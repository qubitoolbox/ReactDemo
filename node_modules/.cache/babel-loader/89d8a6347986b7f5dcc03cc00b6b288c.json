{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuous, isFieldDef } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined } from '../util';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n  const {\n    tooltip\n  } = oldEncoding,\n        filteredEncoding = __rest(oldEncoding, [\"tooltip\"]);\n\n  if (!tooltip) {\n    return {\n      filteredEncoding: oldEncoding\n    };\n  }\n\n  let customTooltipWithAggregatedField;\n  let customTooltipWithoutAggregatedField;\n\n  if (isArray(tooltip)) {\n    tooltip.forEach(t => {\n      if (t.aggregate) {\n        if (!customTooltipWithAggregatedField) {\n          customTooltipWithAggregatedField = [];\n        }\n\n        customTooltipWithAggregatedField.push(t);\n      } else {\n        if (!customTooltipWithoutAggregatedField) {\n          customTooltipWithoutAggregatedField = [];\n        }\n\n        customTooltipWithoutAggregatedField.push(t);\n      }\n    });\n\n    if (customTooltipWithAggregatedField) {\n      filteredEncoding.tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if (tooltip['aggregate']) {\n      filteredEncoding.tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n\n  return {\n    customTooltipWithoutAggregatedField,\n    filteredEncoding\n  };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {\n      tooltip: encodingWithoutContinuousAxis.tooltip\n    };\n  }\n\n  const fiveSummaryTooltip = tooltipSummary.map(({\n    fieldPrefix,\n    titlePrefix\n  }) => ({\n    field: fieldPrefix + continuousAxisChannelDef.field,\n    type: continuousAxisChannelDef.type,\n    title: titlePrefix + (withFieldName ? ' of ' + continuousAxisChannelDef.field : '')\n  }));\n  return {\n    tooltip: [...fiveSummaryTooltip, // need to cast because TextFieldDef support fewer types of bin\n    ...fieldDefs(encodingWithoutContinuousAxis)]\n  };\n}\nexport function getTitle(continuousAxisChannelDef) {\n  const {\n    axis,\n    title,\n    field\n  } = continuousAxisChannelDef;\n  return axis && axis.title !== undefined ? undefined : getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n  const {\n    scale,\n    axis\n  } = continuousAxisChannelDef;\n  return ({\n    partName,\n    mark,\n    positionPrefix,\n    endPositionPrefix = undefined,\n    extraEncoding = {}\n  }) => {\n    const title = getTitle(continuousAxisChannelDef);\n    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n      mark,\n      encoding: Object.assign(Object.assign(Object.assign({\n        [continuousAxis]: Object.assign(Object.assign(Object.assign({\n          field: positionPrefix + '_' + continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type\n        }, title !== undefined ? {\n          title\n        } : {}), scale !== undefined ? {\n          scale\n        } : {}), axis !== undefined ? {\n          axis\n        } : {})\n      }, isString(endPositionPrefix) ? {\n        [continuousAxis + '2']: {\n          field: endPositionPrefix + '_' + continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type\n        }\n      } : {}), sharedEncoding), extraEncoding)\n    });\n  };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n  const {\n    clip,\n    color,\n    opacity\n  } = markDef;\n  const mark = markDef.type;\n\n  if (markDef[part] || markDef[part] === undefined && compositeMarkConfig[part]) {\n    return [Object.assign(Object.assign({}, partBaseSpec), {\n      mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip ? {\n        clip\n      } : {}), color ? {\n        color\n      } : {}), opacity ? {\n        opacity\n      } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {\n        type: partBaseSpec.mark\n      }), {\n        style: `${mark}-${part}`\n      }), isBoolean(markDef[part]) ? {} : markDef[part])\n    })];\n  }\n\n  return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n  const {\n    encoding\n  } = spec;\n  const continuousAxis = orient === 'vertical' ? 'y' : 'x';\n  const continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n\n  const continuousAxisChannelDef2 = encoding[continuousAxis + '2'];\n  const continuousAxisChannelDefError = encoding[continuousAxis + 'Error'];\n  const continuousAxisChannelDefError2 = encoding[continuousAxis + 'Error2'];\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n  if (continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {\n    const {\n      aggregate\n    } = continuousAxisChannelDef,\n          continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, [\"aggregate\"]);\n\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n\n    return continuousAxisWithoutAggregate;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient(spec, compositeMark) {\n  const {\n    mark,\n    encoding\n  } = spec;\n\n  if (isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // x is continuous\n    if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // both x and y are continuous\n      if (encoding.x.aggregate === undefined && encoding.y.aggregate === compositeMark) {\n        return 'vertical';\n      } else if (encoding.y.aggregate === undefined && encoding.x.aggregate === compositeMark) {\n        return 'horizontal';\n      } else if (encoding.x.aggregate === compositeMark && encoding.y.aggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isMarkDef(mark) && mark.orient) {\n          return mark.orient;\n        } // default orientation = vertical\n\n\n        return 'vertical';\n      }\n    } // x is continuous but y is not\n\n\n    return 'horizontal';\n  } else if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error('Need a valid continuous axis for ' + compositeMark + 's');\n  }\n}","map":{"version":3,"sources":["../../../src/compositemark/common.ts"],"names":[],"mappings":"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","sourcesContent":["import {Orientation, Text} from 'vega';\nimport {isArray, isBoolean, isString} from 'vega-util';\nimport {CompositeMark, CompositeMarkDef} from '.';\nimport {\n  Field,\n  FieldDefBase,\n  isContinuous,\n  isFieldDef,\n  PositionFieldDef,\n  SecondaryFieldDef,\n  StringFieldDef,\n  StringFieldDefWithCondition,\n  StringValueDefWithCondition\n} from '../channeldef';\nimport {Encoding, fieldDefs} from '../encoding';\nimport * as log from '../log';\nimport {ColorMixins, GenericMarkDef, isMarkDef, Mark, MarkConfig, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedUnitSpec} from '../spec';\nimport {getFirstDefined} from '../util';\n\nexport type PartsMixins<P extends string> = Partial<Record<P, boolean | MarkConfig>>;\n\nexport type GenericCompositeMarkDef<T> = GenericMarkDef<T> &\n  ColorMixins & {\n    /**\n     * The opacity (value between [0,1]) of the mark.\n     */\n    opacity?: number;\n\n    /**\n     * Whether a composite mark be clipped to the enclosing groupâ€™s width and height.\n     */\n    clip?: boolean;\n  };\n\nexport interface CompositeMarkTooltipSummary {\n  /**\n   * The prefix of the field to be shown in tooltip\n   */\n  fieldPrefix: string;\n\n  /**\n   * The title prefix to show, corresponding to the field with field prefix `fieldPrefix`\n   */\n  titlePrefix: Text;\n}\n\nexport function filterTooltipWithAggregatedField<F extends Field>(\n  oldEncoding: Encoding<F>\n): {\n  customTooltipWithoutAggregatedField?:\n    | StringFieldDefWithCondition<F>\n    | StringValueDefWithCondition<F>\n    | StringFieldDef<F>[];\n  filteredEncoding: Encoding<F>;\n} {\n  const {tooltip, ...filteredEncoding} = oldEncoding;\n  if (!tooltip) {\n    return {filteredEncoding: oldEncoding};\n  }\n\n  let customTooltipWithAggregatedField:\n    | StringFieldDefWithCondition<F>\n    | StringValueDefWithCondition<F>\n    | StringFieldDef<F>[];\n  let customTooltipWithoutAggregatedField:\n    | StringFieldDefWithCondition<F>\n    | StringValueDefWithCondition<F>\n    | StringFieldDef<F>[];\n\n  if (isArray(tooltip)) {\n    tooltip.forEach((t: StringFieldDef<F>) => {\n      if (t.aggregate) {\n        if (!customTooltipWithAggregatedField) {\n          customTooltipWithAggregatedField = [];\n        }\n        (customTooltipWithAggregatedField as StringFieldDef<F>[]).push(t);\n      } else {\n        if (!customTooltipWithoutAggregatedField) {\n          customTooltipWithoutAggregatedField = [];\n        }\n        (customTooltipWithoutAggregatedField as StringFieldDef<F>[]).push(t);\n      }\n    });\n\n    if (customTooltipWithAggregatedField) {\n      (filteredEncoding as Encoding<F>).tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if (tooltip['aggregate']) {\n      (filteredEncoding as Encoding<F>).tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n  return {customTooltipWithoutAggregatedField, filteredEncoding};\n}\n\nexport function getCompositeMarkTooltip(\n  tooltipSummary: CompositeMarkTooltipSummary[],\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  encodingWithoutContinuousAxis: Encoding<string>,\n  withFieldName = true\n): Encoding<string> {\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {tooltip: encodingWithoutContinuousAxis.tooltip};\n  }\n\n  const fiveSummaryTooltip: StringFieldDef<string>[] = tooltipSummary.map(\n    ({fieldPrefix, titlePrefix}): StringFieldDef<string> => ({\n      field: fieldPrefix + continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type,\n      title: titlePrefix + (withFieldName ? ' of ' + continuousAxisChannelDef.field : '')\n    })\n  );\n\n  return {\n    tooltip: [\n      ...fiveSummaryTooltip,\n      // need to cast because TextFieldDef support fewer types of bin\n      ...(fieldDefs(encodingWithoutContinuousAxis) as StringFieldDef<string>[])\n    ]\n  };\n}\n\nexport function getTitle(continuousAxisChannelDef: PositionFieldDef<string>) {\n  const {axis, title, field} = continuousAxisChannelDef;\n  return axis && axis.title !== undefined ? undefined : getFirstDefined(title, field);\n}\n\nexport function makeCompositeAggregatePartFactory<P extends PartsMixins<any>>(\n  compositeMarkDef: GenericCompositeMarkDef<any> & P,\n  continuousAxis: 'x' | 'y',\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  sharedEncoding: Encoding<string>,\n  compositeMarkConfig: P\n) {\n  const {scale, axis} = continuousAxisChannelDef;\n\n  return ({\n    partName,\n    mark,\n    positionPrefix,\n    endPositionPrefix = undefined,\n    extraEncoding = {}\n  }: {\n    partName: keyof P;\n    mark: Mark | MarkDef;\n    positionPrefix: string;\n    endPositionPrefix?: string;\n    extraEncoding?: Encoding<string>;\n  }) => {\n    const title = getTitle(continuousAxisChannelDef);\n\n    return partLayerMixins<P>(compositeMarkDef, partName, compositeMarkConfig, {\n      mark, // TODO better remove this method and just have mark as a parameter of the method\n      encoding: {\n        [continuousAxis]: {\n          field: positionPrefix + '_' + continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type,\n          ...(title !== undefined ? {title} : {}),\n          ...(scale !== undefined ? {scale} : {}),\n          ...(axis !== undefined ? {axis} : {})\n        },\n        ...(isString(endPositionPrefix)\n          ? {\n              [continuousAxis + '2']: {\n                field: endPositionPrefix + '_' + continuousAxisChannelDef.field,\n                type: continuousAxisChannelDef.type\n              }\n            }\n          : {}),\n        ...sharedEncoding,\n        ...extraEncoding\n      }\n    });\n  };\n}\n\nexport function partLayerMixins<P extends PartsMixins<any>>(\n  markDef: GenericCompositeMarkDef<any> & P,\n  part: keyof P,\n  compositeMarkConfig: P,\n  partBaseSpec: NormalizedUnitSpec\n): NormalizedUnitSpec[] {\n  const {clip, color, opacity} = markDef;\n\n  const mark = markDef.type;\n\n  if (markDef[part] || (markDef[part] === undefined && compositeMarkConfig[part])) {\n    return [\n      {\n        ...partBaseSpec,\n        mark: {\n          ...(compositeMarkConfig[part] as MarkConfig),\n          ...(clip ? {clip} : {}),\n          ...(color ? {color} : {}),\n          ...(opacity ? {opacity} : {}),\n          ...(isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {type: partBaseSpec.mark}),\n          style: `${mark}-${part}`,\n          ...(isBoolean(markDef[part]) ? {} : (markDef[part] as MarkConfig))\n        }\n      }\n    ];\n  }\n  return [];\n}\n\nexport function compositeMarkContinuousAxis<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<string>, CompositeMark | CompositeMarkDef>,\n  orient: Orientation,\n  compositeMark: M\n): {\n  continuousAxisChannelDef: PositionFieldDef<string>;\n  continuousAxisChannelDef2: SecondaryFieldDef<string>;\n  continuousAxisChannelDefError: SecondaryFieldDef<string>;\n  continuousAxisChannelDefError2: SecondaryFieldDef<string>;\n  continuousAxis: 'x' | 'y';\n} {\n  const {encoding} = spec;\n  const continuousAxis: 'x' | 'y' = orient === 'vertical' ? 'y' : 'x';\n\n  const continuousAxisChannelDef = encoding[continuousAxis] as PositionFieldDef<string>; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n  const continuousAxisChannelDef2 = encoding[continuousAxis + '2'] as SecondaryFieldDef<string>;\n  const continuousAxisChannelDefError = encoding[continuousAxis + 'Error'] as SecondaryFieldDef<string>;\n  const continuousAxisChannelDefError2 = encoding[continuousAxis + 'Error2'] as SecondaryFieldDef<string>;\n\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef<M extends CompositeMark, F extends FieldDefBase<string>>(\n  continuousAxisChannelDef: F,\n  compositeMark: M\n): F {\n  if (continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {\n    const {aggregate, ...continuousAxisWithoutAggregate} = continuousAxisChannelDef;\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    return continuousAxisWithoutAggregate as F;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<Field>, CompositeMark | CompositeMarkDef>,\n  compositeMark: M\n): Orientation {\n  const {mark, encoding} = spec;\n\n  if (isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // x is continuous\n    if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // both x and y are continuous\n      if (encoding.x.aggregate === undefined && encoding.y.aggregate === compositeMark) {\n        return 'vertical';\n      } else if (encoding.y.aggregate === undefined && encoding.x.aggregate === compositeMark) {\n        return 'horizontal';\n      } else if (encoding.x.aggregate === compositeMark && encoding.y.aggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isMarkDef(mark) && mark.orient) {\n          return mark.orient;\n        }\n\n        // default orientation = vertical\n        return 'vertical';\n      }\n    }\n\n    // x is continuous but y is not\n    return 'horizontal';\n  } else if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error('Need a valid continuous axis for ' + compositeMark + 's');\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}