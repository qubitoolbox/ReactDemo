{"ast":null,"code":"import { isArray, isBoolean } from 'vega-util';\nimport { SUM_OPS } from './aggregate';\nimport { NONPOSITION_CHANNELS, X, X2, Y2 } from './channel';\nimport { getTypedFieldDef, isFieldDef, isStringFieldDef, vgField } from './channeldef';\nimport { channelHasField, isAggregate } from './encoding';\nimport * as log from './log';\nimport { AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, POINT, RULE, SQUARE, TEXT, TICK } from './mark';\nimport { ScaleType } from './scale';\nimport { contains } from './util';\nconst STACK_OFFSET_INDEX = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n};\nexport function isStackOffset(s) {\n  return !!STACK_OFFSET_INDEX[s];\n}\nexport const STACKABLE_MARKS = [BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK];\nexport const STACK_BY_DEFAULT_MARKS = [BAR, AREA];\n\nfunction potentialStackedChannel(encoding) {\n  const xDef = encoding.x;\n  const yDef = encoding.y;\n\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (xDef.type === 'quantitative' && yDef.type === 'quantitative') {\n      if (xDef.stack) {\n        return 'x';\n      } else if (yDef.stack) {\n        return 'y';\n      } // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n\n\n      if (!!xDef.aggregate !== !!yDef.aggregate) {\n        return xDef.aggregate ? 'x' : 'y';\n      }\n    } else if (xDef.type === 'quantitative') {\n      return 'x';\n    } else if (yDef.type === 'quantitative') {\n      return 'y';\n    }\n  } else if (isFieldDef(xDef) && xDef.type === 'quantitative') {\n    return 'x';\n  } else if (isFieldDef(yDef) && yDef.type === 'quantitative') {\n    return 'y';\n  }\n\n  return undefined;\n} // Note: CompassQL uses this method and only passes in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\n\n\nexport function stack(m, encoding, opt = {}) {\n  const mark = isMarkDef(m) ? m.type : m; // Should have stackable mark\n\n  if (!contains(STACKABLE_MARKS, mark)) {\n    return null;\n  }\n\n  const fieldChannel = potentialStackedChannel(encoding);\n\n  if (!fieldChannel) {\n    return null;\n  }\n\n  const stackedFieldDef = encoding[fieldChannel];\n  const stackedField = isStringFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n  const dimensionChannel = fieldChannel === 'x' ? 'y' : 'x';\n  const dimensionDef = encoding[dimensionChannel];\n  const dimensionField = isStringFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined; // Should have grouping level of detail that is different from the dimension field\n\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n    if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach(cDef => {\n        const fieldDef = getTypedFieldDef(cDef);\n\n        if (fieldDef.aggregate) {\n          return;\n        } // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n\n\n        const f = isStringFieldDef(fieldDef) ? vgField(fieldDef, {}) : undefined;\n\n        if ( // if fielddef is a repeat, just include it in the stack by\n        !f || // otherwise, the field must be different from x and y fields.\n        f !== dimensionField && f !== stackedField) {\n          sc.push({\n            channel,\n            fieldDef\n          });\n        }\n      });\n    }\n\n    return sc;\n  }, []); // Automatically determine offset\n\n  let offset;\n\n  if (stackedFieldDef.stack !== undefined) {\n    if (isBoolean(stackedFieldDef.stack)) {\n      offset = stackedFieldDef.stack ? 'zero' : null;\n    } else {\n      offset = stackedFieldDef.stack;\n    }\n  } else if (stackBy.length > 0 && contains(STACK_BY_DEFAULT_MARKS, mark)) {\n    // Bar and Area with sum ops are automatically stacked by default\n    offset = 'zero';\n  }\n\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n\n  if (isAggregate(encoding) && stackBy.length === 0) {\n    return null;\n  } // warn when stacking non-linear\n\n\n  if (stackedFieldDef.scale && stackedFieldDef.scale.type && stackedFieldDef.scale.type !== ScaleType.LINEAR) {\n    if (opt.disallowNonLinearStack) {\n      return null;\n    } else {\n      log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n    }\n  } // Check if it is a ranged mark\n\n\n  if (channelHasField(encoding, fieldChannel === X ? X2 : Y2)) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n\n    return null;\n  } // Warn if stacking non-summative aggregate\n\n\n  if (stackedFieldDef.aggregate && !contains(SUM_OPS, stackedFieldDef.aggregate)) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n\n  return {\n    groupbyChannel: dimensionDef ? dimensionChannel : undefined,\n    fieldChannel,\n    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n    stackBy,\n    offset\n  };\n}","map":{"version":3,"sources":["../../src/stack.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray, isBoolean} from 'vega-util';\nimport {SUM_OPS} from './aggregate';\nimport {NonPositionChannel, NONPOSITION_CHANNELS, X, X2, Y2} from './channel';\nimport {\n  Field,\n  getTypedFieldDef,\n  isFieldDef,\n  isStringFieldDef,\n  PositionFieldDef,\n  TypedFieldDef,\n  vgField\n} from './channeldef';\nimport {channelHasField, Encoding, isAggregate} from './encoding';\nimport * as log from './log';\nimport {AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, Mark, MarkDef, POINT, RULE, SQUARE, TEXT, TICK} from './mark';\nimport {ScaleType} from './scale';\nimport {contains, Flag} from './util';\n\nexport type StackOffset = 'zero' | 'center' | 'normalize';\n\nconst STACK_OFFSET_INDEX: Flag<StackOffset> = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n};\n\nexport function isStackOffset(s: string): s is StackOffset {\n  return !!STACK_OFFSET_INDEX[s];\n}\n\nexport interface StackProperties {\n  /** Dimension axis of the stack. */\n  groupbyChannel: 'x' | 'y';\n\n  /** Measure axis of the stack. */\n  fieldChannel: 'x' | 'y';\n\n  /** Stack-by fields e.g., color, detail */\n  stackBy: {\n    fieldDef: TypedFieldDef<string>;\n    channel: NonPositionChannel;\n  }[];\n\n  /**\n   * See `stack` property of Position Field Def.\n   */\n  offset: StackOffset;\n\n  /**\n   * Whether this stack will produce impute transform\n   */\n  impute: boolean;\n}\n\nexport const STACKABLE_MARKS = [BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK];\nexport const STACK_BY_DEFAULT_MARKS = [BAR, AREA];\n\nfunction potentialStackedChannel(encoding: Encoding<Field>): 'x' | 'y' | undefined {\n  const xDef = encoding.x;\n  const yDef = encoding.y;\n\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (xDef.type === 'quantitative' && yDef.type === 'quantitative') {\n      if (xDef.stack) {\n        return 'x';\n      } else if (yDef.stack) {\n        return 'y';\n      }\n      // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n      if (!!xDef.aggregate !== !!yDef.aggregate) {\n        return xDef.aggregate ? 'x' : 'y';\n      }\n    } else if (xDef.type === 'quantitative') {\n      return 'x';\n    } else if (yDef.type === 'quantitative') {\n      return 'y';\n    }\n  } else if (isFieldDef(xDef) && xDef.type === 'quantitative') {\n    return 'x';\n  } else if (isFieldDef(yDef) && yDef.type === 'quantitative') {\n    return 'y';\n  }\n  return undefined;\n}\n\n// Note: CompassQL uses this method and only passes in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\nexport function stack(\n  m: Mark | MarkDef,\n  encoding: Encoding<Field>,\n  opt: {\n    disallowNonLinearStack?: boolean; // This option is for CompassQL\n  } = {}\n): StackProperties {\n  const mark = isMarkDef(m) ? m.type : m;\n  // Should have stackable mark\n  if (!contains(STACKABLE_MARKS, mark)) {\n    return null;\n  }\n\n  const fieldChannel = potentialStackedChannel(encoding);\n  if (!fieldChannel) {\n    return null;\n  }\n\n  const stackedFieldDef = encoding[fieldChannel] as PositionFieldDef<string>;\n  const stackedField = isStringFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n\n  const dimensionChannel = fieldChannel === 'x' ? 'y' : 'x';\n  const dimensionDef = encoding[dimensionChannel];\n  const dimensionField = isStringFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n\n  // Should have grouping level of detail that is different from the dimension field\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n    if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach(cDef => {\n        const fieldDef = getTypedFieldDef(cDef);\n        if (fieldDef.aggregate) {\n          return;\n        }\n\n        // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n        const f = isStringFieldDef(fieldDef) ? vgField(fieldDef, {}) : undefined;\n        if (\n          // if fielddef is a repeat, just include it in the stack by\n          !f ||\n          // otherwise, the field must be different from x and y fields.\n          (f !== dimensionField && f !== stackedField)\n        ) {\n          sc.push({channel, fieldDef});\n        }\n      });\n    }\n    return sc;\n  }, []);\n\n  // Automatically determine offset\n  let offset: StackOffset;\n  if (stackedFieldDef.stack !== undefined) {\n    if (isBoolean(stackedFieldDef.stack)) {\n      offset = stackedFieldDef.stack ? 'zero' : null;\n    } else {\n      offset = stackedFieldDef.stack;\n    }\n  } else if (stackBy.length > 0 && contains(STACK_BY_DEFAULT_MARKS, mark)) {\n    // Bar and Area with sum ops are automatically stacked by default\n    offset = 'zero';\n  }\n\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n\n  if (isAggregate(encoding) && stackBy.length === 0) {\n    return null;\n  }\n\n  // warn when stacking non-linear\n  if (stackedFieldDef.scale && stackedFieldDef.scale.type && stackedFieldDef.scale.type !== ScaleType.LINEAR) {\n    if (opt.disallowNonLinearStack) {\n      return null;\n    } else {\n      log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n    }\n  }\n\n  // Check if it is a ranged mark\n  if (channelHasField(encoding, fieldChannel === X ? X2 : Y2)) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n    return null;\n  }\n\n  // Warn if stacking non-summative aggregate\n  if (stackedFieldDef.aggregate && !contains(SUM_OPS, stackedFieldDef.aggregate)) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n\n  return {\n    groupbyChannel: dimensionDef ? dimensionChannel : undefined,\n    fieldChannel,\n    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n    stackBy,\n    offset\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}