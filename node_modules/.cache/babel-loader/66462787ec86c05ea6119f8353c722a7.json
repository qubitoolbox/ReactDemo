{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, STROKE, X, Y } from '../../channel';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { SignalRefWrapper } from './../signal';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n  keys(localScaleComponents).forEach(channel => {\n    const specifiedScale = model.specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldDef = model.fieldDef(channel);\n    const config = model.config;\n    const specifiedValue = specifiedScale[property];\n    const sType = mergedScaleCmpt.get('type');\n    const supportedByScaleType = scaleTypeSupportProperty(sType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(sType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        // copyKeyFromObject ensures type safety\n        localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n      } else {\n        const value = getDefaultValue(property, model, channel, fieldDef, mergedScaleCmpt.get('type'), mergedScaleCmpt.get('padding'), mergedScaleCmpt.get('paddingInner'), specifiedScale.domain, model.markDef, config);\n\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  });\n} // Note: This method is used in Voyager.\n\n\nexport function getDefaultValue(property, model, channel, fieldDef, scaleType, scalePadding, scalePaddingInner, specifiedDomain, markDef, config) {\n  const scaleConfig = config.scale;\n  const {\n    type,\n    sort\n  } = fieldDef; // If we have default rule-base, determine default value first\n\n  switch (property) {\n    case 'bins':\n      return bins(model, fieldDef);\n\n    case 'interpolate':\n      return interpolate(channel, type);\n\n    case 'nice':\n      return nice(scaleType, channel, fieldDef);\n\n    case 'padding':\n      return padding(channel, scaleType, scaleConfig, fieldDef, markDef, config.bar);\n\n    case 'paddingInner':\n      return paddingInner(scalePadding, channel, markDef.type, scaleConfig);\n\n    case 'paddingOuter':\n      return paddingOuter(scalePadding, channel, scaleType, markDef.type, scalePaddingInner, scaleConfig);\n\n    case 'reverse':\n      return reverse(scaleType, sort);\n\n    case 'zero':\n      return zero(channel, fieldDef, specifiedDomain, markDef, scaleType);\n  } // Otherwise, use scale config\n\n\n  return scaleConfig[property];\n} // This method is here rather than in range.ts to avoid circular dependency.\n\nexport function parseScaleRange(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n\n  keys(localScaleComponents).forEach(channel => {\n    let valueWithExplicit;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing((v1, v2) => {\n          switch (property) {\n            case 'range':\n              // For step, prefer larger step\n              if (v1.step && v2.step) {\n                return v1.step - v2.step;\n              }\n\n              return 0;\n            // TODO: precedence rule for other properties\n          }\n\n          return 0;\n        }));\n      }\n    }\n\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  });\n}\nexport function bins(model, fieldDef) {\n  const bin = fieldDef.bin;\n\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n\n  return undefined;\n}\nexport function interpolate(channel, type) {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n\n  return undefined;\n}\nexport function nice(scaleType, channel, fieldDef) {\n  if (fieldDef.bin || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n\n  return util.contains([X, Y], channel) ? true : undefined;\n}\nexport function padding(channel, scaleType, scaleConfig, fieldDef, markDef, barConfig) {\n  if (util.contains([X, Y], channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      const {\n        type,\n        orient\n      } = markDef;\n\n      if (type === 'bar' && !fieldDef.bin && !fieldDef.timeUnit) {\n        if (orient === 'vertical' && channel === 'x' || orient === 'horizontal' && channel === 'y') {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n\n  return undefined;\n}\nexport function paddingInner(paddingValue, channel, mark, scaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    const {\n      bandPaddingInner,\n      barBandPaddingInner,\n      rectBandPaddingInner\n    } = scaleConfig;\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n  }\n\n  return undefined;\n}\nexport function paddingOuter(paddingValue, channel, scaleType, mark, paddingInnerValue, scaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      const {\n        bandPaddingOuter\n      } = scaleConfig;\n      return getFirstDefined(bandPaddingOuter,\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n        size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n        and we want the width/height to be integer by default.\n        Note that step (by default) and cardinality are integers.) */\n      paddingInnerValue / 2);\n    }\n  }\n\n  return undefined;\n}\nexport function reverse(scaleType, sort) {\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n\n  return undefined;\n}\nexport function zero(channel, fieldDef, specifiedDomain, markDef, scaleType) {\n  // If users explicitly provide a domain range, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n\n        if (first <= 0 && last >= 0) {\n          // if the domain includes zero, make zero remains true\n          return true;\n        }\n      }\n\n      return false;\n    }\n  } // If there is no custom domain, return true only for the following cases:\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n\n\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  } // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n\n\n  if (!fieldDef.bin && util.contains([X, Y], channel)) {\n    const {\n      orient,\n      type\n    } = markDef;\n\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if (orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x') {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../../../src/compile/scale/properties.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {isBinned, isBinning, isBinParams} from '../../bin';\nimport {Channel, COLOR, FILL, ScaleChannel, STROKE, X, Y} from '../../channel';\nimport {ScaleFieldDef, TypedFieldDef} from '../../channeldef';\nimport {Config} from '../../config';\nimport * as log from '../../log';\nimport {Mark, MarkDef, RectConfig} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  isContinuousToContinuous,\n  isContinuousToDiscrete,\n  NiceTime,\n  Scale,\n  ScaleConfig,\n  ScaleType,\n  scaleTypeSupportProperty\n} from '../../scale';\nimport {Sort} from '../../sort';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {contains, getFirstDefined, keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {isUnitModel, Model} from '../model';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {SignalRefWrapper} from './../signal';\nimport {ScaleComponentIndex, ScaleComponentProps} from './component';\nimport {parseUnitScaleRange} from './range';\n\nexport function parseScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model: UnitModel, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    const specifiedScale = model.specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldDef = model.fieldDef(channel);\n    const config = model.config;\n\n    const specifiedValue = specifiedScale[property];\n    const sType = mergedScaleCmpt.get('type');\n\n    const supportedByScaleType = scaleTypeSupportProperty(sType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(sType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        // copyKeyFromObject ensures type safety\n        localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n      } else {\n        const value = getDefaultValue(\n          property,\n          model,\n          channel,\n          fieldDef,\n          mergedScaleCmpt.get('type'),\n          mergedScaleCmpt.get('padding'),\n          mergedScaleCmpt.get('paddingInner'),\n          specifiedScale.domain,\n          model.markDef,\n          config\n        );\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  });\n}\n\n// Note: This method is used in Voyager.\nexport function getDefaultValue(\n  property: keyof Scale,\n  model: Model,\n  channel: Channel,\n  fieldDef: ScaleFieldDef<string, Type>,\n  scaleType: ScaleType,\n  scalePadding: number,\n  scalePaddingInner: number,\n  specifiedDomain: Scale['domain'],\n  markDef: MarkDef,\n  config: Config\n) {\n  const scaleConfig = config.scale;\n  const {type, sort} = fieldDef;\n\n  // If we have default rule-base, determine default value first\n  switch (property) {\n    case 'bins':\n      return bins(model, fieldDef);\n    case 'interpolate':\n      return interpolate(channel, type);\n    case 'nice':\n      return nice(scaleType, channel, fieldDef);\n    case 'padding':\n      return padding(channel, scaleType, scaleConfig, fieldDef, markDef, config.bar);\n    case 'paddingInner':\n      return paddingInner(scalePadding, channel, markDef.type, scaleConfig);\n    case 'paddingOuter':\n      return paddingOuter(scalePadding, channel, scaleType, markDef.type, scalePaddingInner, scaleConfig);\n    case 'reverse':\n      return reverse(scaleType, sort);\n    case 'zero':\n      return zero(channel, fieldDef, specifiedDomain, markDef, scaleType);\n  }\n  // Otherwise, use scale config\n  return scaleConfig[property];\n}\n\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\n\nexport function parseNonUnitScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n\n  keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    let valueWithExplicit: Explicit<any>;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit<VgScale, any>(\n          valueWithExplicit,\n          childValueWithExplicit,\n          property,\n          'scale',\n          tieBreakByComparing<VgScale, any>((v1, v2) => {\n            switch (property) {\n              case 'range':\n                // For step, prefer larger step\n                if (v1.step && v2.step) {\n                  return v1.step - v2.step;\n                }\n                return 0;\n              // TODO: precedence rule for other properties\n            }\n            return 0;\n          })\n        );\n      }\n    }\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  });\n}\n\nexport function bins(model: Model, fieldDef: TypedFieldDef<string>) {\n  const bin = fieldDef.bin;\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n  return undefined;\n}\n\nexport function interpolate(channel: Channel, type: Type) {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n  return undefined;\n}\n\nexport function nice(scaleType: ScaleType, channel: Channel, fieldDef: TypedFieldDef<string>): boolean | NiceTime {\n  if (fieldDef.bin || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n  return util.contains([X, Y], channel) ? true : undefined;\n}\n\nexport function padding(\n  channel: Channel,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig,\n  fieldDef: TypedFieldDef<string>,\n  markDef: MarkDef,\n  barConfig: RectConfig\n) {\n  if (util.contains([X, Y], channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      const {type, orient} = markDef;\n      if (type === 'bar' && !fieldDef.bin && !fieldDef.timeUnit) {\n        if ((orient === 'vertical' && channel === 'x') || (orient === 'horizontal' && channel === 'y')) {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingInner(paddingValue: number, channel: Channel, mark: Mark, scaleConfig: ScaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n\n    const {bandPaddingInner, barBandPaddingInner, rectBandPaddingInner} = scaleConfig;\n\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n  }\n  return undefined;\n}\n\nexport function paddingOuter(\n  paddingValue: number,\n  channel: Channel,\n  scaleType: ScaleType,\n  mark: Mark,\n  paddingInnerValue: number,\n  scaleConfig: ScaleConfig\n) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      const {bandPaddingOuter} = scaleConfig;\n\n      return getFirstDefined(\n        bandPaddingOuter,\n        /* By default, paddingOuter is paddingInner / 2. The reason is that\n          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n          and we want the width/height to be integer by default.\n          Note that step (by default) and cardinality are integers.) */\n        paddingInnerValue / 2\n      );\n    }\n  }\n  return undefined;\n}\n\nexport function reverse(scaleType: ScaleType, sort: Sort<string>) {\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\n\nexport function zero(\n  channel: Channel,\n  fieldDef: TypedFieldDef<string>,\n  specifiedDomain: Domain,\n  markDef: MarkDef,\n  scaleType: ScaleType\n) {\n  // If users explicitly provide a domain range, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n\n        if (first <= 0 && last >= 0) {\n          // if the domain includes zero, make zero remains true\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  // If there is no custom domain, return true only for the following cases:\n\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  }\n\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  if (!fieldDef.bin && util.contains([X, Y], channel)) {\n    const {orient, type} = markDef;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if ((orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x')) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  return false;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}