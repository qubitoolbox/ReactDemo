{"ast":null,"code":"import { SourceNode } from './source';\nimport { GraticuleNode } from './graticule';\nimport { SequenceNode } from './sequence';\n/**\n * Whether this dataflow node is the source of the dataflow that produces data i.e. a source or a generator.\n */\n\nexport function isDataSourceNode(node) {\n  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;\n}\n/**\n * Abstract base class for BottomUpOptimizer and TopDownOptimizer.\n * Contains only mutation handling logic. Subclasses need to implement iteration logic.\n */\n\nclass OptimizerBase {\n  constructor() {\n    this._mutated = false;\n  } // Once true, _mutated is never set to false\n\n\n  setMutated() {\n    this._mutated = true;\n  }\n\n  get mutatedFlag() {\n    return this._mutated;\n  }\n\n}\n/**\n * Starts from a node and runs the optimization function(the \"run\" method) upwards to the root,\n * depending on the continueFlag and mutatedFlag values returned by the optimization function.\n */\n\n\nexport class BottomUpOptimizer extends OptimizerBase {\n  constructor() {\n    super();\n    this._continue = false;\n  }\n\n  setContinue() {\n    this._continue = true;\n  }\n\n  get continueFlag() {\n    return this._continue;\n  }\n\n  get flags() {\n    return {\n      continueFlag: this.continueFlag,\n      mutatedFlag: this.mutatedFlag\n    };\n  }\n\n  set flags({\n    continueFlag,\n    mutatedFlag\n  }) {\n    if (continueFlag) {\n      this.setContinue();\n    }\n\n    if (mutatedFlag) {\n      this.setMutated();\n    }\n  }\n  /**\n   * Reset the state of the optimizer after it has completed a run from the bottom of the tree to the top.\n   */\n\n\n  reset() {// do nothing\n  }\n\n  optimizeNextFromLeaves(node) {\n    if (isDataSourceNode(node)) {\n      return false;\n    }\n\n    const next = node.parent;\n    const {\n      continueFlag\n    } = this.run(node);\n\n    if (continueFlag) {\n      this.optimizeNextFromLeaves(next);\n    }\n\n    return this.mutatedFlag;\n  }\n\n}\n/**\n * The optimizer function( the \"run\" method), is invoked on the given node and then continues recursively.\n */\n\nexport class TopDownOptimizer extends OptimizerBase {}","map":{"version":3,"sources":["../../../../src/compile/data/optimizer.ts"],"names":[],"mappings":"AAEA,SAAQ,UAAR,QAAyB,UAAzB;AACA,SAAQ,aAAR,QAA4B,aAA5B;AACA,SAAQ,YAAR,QAA2B,YAA3B;AAEA;;;;AAGA,OAAM,SAAU,gBAAV,CAA2B,IAA3B,EAA6C;AACjD,SAAO,IAAI,YAAY,UAAhB,IAA8B,IAAI,YAAY,aAA9C,IAA+D,IAAI,YAAY,YAAtF;AACD;AAED;;;;;AAIA,MAAe,aAAf,CAA4B;AAE1B,EAAA,WAAA,GAAA;AACE,SAAK,QAAL,GAAgB,KAAhB;AACD,GAJyB,CAK1B;;;AACO,EAAA,UAAU,GAAA;AACf,SAAK,QAAL,GAAgB,IAAhB;AACD;;AAED,MAAI,WAAJ,GAAe;AACb,WAAO,KAAK,QAAZ;AACD;;AAZyB;AAe5B;;;;;;AAIA,OAAM,MAAgB,iBAAhB,SAA0C,aAA1C,CAAuD;AAG3D,EAAA,WAAA,GAAA;AACE;AACA,SAAK,SAAL,GAAiB,KAAjB;AACD;;AAEM,EAAA,WAAW,GAAA;AAChB,SAAK,SAAL,GAAiB,IAAjB;AACD;;AAED,MAAI,YAAJ,GAAgB;AACd,WAAO,KAAK,SAAZ;AACD;;AAED,MAAI,KAAJ,GAAS;AACP,WAAO;AAAC,MAAA,YAAY,EAAE,KAAK,YAApB;AAAkC,MAAA,WAAW,EAAE,KAAK;AAApD,KAAP;AACD;;AAED,MAAI,KAAJ,CAAU;AAAC,IAAA,YAAD;AAAe,IAAA;AAAf,GAAV,EAAqD;AACnD,QAAI,YAAJ,EAAkB;AAChB,WAAK,WAAL;AACD;;AACD,QAAI,WAAJ,EAAiB;AACf,WAAK,UAAL;AACD;AACF;AAID;;;;;AAGO,EAAA,KAAK,GAAA,CACV;AACD;;AAEM,EAAA,sBAAsB,CAAC,IAAD,EAAmB;AAC9C,QAAI,gBAAgB,CAAC,IAAD,CAApB,EAA4B;AAC1B,aAAO,KAAP;AACD;;AACD,UAAM,IAAI,GAAG,IAAI,CAAC,MAAlB;AACA,UAAM;AAAC,MAAA;AAAD,QAAiB,KAAK,GAAL,CAAS,IAAT,CAAvB;;AACA,QAAI,YAAJ,EAAkB;AAChB,WAAK,sBAAL,CAA4B,IAA5B;AACD;;AACD,WAAO,KAAK,WAAZ;AACD;;AAhD0D;AAmD7D;;;;AAGA,OAAM,MAAgB,gBAAhB,SAAyC,aAAzC,CAAsD","sourcesContent":["import {DataFlowNode} from './dataflow';\nimport {OptimizerFlags} from './optimizers';\nimport {SourceNode} from './source';\nimport {GraticuleNode} from './graticule';\nimport {SequenceNode} from './sequence';\n\n/**\n * Whether this dataflow node is the source of the dataflow that produces data i.e. a source or a generator.\n */\nexport function isDataSourceNode(node: DataFlowNode) {\n  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;\n}\n\n/**\n * Abstract base class for BottomUpOptimizer and TopDownOptimizer.\n * Contains only mutation handling logic. Subclasses need to implement iteration logic.\n */\nabstract class OptimizerBase {\n  private _mutated: boolean;\n  constructor() {\n    this._mutated = false;\n  }\n  // Once true, _mutated is never set to false\n  public setMutated() {\n    this._mutated = true;\n  }\n\n  get mutatedFlag() {\n    return this._mutated;\n  }\n}\n\n/**\n * Starts from a node and runs the optimization function(the \"run\" method) upwards to the root,\n * depending on the continueFlag and mutatedFlag values returned by the optimization function.\n */\nexport abstract class BottomUpOptimizer extends OptimizerBase {\n  private _continue: boolean;\n\n  constructor() {\n    super();\n    this._continue = false;\n  }\n\n  public setContinue() {\n    this._continue = true;\n  }\n\n  get continueFlag() {\n    return this._continue;\n  }\n\n  get flags(): OptimizerFlags {\n    return {continueFlag: this.continueFlag, mutatedFlag: this.mutatedFlag};\n  }\n\n  set flags({continueFlag, mutatedFlag}: OptimizerFlags) {\n    if (continueFlag) {\n      this.setContinue();\n    }\n    if (mutatedFlag) {\n      this.setMutated();\n    }\n  }\n\n  public abstract run(node: DataFlowNode): OptimizerFlags;\n\n  /**\n   * Reset the state of the optimizer after it has completed a run from the bottom of the tree to the top.\n   */\n  public reset(): void {\n    // do nothing\n  }\n\n  public optimizeNextFromLeaves(node: DataFlowNode): boolean {\n    if (isDataSourceNode(node)) {\n      return false;\n    }\n    const next = node.parent;\n    const {continueFlag} = this.run(node);\n    if (continueFlag) {\n      this.optimizeNextFromLeaves(next);\n    }\n    return this.mutatedFlag;\n  }\n}\n\n/**\n * The optimizer function( the \"run\" method), is invoked on the given node and then continues recursively.\n */\nexport abstract class TopDownOptimizer extends OptimizerBase {\n  public abstract run(node: DataFlowNode): boolean;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}