{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { some } from '../../util';\nimport { Split } from '../split';\nexport class ScaleComponent extends Split {\n  constructor(name, typeWithExplicit) {\n    super({}, // no initial explicit property\n    {\n      name\n    } // name as initial implicit property\n    );\n    this.merged = false;\n    this.setWithExplicit('type', typeWithExplicit);\n  }\n  /**\n   * Whether the scale definitely includes zero in the domain\n   */\n\n\n  domainDefinitelyIncludesZero() {\n    if (this.get('zero') !== false) {\n      return true;\n    }\n\n    return some(this.get('domains'), d => isArray(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/scale/component.ts"],"names":[],"mappings":"AAAA,SAAQ,OAAR,QAAsB,WAAtB;AAGA,SAAQ,IAAR,QAAmB,YAAnB;AAEA,SAAkB,KAAlB,QAA8B,UAA9B;AAYA,OAAM,MAAO,cAAP,SAA8B,KAA9B,CAAwD;AAG5D,EAAA,WAAA,CAAY,IAAZ,EAA0B,gBAA1B,EAA+D;AAC7D,UACE,EADF,EACM;AACJ;AAAC,MAAA;AAAD,KAFF,CAES;AAFT;AAHK,SAAA,MAAA,GAAS,KAAT;AAOL,SAAK,eAAL,CAAqB,MAArB,EAA6B,gBAA7B;AACD;AAED;;;;;AAGO,EAAA,4BAA4B,GAAA;AACjC,QAAI,KAAK,GAAL,CAAS,MAAT,MAAqB,KAAzB,EAAgC;AAC9B,aAAO,IAAP;AACD;;AACD,WAAO,IAAI,CAAC,KAAK,GAAL,CAAS,SAAT,CAAD,EAAsB,CAAC,IAAI,OAAO,CAAC,CAAD,CAAP,IAAc,CAAC,CAAC,MAAF,KAAa,CAA3B,IAAgC,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAxC,IAA6C,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAhF,CAAX;AACD;;AAnB2D","sourcesContent":["import {isArray} from 'vega-util';\nimport {ScaleChannel} from '../../channel';\nimport {Scale, ScaleType} from '../../scale';\nimport {some} from '../../util';\nimport {VgNonUnionDomain, VgScale} from '../../vega.schema';\nimport {Explicit, Split} from '../split';\nimport {SelectionExtent} from '../../selection';\n\n/**\n * All VgDomain property except domain.\n * (We exclude domain as we have a special \"domains\" array that allow us merge them all at once in assemble.)\n */\nexport type ScaleComponentProps = Omit<VgScale, 'domain' | 'domainRaw'> & {\n  domains: VgNonUnionDomain[];\n  selectionExtent?: SelectionExtent;\n};\n\nexport class ScaleComponent extends Split<ScaleComponentProps> {\n  public merged = false;\n\n  constructor(name: string, typeWithExplicit: Explicit<ScaleType>) {\n    super(\n      {}, // no initial explicit property\n      {name} // name as initial implicit property\n    );\n    this.setWithExplicit('type', typeWithExplicit);\n  }\n\n  /**\n   * Whether the scale definitely includes zero in the domain\n   */\n  public domainDefinitelyIncludesZero() {\n    if (this.get('zero') !== false) {\n      return true;\n    }\n    return some(this.get('domains'), d => isArray(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);\n  }\n}\n\n// Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\nexport type ScaleComponentIndex = {[P in ScaleChannel]?: ScaleComponent};\n\nexport type ScaleIndex = {[P in ScaleChannel]?: Scale};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}