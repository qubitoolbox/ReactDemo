{"ast":null,"code":"import parseAutosize from './autosize';\nimport parsePadding from './padding';\nimport parseSignal from './signal';\nimport parseSpec from './spec';\nimport { encoders, extendEncode } from './encode/encode-util';\nimport { GroupMark } from './marks/marktypes';\nimport { FrameRole } from './marks/roles';\nimport { ref, operator } from '../util';\nimport DataScope from '../DataScope';\nimport { Bound, Collect, Encode, Render, Sieve, ViewLayout } from '../transforms';\nimport { array, toSet } from 'vega-util';\nvar defined = toSet(['width', 'height', 'padding', 'autosize']);\nexport default function parseView(spec, scope) {\n  var config = scope.config,\n      op,\n      input,\n      encode,\n      parent,\n      root,\n      signals;\n  scope.background = spec.background || config.background;\n  scope.eventConfig = config.events;\n  root = ref(scope.root = scope.add(operator()));\n  scope.addSignal('width', spec.width || 0);\n  scope.addSignal('height', spec.height || 0);\n  scope.addSignal('padding', parsePadding(spec.padding, config));\n  scope.addSignal('autosize', parseAutosize(spec.autosize, config));\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout); // parse signal definitions, including config entries\n\n  signals = addSignals(scope, spec.signals, config.signals); // Store root group item\n\n  input = scope.add(Collect()); // Encode root group item\n\n  encode = extendEncode({\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    },\n    update: {\n      width: {\n        signal: 'width'\n      },\n      height: {\n        signal: 'height'\n      }\n    }\n  }, spec.encode);\n  encode = scope.add(Encode(encoders(encode, GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  }))); // Perform view layout\n\n  parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop(); // Parse remainder of specification\n\n  scope.pushState(ref(encode), ref(parent), null);\n  parseSpec(spec, scope, signals);\n  scope.operators.push(parent); // Bound / render / sieve root item\n\n  op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  })); // Track metadata for root item\n\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\n\nfunction addSignals(scope, signals, config) {\n  // signals defined in the spec take priority\n  array(signals).forEach(_ => {\n    if (!defined[_.name]) parseSignal(_, scope);\n  });\n  if (!config) return signals;\n  const out = array(signals).slice(); // add config signals if not already defined\n\n  array(config).forEach(_ => {\n    if (!scope.hasOwnSignal(_.name)) {\n      parseSignal(_, scope);\n      out.push(_);\n    }\n  });\n  return out;\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/view.js"],"names":["parseAutosize","parsePadding","parseSignal","parseSpec","encoders","extendEncode","GroupMark","FrameRole","ref","operator","DataScope","Bound","Collect","Encode","Render","Sieve","ViewLayout","array","toSet","defined","parseView","spec","scope","config","op","input","encode","parent","root","signals","background","eventConfig","events","add","addSignal","width","height","padding","autosize","legends","objectProperty","legend","layout","addSignals","enter","x","value","y","update","signal","style","pulse","signalRef","mark","operators","pop","pushState","push","addData","forEach","_","name","out","slice","hasOwnSignal"],"mappings":"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","sourcesContent":["import parseAutosize from './autosize';\nimport parsePadding from './padding';\nimport parseSignal from './signal';\nimport parseSpec from './spec';\nimport {encoders, extendEncode} from './encode/encode-util';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole} from './marks/roles';\nimport {ref, operator} from '../util';\nimport DataScope from '../DataScope';\nimport {Bound, Collect, Encode, Render, Sieve, ViewLayout} from '../transforms';\nimport {array, toSet} from 'vega-util';\n\nvar defined = toSet(['width', 'height', 'padding', 'autosize']);\n\nexport default function parseView(spec, scope) {\n  var config = scope.config,\n      op, input, encode, parent, root, signals;\n\n  scope.background = spec.background || config.background;\n  scope.eventConfig = config.events;\n  root = ref(scope.root = scope.add(operator()));\n  scope.addSignal('width', spec.width || 0);\n  scope.addSignal('height', spec.height || 0);\n  scope.addSignal('padding', parsePadding(spec.padding, config));\n  scope.addSignal('autosize', parseAutosize(spec.autosize, config));\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n\n  // parse signal definitions, including config entries\n  signals = addSignals(scope, spec.signals, config.signals);\n\n  // Store root group item\n  input = scope.add(Collect());\n\n  // Encode root group item\n  encode = extendEncode({\n    enter: { x: {value: 0}, y: {value: 0} },\n    update: { width: {signal: 'width'}, height: {signal: 'height'} }\n  }, spec.encode);\n\n  encode = scope.add(Encode(\n    encoders(encode, GroupMark, FrameRole, spec.style, scope, {pulse: ref(input)}))\n  );\n\n  // Perform view layout\n  parent = scope.add(ViewLayout({\n    layout:       scope.objectProperty(spec.layout),\n    legends:      scope.legends,\n    autosize:     scope.signalRef('autosize'),\n    mark:         root,\n    pulse:        ref(encode)\n  }));\n  scope.operators.pop();\n\n  // Parse remainder of specification\n  scope.pushState(ref(encode), ref(parent), null);\n  parseSpec(spec, scope, signals);\n  scope.operators.push(parent);\n\n  // Bound / render / sieve root item\n  op = scope.add(Bound({mark: root, pulse: ref(parent)}));\n  op = scope.add(Render({pulse: ref(op)}));\n  op = scope.add(Sieve({pulse: ref(op)}));\n\n  // Track metadata for root item\n  scope.addData('root', new DataScope(scope, input, input, op));\n\n  return scope;\n}\n\nfunction addSignals(scope, signals, config) {\n  // signals defined in the spec take priority\n  array(signals).forEach(_ => {\n    if (!defined[_.name]) parseSignal(_, scope)\n  });\n\n  if (!config) return signals;\n  const out = array(signals).slice();\n\n  // add config signals if not already defined\n  array(config).forEach(_ => {\n    if (!scope.hasOwnSignal(_.name)) {\n      parseSignal(_, scope);\n      out.push(_);\n    }\n  });\n\n  return out;\n}\n"]},"metadata":{},"sourceType":"module"}