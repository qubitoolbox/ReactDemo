{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { keys } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { isConcatModel, isLayerModel, isRepeatModel } from '../model';\nimport { assembleSelectionScaleDomain } from '../selection/assemble';\nimport { assembleDomain } from './domain';\nexport function assembleScales(model) {\n  if (isLayerModel(model) || isConcatModel(model) || isRepeatModel(model)) {\n    // For concat / layer / repeat, include scales of children too\n    return model.children.reduce((scales, child) => {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\nexport function assembleScalesForModel(model) {\n  return keys(model.component.scales).reduce((scales, channel) => {\n    const scaleComponent = model.component.scales[channel];\n\n    if (scaleComponent.merged) {\n      // Skipped merged scales\n      return scales;\n    }\n\n    const scale = scaleComponent.combine();\n\n    const {\n      name,\n      type,\n      selectionExtent,\n      domains: _d,\n      range: _r\n    } = scale,\n          otherScaleProps = __rest(scale, [\"name\", \"type\", \"selectionExtent\", \"domains\", \"range\"]);\n\n    const range = assembleScaleRange(scale.range, name, channel);\n    let domainRaw;\n\n    if (selectionExtent) {\n      domainRaw = assembleSelectionScaleDomain(model, selectionExtent);\n    }\n\n    const domain = assembleDomain(model, channel);\n    scales.push(Object.assign(Object.assign(Object.assign(Object.assign({\n      name,\n      type\n    }, domain ? {\n      domain\n    } : {}), domainRaw ? {\n      domainRaw\n    } : {}), {\n      range: range\n    }), otherScaleProps));\n    return scales;\n  }, []);\n}\nexport function assembleScaleRange(scaleRange, scaleName, channel) {\n  // add signals to x/y range\n  if (channel === 'x' || channel === 'y') {\n    if (isVgRangeStep(scaleRange)) {\n      // For width/height step, use a signal created in layout assemble instead of a constant step.\n      return {\n        step: {\n          signal: scaleName + '_step'\n        }\n      };\n    }\n  }\n\n  return scaleRange;\n}","map":{"version":3,"sources":["../../../../src/compile/scale/assemble.ts"],"names":[],"mappings":";AACA,SAAQ,IAAR,QAAmB,YAAnB;AACA,SAAQ,aAAR,QAA8C,mBAA9C;AACA,SAAQ,aAAR,EAAuB,YAAvB,EAAqC,aAArC,QAAgE,UAAhE;AACA,SAAQ,4BAAR,QAA2C,uBAA3C;AACA,SAAQ,cAAR,QAA6B,UAA7B;AAEA,OAAM,SAAU,cAAV,CAAyB,KAAzB,EAAqC;AACzC,MAAI,YAAY,CAAC,KAAD,CAAZ,IAAuB,aAAa,CAAC,KAAD,CAApC,IAA+C,aAAa,CAAC,KAAD,CAAhE,EAAyE;AACvE;AACA,WAAO,KAAK,CAAC,QAAN,CAAe,MAAf,CAAsB,CAAC,MAAD,EAAS,KAAT,KAAkB;AAC7C,aAAO,MAAM,CAAC,MAAP,CAAc,cAAc,CAAC,KAAD,CAA5B,CAAP;AACD,KAFM,EAEJ,sBAAsB,CAAC,KAAD,CAFlB,CAAP;AAGD,GALD,MAKO;AACL;AACA;AACA,WAAO,sBAAsB,CAAC,KAAD,CAA7B;AACD;AACF;AAED,OAAM,SAAU,sBAAV,CAAiC,KAAjC,EAA6C;AACjD,SAAO,IAAI,CAAC,KAAK,CAAC,SAAN,CAAgB,MAAjB,CAAJ,CAA6B,MAA7B,CAAoC,CAAC,MAAD,EAAoB,OAApB,KAA6C;AACtF,UAAM,cAAc,GAAG,KAAK,CAAC,SAAN,CAAgB,MAAhB,CAAuB,OAAvB,CAAvB;;AACA,QAAI,cAAc,CAAC,MAAnB,EAA2B;AACzB;AACA,aAAO,MAAP;AACD;;AAED,UAAM,KAAK,GAAG,cAAc,CAAC,OAAf,EAAd;;AACA,UAAM;AAAC,MAAA,IAAD;AAAO,MAAA,IAAP;AAAa,MAAA,eAAb;AAA8B,MAAA,OAAO,EAAE,EAAvC;AAA2C,MAAA,KAAK,EAAE;AAAlD,QAA4E,KAAlF;AAAA,UAA4D,eAAA,GAAA,MAAA,CAAA,KAAA,EAAA,CAAA,MAAA,EAAA,MAAA,EAAA,iBAAA,EAAA,SAAA,EAAA,OAAA,CAAA,CAA5D;;AACA,UAAM,KAAK,GAAG,kBAAkB,CAAC,KAAK,CAAC,KAAP,EAAc,IAAd,EAAoB,OAApB,CAAhC;AAEA,QAAI,SAAJ;;AACA,QAAI,eAAJ,EAAqB;AACnB,MAAA,SAAS,GAAG,4BAA4B,CAAC,KAAD,EAAQ,eAAR,CAAxC;AACD;;AAED,UAAM,MAAM,GAAG,cAAc,CAAC,KAAD,EAAQ,OAAR,CAA7B;AAEA,IAAA,MAAM,CAAC,IAAP,CAAW,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACT,MAAA,IADS;AAET,MAAA;AAFS,KAAA,EAGL,MAAM,GAAG;AAAC,MAAA;AAAD,KAAH,GAAc,EAHf,CAAA,EAIL,SAAS,GAAG;AAAC,MAAA;AAAD,KAAH,GAAiB,EAJrB,CAAA,EAIwB;AACjC,MAAA,KAAK,EAAE;AAD0B,KAJxB,CAAA,EAMN,eANM,CAAX;AASA,WAAO,MAAP;AACD,GA5BM,EA4BJ,EA5BI,CAAP;AA6BD;AAED,OAAM,SAAU,kBAAV,CAA6B,UAA7B,EAAkD,SAAlD,EAAqE,OAArE,EAAqF;AACzF;AACA,MAAI,OAAO,KAAK,GAAZ,IAAmB,OAAO,KAAK,GAAnC,EAAwC;AACtC,QAAI,aAAa,CAAC,UAAD,CAAjB,EAA+B;AAC7B;AACA,aAAO;AACL,QAAA,IAAI,EAAE;AAAC,UAAA,MAAM,EAAE,SAAS,GAAG;AAArB;AADD,OAAP;AAGD;AACF;;AACD,SAAO,UAAP;AACD","sourcesContent":["import {Channel, ScaleChannel} from '../../channel';\nimport {keys} from '../../util';\nimport {isVgRangeStep, VgRange, VgScale} from '../../vega.schema';\nimport {isConcatModel, isLayerModel, isRepeatModel, Model} from '../model';\nimport {assembleSelectionScaleDomain} from '../selection/assemble';\nimport {assembleDomain} from './domain';\n\nexport function assembleScales(model: Model): VgScale[] {\n  if (isLayerModel(model) || isConcatModel(model) || isRepeatModel(model)) {\n    // For concat / layer / repeat, include scales of children too\n    return model.children.reduce((scales, child) => {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\n\nexport function assembleScalesForModel(model: Model): VgScale[] {\n  return keys(model.component.scales).reduce((scales: VgScale[], channel: ScaleChannel) => {\n    const scaleComponent = model.component.scales[channel];\n    if (scaleComponent.merged) {\n      // Skipped merged scales\n      return scales;\n    }\n\n    const scale = scaleComponent.combine();\n    const {name, type, selectionExtent, domains: _d, range: _r, ...otherScaleProps} = scale;\n    const range = assembleScaleRange(scale.range, name, channel);\n\n    let domainRaw;\n    if (selectionExtent) {\n      domainRaw = assembleSelectionScaleDomain(model, selectionExtent);\n    }\n\n    const domain = assembleDomain(model, channel);\n\n    scales.push({\n      name,\n      type,\n      ...(domain ? {domain} : {}),\n      ...(domainRaw ? {domainRaw} : {}),\n      range: range,\n      ...otherScaleProps\n    });\n\n    return scales;\n  }, [] as VgScale[]);\n}\n\nexport function assembleScaleRange(scaleRange: VgRange, scaleName: string, channel: Channel): VgRange {\n  // add signals to x/y range\n  if (channel === 'x' || channel === 'y') {\n    if (isVgRangeStep(scaleRange)) {\n      // For width/height step, use a signal created in layout assemble instead of a constant step.\n      return {\n        step: {signal: scaleName + '_step'}\n      };\n    }\n  }\n  return scaleRange;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}