{"ast":null,"code":"/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\nimport { __rest } from \"tslib\";\nimport { keys } from './util'; // Facet\n\nexport const ROW = 'row';\nexport const COLUMN = 'column';\nexport const FACET = 'facet'; // Position\n\nexport const X = 'x';\nexport const Y = 'y';\nexport const X2 = 'x2';\nexport const Y2 = 'y2'; // Geo Position\n\nexport const LATITUDE = 'latitude';\nexport const LONGITUDE = 'longitude';\nexport const LATITUDE2 = 'latitude2';\nexport const LONGITUDE2 = 'longitude2'; // Mark property with scale\n\nexport const COLOR = 'color';\nexport const FILL = 'fill';\nexport const STROKE = 'stroke';\nexport const SHAPE = 'shape';\nexport const SIZE = 'size';\nexport const OPACITY = 'opacity';\nexport const FILLOPACITY = 'fillOpacity';\nexport const STROKEOPACITY = 'strokeOpacity';\nexport const STROKEWIDTH = 'strokeWidth'; // Non-scale channel\n\nexport const TEXT = 'text';\nexport const ORDER = 'order';\nexport const DETAIL = 'detail';\nexport const KEY = 'key';\nexport const TOOLTIP = 'tooltip';\nexport const HREF = 'href';\nexport const URL = 'url';\nconst POSITION_CHANNEL_INDEX = {\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1\n};\nexport function isPositionChannel(c) {\n  return c in POSITION_CHANNEL_INDEX;\n}\nexport function getPositionChannelFromLatLong(channel) {\n  switch (channel) {\n    case LATITUDE:\n      return 'y';\n\n    case LATITUDE2:\n      return 'y2';\n\n    case LONGITUDE:\n      return 'x';\n\n    case LONGITUDE2:\n      return 'x2';\n  }\n}\nconst GEOPOSITION_CHANNEL_INDEX = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\nexport function isGeoPositionChannel(c) {\n  return c in GEOPOSITION_CHANNEL_INDEX;\n}\nexport const GEOPOSITION_CHANNELS = keys(GEOPOSITION_CHANNEL_INDEX);\nconst UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), GEOPOSITION_CHANNEL_INDEX), {\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1,\n  size: 1,\n  shape: 1,\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1,\n  url: 1\n});\nexport function isColorChannel(channel) {\n  return channel === 'color' || channel === 'fill' || channel === 'stroke';\n}\nconst FACET_CHANNEL_INDEX = {\n  row: 1,\n  column: 1,\n  facet: 1\n};\nexport const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\nconst CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);\nexport const CHANNELS = keys(CHANNEL_INDEX);\n\nconst {\n  order: _o,\n  detail: _d,\n  tooltip: _tt1\n} = CHANNEL_INDEX,\n      SINGLE_DEF_CHANNEL_INDEX = __rest(CHANNEL_INDEX, [\"order\", \"detail\", \"tooltip\"]);\n\nconst {\n  row: _r,\n  column: _c,\n  facet: _f\n} = SINGLE_DEF_CHANNEL_INDEX,\n      SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest(SINGLE_DEF_CHANNEL_INDEX, [\"row\", \"column\", \"facet\"]);\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\n\nexport const SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\nexport const SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\nexport function isSingleDefUnitChannel(str) {\n  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];\n}\nexport function isChannel(str) {\n  return !!CHANNEL_INDEX[str];\n}\nexport const SECONDARY_RANGE_CHANNEL = ['x2', 'y2', 'latitude2', 'longitude2'];\nexport function isSecondaryRangeChannel(c) {\n  const main = getMainRangeChannel(c);\n  return main !== c;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getMainRangeChannel(channel) {\n  switch (channel) {\n    case 'x2':\n      return 'x';\n\n    case 'y2':\n      return 'y';\n\n    case 'latitude2':\n      return 'latitude';\n\n    case 'longitude2':\n      return 'longitude';\n  }\n\n  return channel;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getSecondaryRangeChannel(channel) {\n  switch (channel) {\n    case 'x':\n      return 'x2';\n\n    case 'y':\n      return 'y2';\n\n    case 'latitude':\n      return 'latitude2';\n\n    case 'longitude':\n      return 'longitude2';\n  }\n\n  return undefined;\n} // CHANNELS without COLUMN, ROW\n\nexport const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX); // NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\n\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2\n} = UNIT_CHANNEL_INDEX,\n      // The rest of unit channels then have scale\nNONPOSITION_CHANNEL_INDEX = __rest(UNIT_CHANNEL_INDEX, [\"x\", \"y\", \"x2\", \"y2\", \"latitude\", \"longitude\", \"latitude2\", \"longitude2\"]);\n\nexport const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX); // POSITION_SCALE_CHANNELS = X and Y;\n\nconst POSITION_SCALE_CHANNEL_INDEX = {\n  x: 1,\n  y: 1\n};\nexport const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport function getSizeType(channel) {\n  return channel === 'x' ? 'width' : 'height';\n}\nexport function getPositionScaleChannel(sizeType) {\n  return sizeType === 'width' ? 'x' : 'y';\n} // NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\n\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  url: _u,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo\n} = NONPOSITION_CHANNEL_INDEX,\n      NONPOSITION_SCALE_CHANNEL_INDEX = __rest(NONPOSITION_CHANNEL_INDEX, [\"text\", \"tooltip\", \"href\", \"url\", \"detail\", \"key\", \"order\"]);\n\nexport const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport function isNonPositionScaleChannel(channel) {\n  return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n/**\n * @returns whether Vega supports legends for a particular channel\n */\n\nexport function supportLegend(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case STROKEWIDTH:\n      return true;\n\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      return false;\n  }\n} // Declare SCALE_CHANNEL_INDEX\n\nconst SCALE_CHANNEL_INDEX = Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);\n/** List of channels with scales */\n\nexport const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport function isScaleChannel(channel) {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\n\nexport function supportMark(channel, mark) {\n  return getSupportedMark(channel)[mark];\n}\nconst ALL_MARKS = {\n  // all marks\n  area: 'always',\n  bar: 'always',\n  circle: 'always',\n  geoshape: 'always',\n  image: 'always',\n  line: 'always',\n  rule: 'always',\n  point: 'always',\n  rect: 'always',\n  square: 'always',\n  trail: 'always',\n  text: 'always',\n  tick: 'always'\n};\n\nconst {\n  geoshape: _g\n} = ALL_MARKS,\n      ALL_MARKS_EXCEPT_GEOSHAPE = __rest(ALL_MARKS, [\"geoshape\"]);\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\n\n\nfunction getSupportedMark(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE: // falls through\n\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH: // falls through\n\n    case FACET:\n    case ROW: // falls through\n\n    case COLUMN:\n      return ALL_MARKS;\n\n    case X:\n    case Y:\n    case LATITUDE:\n    case LONGITUDE:\n      // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n      return ALL_MARKS_EXCEPT_GEOSHAPE;\n\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        area: 'always',\n        bar: 'always',\n        image: 'always',\n        rect: 'always',\n        rule: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned',\n        line: 'binned',\n        trail: 'binned'\n      };\n\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n\n    case SHAPE:\n      return {\n        point: 'always',\n        geoshape: 'always'\n      };\n\n    case TEXT:\n      return {\n        text: 'always'\n      };\n\n    case URL:\n      return {\n        image: 'always'\n      };\n  }\n}\n\nexport function rangeType(channel) {\n  switch (channel) {\n    case X:\n    case Y:\n    case SIZE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY: // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n\n    case X2:\n    case Y2:\n      return undefined;\n\n    case FACET:\n    case ROW:\n    case COLUMN:\n    case SHAPE: // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n      return 'discrete';\n    // Color can be either continuous or discrete, depending on scale type.\n\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n}","map":{"version":3,"sources":["../../src/channel.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {RangeType} from './compile/scale/type';\nimport {Encoding} from './encoding';\nimport {Mark} from './mark';\nimport {EncodingFacetMapping, EncodingFacetMapping as ExtendedFacetMapping} from './spec/facet';\nimport {Flag, keys} from './util';\n\nexport type Channel = keyof Encoding<any> | keyof ExtendedFacetMapping<any>;\n\n// Facet\nexport const ROW: 'row' = 'row';\nexport const COLUMN: 'column' = 'column';\n\nexport const FACET: 'facet' = 'facet';\n\n// Position\nexport const X: 'x' = 'x';\nexport const Y: 'y' = 'y';\nexport const X2: 'x2' = 'x2';\nexport const Y2: 'y2' = 'y2';\n\n// Geo Position\nexport const LATITUDE: 'latitude' = 'latitude';\nexport const LONGITUDE: 'longitude' = 'longitude';\nexport const LATITUDE2: 'latitude2' = 'latitude2';\nexport const LONGITUDE2: 'longitude2' = 'longitude2';\n\n// Mark property with scale\nexport const COLOR: 'color' = 'color';\n\nexport const FILL: 'fill' = 'fill';\n\nexport const STROKE: 'stroke' = 'stroke';\n\nexport const SHAPE: 'shape' = 'shape';\nexport const SIZE: 'size' = 'size';\nexport const OPACITY: 'opacity' = 'opacity';\nexport const FILLOPACITY: 'fillOpacity' = 'fillOpacity';\n\nexport const STROKEOPACITY: 'strokeOpacity' = 'strokeOpacity';\n\nexport const STROKEWIDTH: 'strokeWidth' = 'strokeWidth';\n\n// Non-scale channel\nexport const TEXT: 'text' = 'text';\nexport const ORDER: 'order' = 'order';\nexport const DETAIL: 'detail' = 'detail';\nexport const KEY: 'key' = 'key';\n\nexport const TOOLTIP: 'tooltip' = 'tooltip';\nexport const HREF: 'href' = 'href';\n\nexport const URL: 'url' = 'url';\n\nexport type PositionChannel = 'x' | 'y' | 'x2' | 'y2';\n\nconst POSITION_CHANNEL_INDEX: Flag<PositionChannel> = {\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1\n};\nexport function isPositionChannel(c: Channel): c is PositionChannel {\n  return c in POSITION_CHANNEL_INDEX;\n}\n\nexport type GeoPositionChannel = 'longitude' | 'latitude' | 'longitude2' | 'latitude2';\n\nexport function getPositionChannelFromLatLong(channel: GeoPositionChannel): PositionChannel {\n  switch (channel) {\n    case LATITUDE:\n      return 'y';\n    case LATITUDE2:\n      return 'y2';\n    case LONGITUDE:\n      return 'x';\n    case LONGITUDE2:\n      return 'x2';\n  }\n}\n\nconst GEOPOSITION_CHANNEL_INDEX: Flag<GeoPositionChannel> = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\n\nexport function isGeoPositionChannel(c: Channel): c is GeoPositionChannel {\n  return c in GEOPOSITION_CHANNEL_INDEX;\n}\n\nexport const GEOPOSITION_CHANNELS = keys(GEOPOSITION_CHANNEL_INDEX);\n\nconst UNIT_CHANNEL_INDEX: Flag<keyof Encoding<any>> = {\n  ...POSITION_CHANNEL_INDEX,\n\n  ...GEOPOSITION_CHANNEL_INDEX,\n\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n\n  strokeWidth: 1,\n  size: 1,\n  shape: 1,\n\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1,\n  url: 1\n};\n\nexport type ColorChannel = 'color' | 'fill' | 'stroke';\n\nexport function isColorChannel(channel: Channel): channel is ColorChannel {\n  return channel === 'color' || channel === 'fill' || channel === 'stroke';\n}\n\nexport type FacetChannel = keyof EncodingFacetMapping<any>;\n\nconst FACET_CHANNEL_INDEX: Flag<keyof EncodingFacetMapping<any>> = {\n  row: 1,\n  column: 1,\n  facet: 1\n};\n\nexport const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\n\nconst CHANNEL_INDEX = {\n  ...UNIT_CHANNEL_INDEX,\n  ...FACET_CHANNEL_INDEX\n};\n\nexport const CHANNELS = keys(CHANNEL_INDEX);\n\nconst {order: _o, detail: _d, tooltip: _tt1, ...SINGLE_DEF_CHANNEL_INDEX} = CHANNEL_INDEX;\nconst {row: _r, column: _c, facet: _f, ...SINGLE_DEF_UNIT_CHANNEL_INDEX} = SINGLE_DEF_CHANNEL_INDEX;\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\nexport const SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\n\nexport type SingleDefChannel = typeof SINGLE_DEF_CHANNELS[number];\n\nexport const SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\n\nexport type SingleDefUnitChannel = typeof SINGLE_DEF_UNIT_CHANNELS[number];\n\nexport function isSingleDefUnitChannel(str: string): str is SingleDefUnitChannel {\n  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];\n}\n\nexport function isChannel(str: string): str is Channel {\n  return !!CHANNEL_INDEX[str];\n}\n\nexport type SecondaryRangeChannel = 'x2' | 'y2' | 'latitude2' | 'longitude2';\n\nexport const SECONDARY_RANGE_CHANNEL: SecondaryRangeChannel[] = ['x2', 'y2', 'latitude2', 'longitude2'];\n\nexport function isSecondaryRangeChannel(c: Channel): c is SecondaryRangeChannel {\n  const main = getMainRangeChannel(c);\n  return main !== c;\n}\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getMainRangeChannel(channel: Channel): Channel {\n  switch (channel) {\n    case 'x2':\n      return 'x';\n    case 'y2':\n      return 'y';\n    case 'latitude2':\n      return 'latitude';\n    case 'longitude2':\n      return 'longitude';\n  }\n  return channel;\n}\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getSecondaryRangeChannel(channel: Channel): SecondaryRangeChannel {\n  switch (channel) {\n    case 'x':\n      return 'x2';\n    case 'y':\n      return 'y2';\n    case 'latitude':\n      return 'latitude2';\n    case 'longitude':\n      return 'longitude2';\n  }\n  return undefined;\n}\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX);\n\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2,\n  // The rest of unit channels then have scale\n  ...NONPOSITION_CHANNEL_INDEX\n} = UNIT_CHANNEL_INDEX;\n\nexport const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);\nexport type NonPositionChannel = typeof NONPOSITION_CHANNELS[number];\n\n// POSITION_SCALE_CHANNELS = X and Y;\nconst POSITION_SCALE_CHANNEL_INDEX = {x: 1, y: 1} as const;\nexport const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport type PositionScaleChannel = typeof POSITION_SCALE_CHANNELS[number];\n\nexport function getSizeType(channel: PositionScaleChannel): 'width' | 'height' {\n  return channel === 'x' ? 'width' : 'height';\n}\n\nexport function getPositionScaleChannel(sizeType: 'width' | 'height'): PositionScaleChannel {\n  return sizeType === 'width' ? 'x' : 'y';\n}\n\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  url: _u,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n} = NONPOSITION_CHANNEL_INDEX;\nexport const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport type NonPositionScaleChannel = typeof NONPOSITION_SCALE_CHANNELS[number];\n\nexport function isNonPositionScaleChannel(channel: Channel): channel is NonPositionScaleChannel {\n  return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n\n/**\n * @returns whether Vega supports legends for a particular channel\n */\nexport function supportLegend(channel: NonPositionScaleChannel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case STROKEWIDTH:\n      return true;\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      return false;\n  }\n}\n\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = {\n  ...POSITION_SCALE_CHANNEL_INDEX,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n};\n\n/** List of channels with scales */\nexport const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport type ScaleChannel = typeof SCALE_CHANNELS[number];\n\nexport function isScaleChannel(channel: Channel): channel is ScaleChannel {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n\nexport type SupportedMark = {[mark in Mark]?: 'always' | 'binned'};\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: Channel, mark: Mark) {\n  return getSupportedMark(channel)[mark];\n}\n\nconst ALL_MARKS: {[m in Mark]: 'always'} = {\n  // all marks\n  area: 'always',\n  bar: 'always',\n  circle: 'always',\n  geoshape: 'always',\n  image: 'always',\n  line: 'always',\n  rule: 'always',\n  point: 'always',\n  rect: 'always',\n  square: 'always',\n  trail: 'always',\n  text: 'always',\n  tick: 'always'\n};\n\nconst {geoshape: _g, ...ALL_MARKS_EXCEPT_GEOSHAPE} = ALL_MARKS;\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\nfunction getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    // falls through\n\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n    // falls through\n\n    case FACET:\n    case ROW: // falls through\n    case COLUMN:\n      return ALL_MARKS;\n    case X:\n    case Y:\n    case LATITUDE:\n    case LONGITUDE:\n      // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n      return ALL_MARKS_EXCEPT_GEOSHAPE;\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        area: 'always',\n        bar: 'always',\n        image: 'always',\n        rect: 'always',\n        rule: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned',\n        line: 'binned',\n        trail: 'binned'\n      };\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n    case SHAPE:\n      return {point: 'always', geoshape: 'always'};\n    case TEXT:\n      return {text: 'always'};\n\n    case URL:\n      return {image: 'always'};\n  }\n}\n\nexport function rangeType(channel: Channel): RangeType {\n  switch (channel) {\n    case X:\n    case Y:\n    case SIZE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n\n    // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n    case X2:\n    case Y2:\n      return undefined;\n\n    case FACET:\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}