{"ast":null,"code":"import { ref, keyFieldRef, aggrField } from '../util';\nimport { Collect, Aggregate, MultiExtent, MultiValues, Sieve, Values } from '../transforms';\nimport { isValidScaleType, isDiscrete, isQuantile } from 'vega-scale';\nimport { error, extend, hasOwnProperty, isArray, isObject, isString, stringValue } from 'vega-util';\nvar FIELD_REF_ID = 0;\nvar MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\nexport function initScale(spec, scope) {\n  var type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type: type,\n    domain: undefined\n  });\n}\nexport function parseScale(spec, scope) {\n  var params = scope.getScale(spec.name).params,\n      key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n} // -- SCALE DOMAIN ----\n\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(function (v) {\n    return parseLiteral(v, scope);\n  });\n}\n\nfunction singularDomain(domain, spec, scope) {\n  var data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  var data = domain.data,\n      fields = domain.fields.reduce(function (dom, d) {\n    d = isString(d) ? {\n      data: data,\n      field: d\n    } : isArray(d) || d.signal ? fieldRef(d, scope) : d;\n    dom.push(d);\n    return dom;\n  }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  var name = '_:vega:_' + FIELD_REF_ID++,\n      coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    var code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  var sort = parseSort(domain.sort, true),\n      counts,\n      p,\n      a,\n      c,\n      v; // get value counts for each domain field\n\n  counts = fields.map(function (f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  }); // aggregate the results from each domain field\n\n  p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n\n  a = scope.add(Aggregate(p)); // collect aggregate output\n\n  c = scope.add(Collect({\n    pulse: ref(a)\n  })); // extract values for combined domain\n\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  var values = fields.map(function (f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  }); // combine value arrays\n\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  var extents = fields.map(function (f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  }); // combine extents\n\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n} // -- SCALE BINS -----\n\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n} // -- SCALE NICE -----\n\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n} // -- SCALE INTERPOLATION -----\n\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n} // -- SCALE RANGE -----\n\n\nfunction parseScaleRange(spec, scope, params) {\n  var range = spec.range,\n      config = scope.config.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/scale.js"],"names":["ref","keyFieldRef","aggrField","Collect","Aggregate","MultiExtent","MultiValues","Sieve","Values","isValidScaleType","isDiscrete","isQuantile","error","extend","hasOwnProperty","isArray","isObject","isString","stringValue","FIELD_REF_ID","MULTIDOMAIN_SORT_OPS","min","max","count","initScale","spec","scope","type","addScale","name","domain","undefined","parseScale","params","getScale","key","parseScaleDomain","range","parseScaleRange","interpolate","parseScaleInterpolate","nice","parseScaleNice","bins","parseScaleBins","parseLiteral","v","signal","signalRef","parseArray","map","dataLookupError","domainMin","domainMax","explicitDomain","fields","multipleDomain","singularDomain","data","getData","valuesRef","field","parseSort","sort","domainRef","extentRef","reduce","dom","d","fieldRef","push","ordinalMultipleDomain","quantileMultipleDomain","numericMultipleDomain","coll","value","$ingest","code","input","addDataPipeline","counts","p","a","c","f","countsRef","groupby","pulse","op","ops","as","add","sortRef","multidomain","values","extents","objectProperty","interval","step","gamma","interpolateGamma","config","scheme","extent","schemeExtent","schemeCount","rangeStep"],"mappings":"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","sourcesContent":["import {ref, keyFieldRef, aggrField} from '../util';\nimport {\n  Collect, Aggregate, MultiExtent, MultiValues, Sieve, Values\n} from '../transforms';\n\nimport {isValidScaleType, isDiscrete, isQuantile} from 'vega-scale';\nimport {\n  error, extend, hasOwnProperty, isArray, isObject, isString, stringValue\n} from 'vega-util';\n\nvar FIELD_REF_ID = 0;\n\nvar MULTIDOMAIN_SORT_OPS  = {min: 'min', max: 'max', count: 'sum'};\n\nexport function initScale(spec, scope) {\n  var type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type:   type,\n    domain: undefined\n  });\n}\n\nexport function parseScale(spec, scope) {\n  var params = scope.getScale(spec.name).params,\n      key;\n\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v\n    : v.signal ? scope.signalRef(v.signal)\n    : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal\n    ? scope.signalRef(v.signal)\n    : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n}\n\n// -- SCALE DOMAIN ----\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal)\n    : (isArray(domain) ? explicitDomain\n    : domain.fields ? multipleDomain\n    : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(function(v) {\n    return parseLiteral(v, scope);\n  });\n}\n\nfunction singularDomain(domain, spec, scope) {\n  var data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n\n  return isDiscrete(spec.type)\n      ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false))\n      : isQuantile(spec.type) ? data.domainRef(scope, domain.field)\n      : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  var data = domain.data,\n      fields = domain.fields.reduce(function(dom, d) {\n        d = isString(d) ? {data: data, field: d}\n          : (isArray(d) || d.signal) ? fieldRef(d, scope)\n          : d;\n        dom.push(d);\n        return dom;\n      }, []);\n\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain\n    : isQuantile(spec.type) ? quantileMultipleDomain\n    : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  var name = '_:vega:_' + (FIELD_REF_ID++),\n      coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {$ingest: data};\n  } else if (data.signal) {\n    var code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {data: name, field: 'data'};\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  var sort = parseSort(domain.sort, true),\n      counts, p, a, c, v;\n\n  // get value counts for each domain field\n  counts = fields.map(function(f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  });\n\n  // aggregate the results from each domain field\n  p = {groupby: keyFieldRef, pulse: counts};\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n  a = scope.add(Aggregate(p));\n\n  // collect aggregate output\n  c = scope.add(Collect({pulse: ref(a)}));\n\n  // extract values for combined domain\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort:  scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';\n      else sort = {field: 'key'};\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  var values = fields.map(function(f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  });\n\n  // combine value arrays\n  return ref(scope.add(MultiValues({values: values})));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  var extents = fields.map(function(f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  });\n\n  // combine extents\n  return ref(scope.add(MultiExtent({extents: extents})));\n}\n\n// -- SCALE BINS -----\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v)\n    ? parseArray(v, scope)\n    : scope.objectProperty(v);\n}\n\n// -- SCALE NICE -----\n\nfunction parseScaleNice(nice) {\n  return isObject(nice)\n    ? {\n        interval: parseLiteral(nice.interval),\n        step: parseLiteral(nice.step)\n      }\n    : parseLiteral(nice);\n}\n\n// -- SCALE INTERPOLATION -----\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n}\n\n// -- SCALE RANGE -----\n\nfunction parseScaleRange(spec, scope, params) {\n  var range = spec.range,\n      config = scope.config.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {range: config[range]});\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {signal: 'width'}]\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type)\n        ? [0, {signal: 'height'}]\n        : [{signal: 'height'}, 0]\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme)\n      ? parseArray(range.scheme, scope)\n      : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n"]},"metadata":{},"sourceType":"module"}