{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { array, stringValue } from 'vega-util';\nimport { STORE, TUPLE, unitName } from '.';\nimport { X, Y } from '../../channel';\nimport { warn } from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys } from '../../util';\nimport { assembleInit } from './assemble';\nimport { TUPLE_FIELDS } from './transforms/project';\nimport scales from './transforms/scales';\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\nconst interval = {\n  signals: (model, selCmpt) => {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const hasScales = scales.has(selCmpt);\n    const signals = [];\n    const dataSignals = [];\n    const scaleTriggers = [];\n\n    if (selCmpt.translate && !hasScales) {\n      const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(name + BRUSH)}`;\n      events(selCmpt, (on, evt) => {\n        var _a;\n\n        const filters = array((_a = evt.between[0].filter, _a !== null && _a !== void 0 ? _a : evt.between[0].filter = []));\n\n        if (filters.indexOf(filterExpr) < 0) {\n          filters.push(filterExpr);\n        }\n\n        return on;\n      });\n    }\n\n    selCmpt.project.items.forEach((proj, i) => {\n      const channel = proj.channel;\n\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n\n      const init = selCmpt.init ? selCmpt.init[i] : null;\n      const cs = channelSignals(model, selCmpt, proj, init);\n      const dname = proj.signals.data;\n      const vname = proj.signals.visual;\n      const scaleName = stringValue(model.scaleName(channel));\n      const scaleType = model.getScaleComponent(channel).get('type');\n      const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n      signals.push(...cs);\n      dataSignals.push(dname);\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr: `(!isArray(${dname}) || ` + `(${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ` + `${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`\n      });\n    }); // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n\n    if (!hasScales) {\n      signals.push({\n        name: name + SCALE_TRIGGER,\n        value: {},\n        on: [{\n          events: scaleTriggers.map(t => ({\n            scale: t.scaleName\n          })),\n          update: scaleTriggers.map(t => t.expr).join(' && ') + ` ? ${name + SCALE_TRIGGER} : {}`\n        }]\n      });\n    } // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n\n\n    const init = selCmpt.init;\n    const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n    return signals.concat(Object.assign(Object.assign({\n      name: name + TUPLE\n    }, init ? {\n      init: `{${update}: ${assembleInit(init)}}`\n    } : {}), {\n      on: [{\n        events: [{\n          signal: dataSignals.join(' || ')\n        }],\n        update: dataSignals.join(' && ') + ` ? {${update}: [${dataSignals}]} : null`\n      }]\n    }));\n  },\n  modifyExpr: (model, selCmpt) => {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`);\n  },\n  marks: (model, selCmpt, marks) => {\n    const name = selCmpt.name;\n    const {\n      x,\n      y\n    } = selCmpt.project.hasChannel;\n    const xvname = x && x.signals.visual;\n    const yvname = y && y.signals.visual;\n    const store = `data(${stringValue(selCmpt.name + STORE)})`; // Do not add a brush if we're binding to scales.\n\n    if (scales.has(selCmpt)) {\n      return marks;\n    }\n\n    const update = {\n      x: x !== undefined ? {\n        signal: `${xvname}[0]`\n      } : {\n        value: 0\n      },\n      y: y !== undefined ? {\n        signal: `${yvname}[0]`\n      } : {\n        value: 0\n      },\n      x2: x !== undefined ? {\n        signal: `${xvname}[1]`\n      } : {\n        field: {\n          group: 'width'\n        }\n      },\n      y2: y !== undefined ? {\n        signal: `${yvname}[1]`\n      } : {\n        field: {\n          group: 'height'\n        }\n      }\n    }; // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n\n    if (selCmpt.resolve === 'global') {\n      for (const key of keys(update)) {\n        update[key] = [Object.assign({\n          test: `${store}.length && ${store}[0].unit === ${unitName(model)}`\n        }, update[key]), {\n          value: 0\n        }];\n      }\n    } // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n\n\n    const _a = selCmpt.mark,\n          {\n      fill,\n      fillOpacity\n    } = _a,\n          stroke = __rest(_a, [\"fill\", \"fillOpacity\"]);\n\n    const vgStroke = keys(stroke).reduce((def, k) => {\n      def[k] = [{\n        test: [x !== undefined && `${xvname}[0] !== ${xvname}[1]`, y !== undefined && `${yvname}[0] !== ${yvname}[1]`].filter(t => t).join(' && '),\n        value: stroke[k]\n      }, {\n        value: null\n      }];\n      return def;\n    }, {});\n    return [{\n      name: name + BRUSH + '_bg',\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {\n            value: fill\n          },\n          fillOpacity: {\n            value: fillOpacity\n          }\n        },\n        update: update\n      }\n    }, ...marks, {\n      name: name + BRUSH,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {\n            value: 'transparent'\n          }\n        },\n        update: Object.assign(Object.assign({}, update), vgStroke)\n      }\n    }];\n  }\n};\nexport default interval;\n/**\n * Returns the visual and data signals for an interval selection.\n */\n\nfunction channelSignals(model, selCmpt, proj, init) {\n  const channel = proj.channel;\n  const vname = proj.signals.visual;\n  const dname = proj.signals.data;\n  const hasScales = scales.has(selCmpt);\n  const scaleName = stringValue(model.scaleName(channel));\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n\n  const scaled = str => `scale(${scaleName}, ${str})`;\n\n  const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  const coord = `${channel}(unit)`;\n  const on = events(selCmpt, (def, evt) => {\n    return [...def, {\n      events: evt.between[0],\n      update: `[${coord}, ${coord}]`\n    }, {\n      events: evt,\n      update: `[${vname}[0], clamp(${coord}, 0, ${size})]`\n    } // Brush End\n    ];\n  }); // React to pan/zooms of continuous scales. Non-continuous scales\n  // (band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n\n  on.push({\n    events: {\n      signal: selCmpt.name + SCALE_TRIGGER\n    },\n    update: hasContinuousDomain(scaleType) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`\n  });\n  return hasScales ? [{\n    name: dname,\n    on: []\n  }] : [Object.assign(Object.assign({\n    name: vname\n  }, init ? {\n    init: assembleInit(init, true, scaled)\n  } : {\n    value: []\n  }), {\n    on: on\n  }), Object.assign(Object.assign({\n    name: dname\n  }, init ? {\n    init: assembleInit(init)\n  } : {}), {\n    on: [{\n      events: {\n        signal: vname\n      },\n      update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`\n    }]\n  })];\n}\n\nfunction events(selCmpt, cb) {\n  return selCmpt.events.reduce((on, evt) => {\n    if (!evt.between) {\n      warn(`${evt} is not an ordered event stream for interval selections.`);\n      return on;\n    }\n\n    return cb(on, evt);\n  }, []);\n}","map":{"version":3,"sources":["../../../../src/compile/selection/interval.ts"],"names":[],"mappings":"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","sourcesContent":["import {NewSignal, OnEvent, Stream} from 'vega';\nimport {array, stringValue} from 'vega-util';\nimport {SelectionCompiler, SelectionComponent, STORE, TUPLE, unitName} from '.';\nimport {ScaleChannel, X, Y} from '../../channel';\nimport {warn} from '../../log';\nimport {hasContinuousDomain} from '../../scale';\nimport {SelectionInitInterval} from '../../selection';\nimport {keys} from '../../util';\nimport {UnitModel} from '../unit';\nimport {assembleInit} from './assemble';\nimport {SelectionProjection, TUPLE_FIELDS} from './transforms/project';\nimport scales from './transforms/scales';\n\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\n\nconst interval: SelectionCompiler<'interval'> = {\n  signals: (model, selCmpt) => {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const hasScales = scales.has(selCmpt);\n    const signals: NewSignal[] = [];\n    const dataSignals: string[] = [];\n    const scaleTriggers: {\n      scaleName: string;\n      expr: string;\n    }[] = [];\n\n    if (selCmpt.translate && !hasScales) {\n      const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(name + BRUSH)}`;\n      events(selCmpt, (on: OnEvent[], evt: Stream) => {\n        const filters = array(evt.between[0].filter ?? (evt.between[0].filter = []));\n        if (filters.indexOf(filterExpr) < 0) {\n          filters.push(filterExpr);\n        }\n        return on;\n      });\n    }\n\n    selCmpt.project.items.forEach((proj, i) => {\n      const channel = proj.channel;\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n\n      const init = selCmpt.init ? selCmpt.init[i] : null;\n      const cs = channelSignals(model, selCmpt, proj, init);\n      const dname = proj.signals.data;\n      const vname = proj.signals.visual;\n      const scaleName = stringValue(model.scaleName(channel));\n      const scaleType = model.getScaleComponent(channel).get('type');\n      const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n\n      signals.push(...cs);\n      dataSignals.push(dname);\n\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr:\n          `(!isArray(${dname}) || ` +\n          `(${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ` +\n          `${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`\n      });\n    });\n\n    // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n    if (!hasScales) {\n      signals.push({\n        name: name + SCALE_TRIGGER,\n        value: {},\n        on: [\n          {\n            events: scaleTriggers.map(t => ({scale: t.scaleName})),\n            update: scaleTriggers.map(t => t.expr).join(' && ') + ` ? ${name + SCALE_TRIGGER} : {}`\n          }\n        ]\n      });\n    }\n\n    // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n    const init = selCmpt.init;\n    const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n    return signals.concat({\n      name: name + TUPLE,\n      ...(init ? {init: `{${update}: ${assembleInit(init)}}`} : {}),\n      on: [\n        {\n          events: [{signal: dataSignals.join(' || ')}], // Prevents double invocation, see https://github.com/vega/vega#1672.\n          update: dataSignals.join(' && ') + ` ? {${update}: [${dataSignals}]} : null`\n        }\n      ]\n    });\n  },\n\n  modifyExpr: (model, selCmpt) => {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`);\n  },\n\n  marks: (model, selCmpt, marks) => {\n    const name = selCmpt.name;\n    const {x, y} = selCmpt.project.hasChannel;\n    const xvname = x && x.signals.visual;\n    const yvname = y && y.signals.visual;\n    const store = `data(${stringValue(selCmpt.name + STORE)})`;\n\n    // Do not add a brush if we're binding to scales.\n    if (scales.has(selCmpt)) {\n      return marks;\n    }\n\n    const update: any = {\n      x: x !== undefined ? {signal: `${xvname}[0]`} : {value: 0},\n      y: y !== undefined ? {signal: `${yvname}[0]`} : {value: 0},\n      x2: x !== undefined ? {signal: `${xvname}[1]`} : {field: {group: 'width'}},\n      y2: y !== undefined ? {signal: `${yvname}[1]`} : {field: {group: 'height'}}\n    };\n\n    // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n    if (selCmpt.resolve === 'global') {\n      for (const key of keys(update)) {\n        update[key] = [\n          {\n            test: `${store}.length && ${store}[0].unit === ${unitName(model)}`,\n            ...update[key]\n          },\n          {value: 0}\n        ];\n      }\n    }\n\n    // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n    const {fill, fillOpacity, ...stroke} = selCmpt.mark;\n    const vgStroke = keys(stroke).reduce((def, k) => {\n      def[k] = [\n        {\n          test: [x !== undefined && `${xvname}[0] !== ${xvname}[1]`, y !== undefined && `${yvname}[0] !== ${yvname}[1]`]\n            .filter(t => t)\n            .join(' && '),\n          value: stroke[k]\n        },\n        {value: null}\n      ];\n      return def;\n    }, {});\n\n    return [\n      {\n        name: name + BRUSH + '_bg',\n        type: 'rect',\n        clip: true,\n        encode: {\n          enter: {\n            fill: {value: fill},\n            fillOpacity: {value: fillOpacity}\n          },\n          update: update\n        }\n      },\n      ...marks,\n      {\n        name: name + BRUSH,\n        type: 'rect',\n        clip: true,\n        encode: {\n          enter: {\n            fill: {value: 'transparent'}\n          },\n          update: {...update, ...vgStroke}\n        }\n      }\n    ];\n  }\n};\nexport default interval;\n\n/**\n * Returns the visual and data signals for an interval selection.\n */\nfunction channelSignals(\n  model: UnitModel,\n  selCmpt: SelectionComponent<'interval'>,\n  proj: SelectionProjection,\n  init?: SelectionInitInterval\n): NewSignal[] {\n  const channel = proj.channel;\n  const vname = proj.signals.visual;\n  const dname = proj.signals.data;\n  const hasScales = scales.has(selCmpt);\n  const scaleName = stringValue(model.scaleName(channel));\n  const scale = model.getScaleComponent(channel as ScaleChannel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const scaled = (str: string) => `scale(${scaleName}, ${str})`;\n  const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  const coord = `${channel}(unit)`;\n\n  const on = events(selCmpt, (def: OnEvent[], evt: Stream) => {\n    return [\n      ...def,\n      {events: evt.between[0], update: `[${coord}, ${coord}]`}, // Brush Start\n      {events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]`} // Brush End\n    ];\n  });\n\n  // React to pan/zooms of continuous scales. Non-continuous scales\n  // (band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n  on.push({\n    events: {signal: selCmpt.name + SCALE_TRIGGER},\n    update: hasContinuousDomain(scaleType) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`\n  });\n\n  return hasScales\n    ? [{name: dname, on: []}]\n    : [\n        {\n          name: vname,\n          ...(init ? {init: assembleInit(init, true, scaled)} : {value: []}),\n          on: on\n        },\n        {\n          name: dname,\n          ...(init ? {init: assembleInit(init)} : {}), // Cannot be `value` as `init` may require datetime exprs.\n          on: [\n            {\n              events: {signal: vname},\n              update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`\n            }\n          ]\n        }\n      ];\n}\n\nfunction events(selCmpt: SelectionComponent<'interval'>, cb: (def: OnEvent[], evt: Stream) => OnEvent[]): OnEvent[] {\n  return selCmpt.events.reduce((on, evt) => {\n    if (!evt.between) {\n      warn(`${evt} is not an ordered event stream for interval selections.`);\n      return on;\n    }\n    return cb(on, evt);\n  }, [] as OnEvent[]);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}