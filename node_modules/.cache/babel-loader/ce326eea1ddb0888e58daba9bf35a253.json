{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tf = __importStar(require(\"@tensorflow/tfjs-core\"));\n\nconst camera_webgl_util_1 = require(\"./camera_webgl_util\");\n\nconst glCapabilities = {\n  canDownloadFromRGBTexture: new WeakMap(),\n  // Has detectGLCapabilities been run on a particular GL context;\n  glCapabilitiesTested: new WeakMap()\n};\n/**\n * Utility function that tests the GL context for capabilities to enable\n * optimizations.\n *\n * For best performance this should be be called once before using the other\n * camera related functions.\n */\n\n/** @doc {heading: 'Media', subheading: 'Camera'} */\n\nasync function detectGLCapabilities(gl) {\n  if (glCapabilities.glCapabilitiesTested.get(gl)) {\n    return;\n  } // Test whether we can successfully download from an RGB texture.\n  // Notably this isn't supported on iOS, but we use this test rather than a\n  // platform check to be more robust on android devices we may not have\n  // directly tested.\n  // Set this to true temporarily so that fromTexture does not\n  // use its workaround.\n\n\n  glCapabilities.canDownloadFromRGBTexture.set(gl, true);\n\n  try {\n    const height = 2;\n    const width = 4; // This must be a multiple of 4.\n\n    const data = new Uint8Array(height * width * 4);\n\n    for (let i = 0; i < data.length; i++) {\n      data[i] = i;\n    }\n\n    const sourceDims = {\n      height,\n      width,\n      depth: 4\n    };\n    const tex = camera_webgl_util_1.uploadTextureData(data, gl, sourceDims);\n    const targetDims = {\n      height,\n      width,\n      depth: 3\n    };\n    const downloaded = fromTexture(gl, tex, sourceDims, targetDims);\n    const downloadedData = await downloaded.data();\n    tf.dispose(downloaded);\n    const matches = tf.util.arraysEqual(downloadedData, [0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 20, 21, 22, 24, 25, 26, 28, 29, 30]);\n\n    if (matches) {\n      glCapabilities.canDownloadFromRGBTexture.set(gl, true);\n    } else {\n      glCapabilities.canDownloadFromRGBTexture.set(gl, false);\n    }\n  } catch (e) {\n    glCapabilities.canDownloadFromRGBTexture.set(gl, false);\n  } finally {\n    glCapabilities.glCapabilitiesTested.set(gl, true);\n  }\n}\n\nexports.detectGLCapabilities = detectGLCapabilities;\n/**\n * Transfers tensor data to an RGB(A) texture.\n *\n * @param gl the WebGL context that owns the texture.\n * @param imageTensor the tensor to upload\n * @param texture optional the target texture. If none is passed in a new\n *     texture will be created.\n */\n\n/** @doc {heading: 'Media', subheading: 'Camera'} */\n\nasync function toTexture(gl, imageTensor, texture) {\n  tf.util.assert(imageTensor.dtype === 'int32', () => 'imageTensor must be of type int32');\n  tf.util.assert(imageTensor.rank === 3, () => 'imageTensor must be a Tensor3D');\n  const imageData = Uint8Array.from((await imageTensor.data()));\n  const dims = {\n    height: imageTensor.shape[0],\n    width: imageTensor.shape[1],\n    depth: imageTensor.shape[2]\n  };\n  return camera_webgl_util_1.uploadTextureData(imageData, gl, dims, texture);\n}\n\nexports.toTexture = toTexture;\n/**\n * Creates a tensor3D from a texture.\n *\n * Allows for resizing the image and dropping the alpha channel from the\n * resulting tensor.\n *\n * Note that if you the output depth is 3 then the output width should be a\n * multiple of 4.\n *\n * @param gl the WebGL context that owns the input texture\n * @param texture the texture to convert into a tensor\n * @param sourceDims source dimensions of input texture (width, height, depth)\n * @param targetShape desired shape of output tensor\n */\n\n/** @doc {heading: 'Media', subheading: 'Camera'} */\n\nfunction fromTexture(gl, texture, sourceDims, targetShape, options = {}) {\n  tf.util.assert(targetShape.depth === 3 || targetShape.depth === 4, () => 'fromTexture Error: target depth must be 3 or 4');\n\n  if (targetShape.depth === 3 && targetShape.width % 4 !== 0) {\n    // We throw an error here rather than use the CPU workaround as the user is\n    // likely trying to get the maximum performance.\n    if (glCapabilities.canDownloadFromRGBTexture.get(gl)) {\n      // See\n      // https://www.khronos.org/opengl/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n      // for more details. At the moment gl.pixelStorei(gl.PACK_ALIGNMENT, 1);\n      // is not supported on expo. \"EXGL: gl.pixelStorei() doesn't support this\n      // parameter yet!\"\n      throw new Error('When using targetShape.depth=3, targetShape.width must be' + ' a multiple of 4. Alternatively do not call detectGLCapabilities()');\n    }\n  }\n\n  const originalTargetDepth = targetShape.depth;\n  const targetDepth = glCapabilities.canDownloadFromRGBTexture.get(gl) ? originalTargetDepth : 4;\n  sourceDims = {\n    height: Math.floor(sourceDims.height),\n    width: Math.floor(sourceDims.width),\n    depth: sourceDims.depth\n  };\n  targetShape = {\n    height: Math.floor(targetShape.height),\n    width: Math.floor(targetShape.width),\n    depth: targetDepth\n  };\n  const alignCorners = options.alignCorners != null ? options.alignCorners : false;\n  const interpolation = options.interpolation != null ? options.interpolation : 'bilinear';\n  tf.util.assert(interpolation === 'bilinear' || interpolation === 'nearest_neighbor', () => 'fromTexture Error: interpolation must be one of' + ' \"bilinear\" or \"nearest_neighbor\"');\n  const resizedTexture = camera_webgl_util_1.runResizeProgram(gl, texture, sourceDims, targetShape, alignCorners, interpolation);\n  const downloadedTextureData = camera_webgl_util_1.downloadTextureData(gl, resizedTexture, targetShape);\n  let finalTexData;\n\n  if (originalTargetDepth !== targetDepth && originalTargetDepth === 3) {\n    // We are on a device that does not support downloading from an RGB texture.\n    // Remove the alpha channel values on the CPU.\n    const area = targetShape.height * targetShape.width;\n    finalTexData = new Uint8Array(area * originalTargetDepth);\n\n    for (let i = 0; i < area; i++) {\n      const flatIndexRGB = i * 3;\n      const flatIndexRGBA = i * 4;\n      finalTexData[flatIndexRGB] = downloadedTextureData[flatIndexRGBA];\n      finalTexData[flatIndexRGB + 1] = downloadedTextureData[flatIndexRGBA + 1];\n      finalTexData[flatIndexRGB + 2] = downloadedTextureData[flatIndexRGBA + 2];\n    }\n  } else {\n    finalTexData = downloadedTextureData;\n  }\n\n  return tf.tensor3d(finalTexData, [targetShape.height, targetShape.width, originalTargetDepth], 'int32');\n}\n\nexports.fromTexture = fromTexture;\n/**\n * Render a texture to the GLView. This will use the default framebuffer\n * and present the contents of the texture on the screen.\n *\n * @param gl\n * @param texture\n * @param dims Dimensions of tensor\n */\n\n/** @doc {heading: 'Media', subheading: 'Camera'} */\n\nfunction renderToGLView(gl, texture, size, flipHorizontal = true) {\n  size = {\n    width: Math.floor(size.width),\n    height: Math.floor(size.height)\n  };\n  camera_webgl_util_1.drawTexture(gl, texture, size, flipHorizontal);\n}\n\nexports.renderToGLView = renderToGLView;","map":{"version":3,"sources":["../../src/camera/camera.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tf = __importStar(require(\"@tensorflow/tfjs-core\"));\nconst camera_webgl_util_1 = require(\"./camera_webgl_util\");\nconst glCapabilities = {\n    canDownloadFromRGBTexture: new WeakMap(),\n    // Has detectGLCapabilities been run on a particular GL context;\n    glCapabilitiesTested: new WeakMap()\n};\n/**\n * Utility function that tests the GL context for capabilities to enable\n * optimizations.\n *\n * For best performance this should be be called once before using the other\n * camera related functions.\n */\n/** @doc {heading: 'Media', subheading: 'Camera'} */\nasync function detectGLCapabilities(gl) {\n    if (glCapabilities.glCapabilitiesTested.get(gl)) {\n        return;\n    }\n    // Test whether we can successfully download from an RGB texture.\n    // Notably this isn't supported on iOS, but we use this test rather than a\n    // platform check to be more robust on android devices we may not have\n    // directly tested.\n    // Set this to true temporarily so that fromTexture does not\n    // use its workaround.\n    glCapabilities.canDownloadFromRGBTexture.set(gl, true);\n    try {\n        const height = 2;\n        const width = 4; // This must be a multiple of 4.\n        const data = new Uint8Array(height * width * 4);\n        for (let i = 0; i < data.length; i++) {\n            data[i] = i;\n        }\n        const sourceDims = { height, width, depth: 4 };\n        const tex = camera_webgl_util_1.uploadTextureData(data, gl, sourceDims);\n        const targetDims = { height, width, depth: 3 };\n        const downloaded = fromTexture(gl, tex, sourceDims, targetDims);\n        const downloadedData = await downloaded.data();\n        tf.dispose(downloaded);\n        const matches = tf.util.arraysEqual(downloadedData, [\n            0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14,\n            16, 17, 18, 20, 21, 22, 24, 25, 26, 28, 29, 30\n        ]);\n        if (matches) {\n            glCapabilities.canDownloadFromRGBTexture.set(gl, true);\n        }\n        else {\n            glCapabilities.canDownloadFromRGBTexture.set(gl, false);\n        }\n    }\n    catch (e) {\n        glCapabilities.canDownloadFromRGBTexture.set(gl, false);\n    }\n    finally {\n        glCapabilities.glCapabilitiesTested.set(gl, true);\n    }\n}\nexports.detectGLCapabilities = detectGLCapabilities;\n/**\n * Transfers tensor data to an RGB(A) texture.\n *\n * @param gl the WebGL context that owns the texture.\n * @param imageTensor the tensor to upload\n * @param texture optional the target texture. If none is passed in a new\n *     texture will be created.\n */\n/** @doc {heading: 'Media', subheading: 'Camera'} */\nasync function toTexture(gl, imageTensor, texture) {\n    tf.util.assert(imageTensor.dtype === 'int32', () => 'imageTensor must be of type int32');\n    tf.util.assert(imageTensor.rank === 3, () => 'imageTensor must be a Tensor3D');\n    const imageData = Uint8Array.from(await imageTensor.data());\n    const dims = {\n        height: imageTensor.shape[0],\n        width: imageTensor.shape[1],\n        depth: imageTensor.shape[2],\n    };\n    return camera_webgl_util_1.uploadTextureData(imageData, gl, dims, texture);\n}\nexports.toTexture = toTexture;\n/**\n * Creates a tensor3D from a texture.\n *\n * Allows for resizing the image and dropping the alpha channel from the\n * resulting tensor.\n *\n * Note that if you the output depth is 3 then the output width should be a\n * multiple of 4.\n *\n * @param gl the WebGL context that owns the input texture\n * @param texture the texture to convert into a tensor\n * @param sourceDims source dimensions of input texture (width, height, depth)\n * @param targetShape desired shape of output tensor\n */\n/** @doc {heading: 'Media', subheading: 'Camera'} */\nfunction fromTexture(gl, texture, sourceDims, targetShape, options = {}) {\n    tf.util.assert(targetShape.depth === 3 || targetShape.depth === 4, () => 'fromTexture Error: target depth must be 3 or 4');\n    if (targetShape.depth === 3 && targetShape.width % 4 !== 0) {\n        // We throw an error here rather than use the CPU workaround as the user is\n        // likely trying to get the maximum performance.\n        if (glCapabilities.canDownloadFromRGBTexture.get(gl)) {\n            // See\n            // https://www.khronos.org/opengl/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n            // for more details. At the moment gl.pixelStorei(gl.PACK_ALIGNMENT, 1);\n            // is not supported on expo. \"EXGL: gl.pixelStorei() doesn't support this\n            // parameter yet!\"\n            throw new Error('When using targetShape.depth=3, targetShape.width must be' +\n                ' a multiple of 4. Alternatively do not call detectGLCapabilities()');\n        }\n    }\n    const originalTargetDepth = targetShape.depth;\n    const targetDepth = glCapabilities.canDownloadFromRGBTexture.get(gl) ?\n        originalTargetDepth :\n        4;\n    sourceDims = {\n        height: Math.floor(sourceDims.height),\n        width: Math.floor(sourceDims.width),\n        depth: sourceDims.depth,\n    };\n    targetShape = {\n        height: Math.floor(targetShape.height),\n        width: Math.floor(targetShape.width),\n        depth: targetDepth\n    };\n    const alignCorners = options.alignCorners != null ? options.alignCorners : false;\n    const interpolation = options.interpolation != null ? options.interpolation : 'bilinear';\n    tf.util.assert(interpolation === 'bilinear' || interpolation === 'nearest_neighbor', () => 'fromTexture Error: interpolation must be one of' +\n        ' \"bilinear\" or \"nearest_neighbor\"');\n    const resizedTexture = camera_webgl_util_1.runResizeProgram(gl, texture, sourceDims, targetShape, alignCorners, interpolation);\n    const downloadedTextureData = camera_webgl_util_1.downloadTextureData(gl, resizedTexture, targetShape);\n    let finalTexData;\n    if (originalTargetDepth !== targetDepth && originalTargetDepth === 3) {\n        // We are on a device that does not support downloading from an RGB texture.\n        // Remove the alpha channel values on the CPU.\n        const area = targetShape.height * targetShape.width;\n        finalTexData = new Uint8Array(area * originalTargetDepth);\n        for (let i = 0; i < area; i++) {\n            const flatIndexRGB = i * 3;\n            const flatIndexRGBA = i * 4;\n            finalTexData[flatIndexRGB] = downloadedTextureData[flatIndexRGBA];\n            finalTexData[flatIndexRGB + 1] = downloadedTextureData[flatIndexRGBA + 1];\n            finalTexData[flatIndexRGB + 2] = downloadedTextureData[flatIndexRGBA + 2];\n        }\n    }\n    else {\n        finalTexData = downloadedTextureData;\n    }\n    return tf.tensor3d(finalTexData, [targetShape.height, targetShape.width, originalTargetDepth], 'int32');\n}\nexports.fromTexture = fromTexture;\n/**\n * Render a texture to the GLView. This will use the default framebuffer\n * and present the contents of the texture on the screen.\n *\n * @param gl\n * @param texture\n * @param dims Dimensions of tensor\n */\n/** @doc {heading: 'Media', subheading: 'Camera'} */\nfunction renderToGLView(gl, texture, size, flipHorizontal = true) {\n    size = {\n        width: Math.floor(size.width),\n        height: Math.floor(size.height),\n    };\n    camera_webgl_util_1.drawTexture(gl, texture, size, flipHorizontal);\n}\nexports.renderToGLView = renderToGLView;\n//# sourceMappingURL=camera.js.map"]},"metadata":{},"sourceType":"script"}