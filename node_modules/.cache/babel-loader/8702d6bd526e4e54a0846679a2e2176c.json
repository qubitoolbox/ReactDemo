{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { TUPLE_FIELDS } from './transforms/project';\nexport function singleOrMultiSignals(model, selCmpt) {\n  const name = selCmpt.name;\n  const fieldsSg = name + TUPLE_FIELDS;\n  const project = selCmpt.project;\n  const datum = '(item().isVoronoi ? datum.datum : datum)';\n  const values = project.items.map(p => {\n    const fieldDef = model.fieldDef(p.channel); // Binned fields should capture extents, for a range test against the raw field.\n\n    return fieldDef && fieldDef.bin ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` + `${datum}[${stringValue(model.vgField(p.channel, {\n      binSuffix: 'end'\n    }))}]]` : `${datum}[${stringValue(p.field)}]`;\n  }).join(', '); // Only add a discrete selection to the store if a datum is present _and_\n  // the interaction isn't occurring on a group mark. This guards against\n  // polluting interactive state with invalid values in faceted displays\n  // as the group marks are also data-driven. We force the update to account\n  // for constant null states but varying toggles (e.g., shift-click in\n  // whitespace followed by a click in whitespace; the store should only\n  // be cleared on the second click).\n\n  const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n  const events = selCmpt.events;\n  return [{\n    name: name + TUPLE,\n    on: events ? [{\n      events,\n      update: `datum && item().mark.marktype !== 'group' ? {${update}: [${values}]} : null`,\n      force: true\n    }] : []\n  }];\n}\nconst multi = {\n  signals: singleOrMultiSignals,\n  modifyExpr: (model, selCmpt) => {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'null' : `{unit: ${unitName(model)}}`);\n  }\n};\nexport default multi;","map":{"version":3,"sources":["../../../../src/compile/selection/multi.ts"],"names":[],"mappings":"AACA,SAAQ,WAAR,QAA0B,WAA1B;AACA,SAA+C,KAA/C,EAAsD,QAAtD,QAAqE,GAArE;AAEA,SAAQ,YAAR,QAA2B,sBAA3B;AAEA,OAAM,SAAU,oBAAV,CAA+B,KAA/B,EAAiD,OAAjD,EAAgG;AACpG,QAAM,IAAI,GAAG,OAAO,CAAC,IAArB;AACA,QAAM,QAAQ,GAAG,IAAI,GAAG,YAAxB;AACA,QAAM,OAAO,GAAG,OAAO,CAAC,OAAxB;AACA,QAAM,KAAK,GAAG,0CAAd;AACA,QAAM,MAAM,GAAG,OAAO,CAAC,KAAR,CACZ,GADY,CACR,CAAC,IAAG;AACP,UAAM,QAAQ,GAAG,KAAK,CAAC,QAAN,CAAe,CAAC,CAAC,OAAjB,CAAjB,CADO,CAEP;;AACA,WAAO,QAAQ,IAAI,QAAQ,CAAC,GAArB,GACH,IAAI,KAAK,IAAI,WAAW,CAAC,KAAK,CAAC,OAAN,CAAc,CAAC,CAAC,OAAhB,EAAyB,EAAzB,CAAD,CAA8B,KAAtD,GACE,GAAG,KAAK,IAAI,WAAW,CAAC,KAAK,CAAC,OAAN,CAAc,CAAC,CAAC,OAAhB,EAAyB;AAAC,MAAA,SAAS,EAAE;AAAZ,KAAzB,CAAD,CAA8C,IAFpE,GAGH,GAAG,KAAK,IAAI,WAAW,CAAC,CAAC,CAAC,KAAH,CAAS,GAHpC;AAID,GARY,EASZ,IATY,CASP,IATO,CAAf,CALoG,CAgBpG;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAM,MAAM,GAAG,SAAS,QAAQ,CAAC,KAAD,CAAO,aAAa,QAAQ,UAA5D;AAEA,QAAM,MAAM,GAAa,OAAO,CAAC,MAAjC;AAEA,SAAO,CACL;AACE,IAAA,IAAI,EAAE,IAAI,GAAG,KADf;AAEE,IAAA,EAAE,EAAE,MAAM,GACN,CACE;AACE,MAAA,MADF;AAEE,MAAA,MAAM,EAAE,gDAAgD,MAAM,MAAM,MAAM,WAF5E;AAGE,MAAA,KAAK,EAAE;AAHT,KADF,CADM,GAQN;AAVN,GADK,CAAP;AAcD;AAED,MAAM,KAAK,GAA+B;AACxC,EAAA,OAAO,EAAE,oBAD+B;AAGxC,EAAA,UAAU,EAAE,CAAC,KAAD,EAAQ,OAAR,KAAmB;AAC7B,UAAM,GAAG,GAAG,OAAO,CAAC,IAAR,GAAe,KAA3B;AACA,WAAO,GAAG,GAAG,IAAN,IAAc,OAAO,CAAC,OAAR,KAAoB,QAApB,GAA+B,MAA/B,GAAwC,UAAU,QAAQ,CAAC,KAAD,CAAO,GAA/E,CAAP;AACD;AANuC,CAA1C;AASA,eAAe,KAAf","sourcesContent":["import {Stream} from 'vega';\nimport {stringValue} from 'vega-util';\nimport {SelectionCompiler, SelectionComponent, TUPLE, unitName} from '.';\nimport {UnitModel} from '../unit';\nimport {TUPLE_FIELDS} from './transforms/project';\n\nexport function singleOrMultiSignals(model: UnitModel, selCmpt: SelectionComponent<'single' | 'multi'>) {\n  const name = selCmpt.name;\n  const fieldsSg = name + TUPLE_FIELDS;\n  const project = selCmpt.project;\n  const datum = '(item().isVoronoi ? datum.datum : datum)';\n  const values = project.items\n    .map(p => {\n      const fieldDef = model.fieldDef(p.channel);\n      // Binned fields should capture extents, for a range test against the raw field.\n      return fieldDef && fieldDef.bin\n        ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` +\n            `${datum}[${stringValue(model.vgField(p.channel, {binSuffix: 'end'}))}]]`\n        : `${datum}[${stringValue(p.field)}]`;\n    })\n    .join(', ');\n\n  // Only add a discrete selection to the store if a datum is present _and_\n  // the interaction isn't occurring on a group mark. This guards against\n  // polluting interactive state with invalid values in faceted displays\n  // as the group marks are also data-driven. We force the update to account\n  // for constant null states but varying toggles (e.g., shift-click in\n  // whitespace followed by a click in whitespace; the store should only\n  // be cleared on the second click).\n  const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n\n  const events: Stream[] = selCmpt.events;\n\n  return [\n    {\n      name: name + TUPLE,\n      on: events\n        ? [\n            {\n              events,\n              update: `datum && item().mark.marktype !== 'group' ? {${update}: [${values}]} : null`,\n              force: true\n            }\n          ]\n        : []\n    }\n  ];\n}\n\nconst multi: SelectionCompiler<'multi'> = {\n  signals: singleOrMultiSignals,\n\n  modifyExpr: (model, selCmpt) => {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'null' : `{unit: ${unitName(model)}}`);\n  }\n};\n\nexport default multi;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}