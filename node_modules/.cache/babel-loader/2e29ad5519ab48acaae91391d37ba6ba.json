{"ast":null,"code":"import * as log from '../log';\nimport { keys } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { makeCompositeAggregatePartFactory } from './common';\nimport { errorBarParams } from './errorbar';\nexport const ERRORBAND = 'errorband';\nconst ERRORBAND_PART_INDEX = {\n  band: 1,\n  borders: 1\n};\nexport const ERRORBAND_PARTS = keys(ERRORBAND_PART_INDEX);\nexport const errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);\nexport function normalizeErrorBand(spec, {\n  config\n}) {\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAND, config);\n  const errorBandDef = markDef;\n  const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);\n  const is2D = spec.encoding.x !== undefined && spec.encoding.y !== undefined;\n  let bandMark = {\n    type: is2D ? 'area' : 'rect'\n  };\n  let bordersMark = {\n    type: is2D ? 'line' : 'rule'\n  };\n  const interpolate = Object.assign(Object.assign({}, errorBandDef.interpolate ? {\n    interpolate: errorBandDef.interpolate\n  } : {}), errorBandDef.tension && errorBandDef.interpolate ? {\n    interpolate: errorBandDef.tension\n  } : {});\n\n  if (is2D) {\n    bandMark = Object.assign(Object.assign({}, bandMark), interpolate);\n    bordersMark = Object.assign(Object.assign({}, bordersMark), interpolate);\n  } else if (errorBandDef.interpolate) {\n    log.warn(log.message.errorBand1DNotSupport('interpolate'));\n  } else if (errorBandDef.tension) {\n    log.warn(log.message.errorBand1DNotSupport('tension'));\n  }\n\n  return Object.assign(Object.assign({}, outerSpec), {\n    transform,\n    layer: [...makeErrorBandPart({\n      partName: 'band',\n      mark: bandMark,\n      positionPrefix: 'lower',\n      endPositionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    }), ...makeErrorBandPart({\n      partName: 'borders',\n      mark: bordersMark,\n      positionPrefix: 'lower',\n      extraEncoding: tooltipEncoding\n    }), ...makeErrorBandPart({\n      partName: 'borders',\n      mark: bordersMark,\n      positionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    })]\n  });\n}","map":{"version":3,"sources":["../../../src/compositemark/errorband.ts"],"names":[],"mappings":"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","sourcesContent":["import {Interpolate, Orientation} from 'vega';\nimport {Field} from '../channeldef';\nimport {Encoding} from '../encoding';\nimport * as log from '../log';\nimport {MarkDef} from '../mark';\nimport {NormalizerParams} from '../normalize';\nimport {GenericUnitSpec, NormalizedLayerSpec} from '../spec';\nimport {Flag, keys} from '../util';\nimport {CompositeMarkNormalizer} from './base';\nimport {GenericCompositeMarkDef, makeCompositeAggregatePartFactory, PartsMixins} from './common';\nimport {ErrorBarCenter, ErrorBarExtent, errorBarParams, ErrorEncoding} from './errorbar';\n\nexport type ErrorBandUnitSpec<\n  EE = {} // extra encoding parameter (for faceted composite unit spec)\n> = GenericUnitSpec<ErrorEncoding<Field> & EE, ErrorBand | ErrorBandDef>;\n\nexport const ERRORBAND: 'errorband' = 'errorband';\nexport type ErrorBand = typeof ERRORBAND;\n\nexport type ErrorBandPart = 'band' | 'borders';\n\nconst ERRORBAND_PART_INDEX: Flag<ErrorBandPart> = {\n  band: 1,\n  borders: 1\n};\n\nexport const ERRORBAND_PARTS = keys(ERRORBAND_PART_INDEX);\n\nexport type ErrorBandPartsMixins = PartsMixins<ErrorBandPart>;\n\nexport interface ErrorBandConfig extends ErrorBandPartsMixins {\n  /**\n   * The center of the error band. Available options include:\n   * - `\"mean\"`: the mean of the data points.\n   * - `\"median\"`: the median of the data points.\n   *\n   * __Default value:__ `\"mean\"`.\n   * @hidden\n   */\n\n  // center is not needed right now but will be added back to the schema if future features require it.\n  center?: ErrorBarCenter;\n\n  /**\n   * The extent of the band. Available options include:\n   * - `\"ci\"`: Extend the band to the confidence interval of the mean.\n   * - `\"stderr\"`: The size of band are set to the value of standard error, extending from the mean.\n   * - `\"stdev\"`: The size of band are set to the value of standard deviation, extending from the mean.\n   * - `\"iqr\"`: Extend the band to the q1 and q3.\n   *\n   * __Default value:__ `\"stderr\"`.\n   */\n  extent?: ErrorBarExtent;\n\n  /**\n   * The line interpolation method for the error band. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.\n   * - `\"step-before\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.\n   * - `\"step-after\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   */\n  interpolate?: Interpolate;\n\n  /**\n   * The tension parameter for the interpolation type of the error band.\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n}\n\nexport type ErrorBandDef = GenericCompositeMarkDef<ErrorBand> &\n  ErrorBandConfig & {\n    /**\n     * Orientation of the error band. This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.\n     */\n    orient?: Orientation;\n  };\n\nexport interface ErrorBandConfigMixins {\n  /**\n   * ErrorBand Config\n   */\n  errorband?: ErrorBandConfig;\n}\n\nexport const errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);\n\nexport function normalizeErrorBand(\n  spec: GenericUnitSpec<Encoding<string>, ErrorBand | ErrorBandDef>,\n  {config}: NormalizerParams\n): NormalizedLayerSpec {\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAND, config);\n  const errorBandDef: ErrorBandDef = markDef;\n\n  const makeErrorBandPart = makeCompositeAggregatePartFactory<ErrorBandPartsMixins>(\n    errorBandDef,\n    continuousAxis,\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis,\n    config.errorband\n  );\n\n  const is2D = spec.encoding.x !== undefined && spec.encoding.y !== undefined;\n\n  let bandMark: MarkDef = {type: is2D ? 'area' : 'rect'};\n  let bordersMark: MarkDef = {type: is2D ? 'line' : 'rule'};\n  const interpolate = {\n    ...(errorBandDef.interpolate ? {interpolate: errorBandDef.interpolate} : {}),\n    ...(errorBandDef.tension && errorBandDef.interpolate ? {interpolate: errorBandDef.tension} : {})\n  };\n\n  if (is2D) {\n    bandMark = {\n      ...bandMark,\n      ...interpolate\n    };\n    bordersMark = {\n      ...bordersMark,\n      ...interpolate\n    };\n  } else if (errorBandDef.interpolate) {\n    log.warn(log.message.errorBand1DNotSupport('interpolate'));\n  } else if (errorBandDef.tension) {\n    log.warn(log.message.errorBand1DNotSupport('tension'));\n  }\n\n  return {\n    ...outerSpec,\n    transform,\n    layer: [\n      ...makeErrorBandPart({\n        partName: 'band',\n        mark: bandMark,\n        positionPrefix: 'lower',\n        endPositionPrefix: 'upper',\n        extraEncoding: tooltipEncoding\n      }),\n      ...makeErrorBandPart({\n        partName: 'borders',\n        mark: bordersMark,\n        positionPrefix: 'lower',\n        extraEncoding: tooltipEncoding\n      }),\n      ...makeErrorBandPart({\n        partName: 'borders',\n        mark: bordersMark,\n        positionPrefix: 'upper',\n        extraEncoding: tooltipEncoding\n      })\n    ]\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}