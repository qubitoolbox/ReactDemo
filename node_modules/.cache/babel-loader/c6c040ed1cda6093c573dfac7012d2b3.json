{"ast":null,"code":"import { SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { hasConditionalFieldDef, isFieldDef } from '../../channeldef';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model, {\n  ignoreRange\n} = {}) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\nexport function parseScaleCore(model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n/**\n * Parse scales for all channels of a model.\n */\n\nfunction parseUnitScaleCore(model) {\n  const {\n    encoding,\n    mark\n  } = model;\n  return SCALE_CHANNELS.reduce((scaleComponents, channel) => {\n    let fieldDef;\n    let specifiedScale;\n    const channelDef = encoding[channel]; // Don't generate scale for shape of geoshape\n\n    if (isFieldDef(channelDef) && mark === GEOSHAPE && channel === SHAPE && channelDef.type === GEOJSON) {\n      return scaleComponents;\n    }\n\n    if (isFieldDef(channelDef)) {\n      fieldDef = channelDef;\n      specifiedScale = channelDef.scale;\n    } else if (hasConditionalFieldDef(channelDef)) {\n      // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n      fieldDef = channelDef.condition;\n      specifiedScale = channelDef.condition['scale']; // We use ['scale'] since we know that channel here has scale for sure\n    }\n\n    if (fieldDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale = specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : {};\n      const sType = scaleType(specifiedScale, channel, fieldDef, mark);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(channel + '', true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n\n    return scaleComponents;\n  }, {});\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));\n\nfunction parseNonUnitScaleCore(model) {\n  const scaleComponents = model.component.scales = {};\n  const scaleTypeWithExplicitIndex = {};\n  const resolve = model.component.resolve; // Parse each child scale and determine if a particular channel can be merged.\n\n  for (const child of model.children) {\n    parseScaleCore(child); // Instead of always merging right away -- check if it is compatible to merge first!\n\n    keys(child.component.scales).forEach(channel => {\n      var _a; // if resolve is undefined, set default first\n\n\n      resolve.scale[channel] = (_a = resolve.scale[channel], _a !== null && _a !== void 0 ? _a : defaultScaleResolve(channel, model));\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent'; // Remove from the index so they don't get merged\n\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    });\n  } // Merge each channel listed in the index\n\n\n  for (const channel of keys(scaleTypeWithExplicitIndex)) {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit); // rename each child and mark them as merged\n\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  }\n\n  return scaleComponents;\n}","map":{"version":3,"sources":["../../../../src/compile/scale/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {ScaleChannel, SCALE_CHANNELS, SHAPE} from '../../channel';\nimport {hasConditionalFieldDef, isFieldDef, TypedFieldDef} from '../../channeldef';\nimport {GEOSHAPE} from '../../mark';\nimport {\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES,\n  Scale,\n  scaleCompatible,\n  ScaleType,\n  scaleTypePrecedence\n} from '../../scale';\nimport {GEOJSON} from '../../type';\nimport {keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {defaultScaleResolve} from '../resolve';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponent, ScaleComponentIndex} from './component';\nimport {parseScaleDomain} from './domain';\nimport {parseScaleProperty, parseScaleRange} from './properties';\nimport {scaleType} from './type';\n\nexport function parseScales(model: Model, {ignoreRange}: {ignoreRange?: boolean} = {}) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\n\nexport function parseScaleCore(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model: UnitModel): ScaleComponentIndex {\n  const {encoding, mark} = model;\n\n  return SCALE_CHANNELS.reduce((scaleComponents: ScaleComponentIndex, channel: ScaleChannel) => {\n    let fieldDef: TypedFieldDef<string>;\n    let specifiedScale: Scale | null;\n\n    const channelDef = encoding[channel];\n\n    // Don't generate scale for shape of geoshape\n    if (isFieldDef(channelDef) && mark === GEOSHAPE && channel === SHAPE && channelDef.type === GEOJSON) {\n      return scaleComponents;\n    }\n\n    if (isFieldDef(channelDef)) {\n      fieldDef = channelDef;\n      specifiedScale = channelDef.scale;\n    } else if (hasConditionalFieldDef<string, any>(channelDef)) {\n      // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n      fieldDef = channelDef.condition;\n      specifiedScale = channelDef.condition['scale']; // We use ['scale'] since we know that channel here has scale for sure\n    }\n\n    if (fieldDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale = specifiedScale ?? {};\n\n      const sType = scaleType(specifiedScale, channel, fieldDef, mark);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(channel + '', true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n\n    return scaleComponents;\n  }, {});\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing(\n  (st1: ScaleType, st2: ScaleType) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2)\n);\n\nfunction parseNonUnitScaleCore(model: Model) {\n  const scaleComponents: ScaleComponentIndex = (model.component.scales = {});\n\n  const scaleTypeWithExplicitIndex: {\n    // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n    [k in ScaleChannel]?: Explicit<ScaleType>;\n  } = {};\n  const resolve = model.component.resolve;\n\n  // Parse each child scale and determine if a particular channel can be merged.\n  for (const child of model.children) {\n    parseScaleCore(child);\n\n    // Instead of always merging right away -- check if it is compatible to merge first!\n    keys(child.component.scales).forEach((channel: ScaleChannel) => {\n      // if resolve is undefined, set default first\n      resolve.scale[channel] = resolve.scale[channel] ?? defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit<VgScale, ScaleType>(\n              explicitScaleType,\n              childScaleType,\n              'type',\n              'scale',\n              scaleTypeTieBreaker\n            );\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent';\n            // Remove from the index so they don't get merged\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    });\n  }\n\n  // Merge each channel listed in the index\n  for (const channel of keys(scaleTypeWithExplicitIndex)) {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n\n    // rename each child and mark them as merged\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  }\n\n  return scaleComponents;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}