{"ast":null,"code":"import Bitmaps from './Bitmaps';\nimport Dimension from './Dimension';\nimport SortedIndex from './SortedIndex';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\n\nexport default function CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\nCrossFilter.Definition = {\n  \"type\": \"CrossFilter\",\n  \"metadata\": {},\n  \"params\": [{\n    \"name\": \"fields\",\n    \"type\": \"field\",\n    \"array\": true,\n    \"required\": true\n  }, {\n    \"name\": \"query\",\n    \"type\": \"array\",\n    \"array\": true,\n    \"required\": true,\n    \"content\": {\n      \"type\": \"number\",\n      \"array\": true,\n      \"length\": 2\n    }\n  }]\n};\nvar prototype = inherits(CrossFilter, Transform);\n\nprototype.transform = function (_, pulse) {\n  if (!this._dims) {\n    return this.init(_, pulse);\n  } else {\n    var init = _.modified('fields') || _.fields.some(function (f) {\n      return pulse.modified(f.fields);\n    });\n\n    return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n  }\n};\n\nprototype.init = function (_, pulse) {\n  var fields = _.fields,\n      query = _.query,\n      indices = this._indices = {},\n      dims = this._dims = [],\n      m = query.length,\n      i = 0,\n      key,\n      index; // instantiate indices and dimensions\n\n  for (; i < m; ++i) {\n    key = fields[i].fname;\n    index = indices[key] || (indices[key] = SortedIndex());\n    dims.push(Dimension(index, i, query[i]));\n  }\n\n  return this.eval(_, pulse);\n};\n\nprototype.reinit = function (_, pulse) {\n  var output = pulse.materialize().fork(),\n      fields = _.fields,\n      query = _.query,\n      indices = this._indices,\n      dims = this._dims,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      out = output.rem = output.add,\n      mod = output.mod,\n      m = query.length,\n      adds = {},\n      add,\n      index,\n      key,\n      mods,\n      remMap,\n      modMap,\n      i,\n      n,\n      f; // set prev to current state\n\n  prev.set(curr); // if pulse has remove tuples, process them first\n\n  if (pulse.rem.length) {\n    remMap = this.remove(_, pulse, output);\n  } // if pulse has added tuples, add them to state\n\n\n  if (pulse.add.length) {\n    bits.add(pulse.add);\n  } // if pulse has modified tuples, create an index map\n\n\n  if (pulse.mod.length) {\n    modMap = {};\n\n    for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n      modMap[mods[i]._index] = 1;\n    }\n  } // re-initialize indices as needed, update curr bitmap\n\n\n  for (i = 0; i < m; ++i) {\n    f = fields[i];\n\n    if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n      key = f.fname;\n\n      if (!(add = adds[key])) {\n        indices[key] = index = SortedIndex();\n        adds[key] = add = index.insert(f, pulse.source, 0);\n      }\n\n      dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n    }\n  } // visit each tuple\n  // if filter state changed, push index to add/rem\n  // else if in mod and passes a filter, push index to mod\n\n\n  for (i = 0, n = bits.data().length; i < n; ++i) {\n    if (remMap[i]) {\n      // skip if removed tuple\n      continue;\n    } else if (prev[i] !== curr[i]) {\n      // add if state changed\n      out.push(i);\n    } else if (modMap[i] && curr[i] !== all) {\n      // otherwise, pass mods through\n      mod.push(i);\n    }\n  }\n\n  bits.mask = (1 << m) - 1;\n  return output;\n};\n\nprototype.eval = function (_, pulse) {\n  var output = pulse.materialize().fork(),\n      m = this._dims.length,\n      mask = 0;\n\n  if (pulse.rem.length) {\n    this.remove(_, pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  if (_.modified('query') && !_.modified('fields')) {\n    mask |= this.update(_, pulse, output);\n  }\n\n  if (pulse.add.length) {\n    this.insert(_, pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  if (pulse.mod.length) {\n    this.modify(pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  this.value.mask = mask;\n  return output;\n};\n\nprototype.insert = function (_, pulse, output) {\n  var tuples = pulse.add,\n      bits = this.value,\n      dims = this._dims,\n      indices = this._indices,\n      fields = _.fields,\n      adds = {},\n      out = output.add,\n      k = bits.size(),\n      n = k + tuples.length,\n      m = dims.length,\n      j,\n      key,\n      add; // resize bitmaps and add tuples as needed\n\n  bits.resize(n, m);\n  bits.add(tuples);\n  var curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(); // add to dimensional indices\n\n  for (j = 0; j < m; ++j) {\n    key = fields[j].fname;\n    add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n    dims[j].onAdd(add, curr);\n  } // set previous filters, output if passes at least one filter\n\n\n  for (; k < n; ++k) {\n    prev[k] = all;\n    if (curr[k] !== all) out.push(k);\n  }\n};\n\nprototype.modify = function (pulse, output) {\n  var out = output.mod,\n      bits = this.value,\n      curr = bits.curr(),\n      all = bits.all(),\n      tuples = pulse.mod,\n      i,\n      n,\n      k;\n\n  for (i = 0, n = tuples.length; i < n; ++i) {\n    k = tuples[i]._index;\n    if (curr[k] !== all) out.push(k);\n  }\n};\n\nprototype.remove = function (_, pulse, output) {\n  var indices = this._indices,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      map = {},\n      out = output.rem,\n      tuples = pulse.rem,\n      i,\n      n,\n      k,\n      f; // process tuples, output if passes at least one filter\n\n  for (i = 0, n = tuples.length; i < n; ++i) {\n    k = tuples[i]._index;\n    map[k] = 1; // build index map\n\n    prev[k] = f = curr[k];\n    curr[k] = all;\n    if (f !== all) out.push(k);\n  } // remove from dimensional indices\n\n\n  for (k in indices) {\n    indices[k].remove(n, map);\n  }\n\n  this.reindex(pulse, n, map);\n  return map;\n}; // reindex filters and indices after propagation completes\n\n\nprototype.reindex = function (pulse, num, map) {\n  var indices = this._indices,\n      bits = this.value;\n  pulse.runAfter(function () {\n    var indexMap = bits.remove(num, map);\n\n    for (var key in indices) indices[key].reindex(indexMap);\n  });\n};\n\nprototype.update = function (_, pulse, output) {\n  var dims = this._dims,\n      query = _.query,\n      stamp = pulse.stamp,\n      m = dims.length,\n      mask = 0,\n      i,\n      q; // survey how many queries have changed\n\n  output.filters = 0;\n\n  for (q = 0; q < m; ++q) {\n    if (_.modified('query', q)) {\n      i = q;\n      ++mask;\n    }\n  }\n\n  if (mask === 1) {\n    // only one query changed, use more efficient update\n    mask = dims[i].one;\n    this.incrementOne(dims[i], query[i], output.add, output.rem);\n  } else {\n    // multiple queries changed, perform full record keeping\n    for (q = 0, mask = 0; q < m; ++q) {\n      if (!_.modified('query', q)) continue;\n      mask |= dims[q].one;\n      this.incrementAll(dims[q], query[q], stamp, output.add);\n      output.rem = output.add; // duplicate add/rem for downstream resolve\n    }\n  }\n\n  return mask;\n};\n\nprototype.incrementAll = function (dim, query, stamp, out) {\n  var bits = this.value,\n      seen = bits.seen(),\n      curr = bits.curr(),\n      prev = bits.prev(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one,\n      i,\n      j,\n      k; // Fast incremental update based on previous lo index.\n\n  if (lo1 < lo0) {\n    for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n      k = index[i];\n\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n\n      curr[k] ^= one;\n    }\n  } else if (lo1 > lo0) {\n    for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n      k = index[i];\n\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n\n      curr[k] ^= one;\n    }\n  } // Fast incremental update based on previous hi index.\n\n\n  if (hi1 > hi0) {\n    for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n      k = index[i];\n\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n\n      curr[k] ^= one;\n    }\n  } else if (hi1 < hi0) {\n    for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n      k = index[i];\n\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n\n      curr[k] ^= one;\n    }\n  }\n\n  dim.range = query.slice();\n};\n\nprototype.incrementOne = function (dim, query, add, rem) {\n  var bits = this.value,\n      curr = bits.curr(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one,\n      i,\n      j,\n      k; // Fast incremental update based on previous lo index.\n\n  if (lo1 < lo0) {\n    for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      add.push(k);\n    }\n  } else if (lo1 > lo0) {\n    for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      rem.push(k);\n    }\n  } // Fast incremental update based on previous hi index.\n\n\n  if (hi1 > hi0) {\n    for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      add.push(k);\n    }\n  } else if (hi1 < hi0) {\n    for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      rem.push(k);\n    }\n  }\n\n  dim.range = query.slice();\n};","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-crossfilter/src/CrossFilter.js"],"names":["Bitmaps","Dimension","SortedIndex","Transform","inherits","CrossFilter","params","call","_indices","_dims","Definition","prototype","transform","_","pulse","init","modified","fields","some","f","reinit","eval","query","indices","dims","m","length","i","key","index","fname","push","output","materialize","fork","bits","value","curr","prev","all","out","rem","add","mod","adds","mods","remMap","modMap","n","set","remove","_index","insert","source","onAdd","data","mask","update","modify","tuples","k","size","j","resize","map","reindex","num","runAfter","indexMap","stamp","q","filters","one","incrementOne","incrementAll","dim","seen","old","bisect","range","lo1","hi1","lo0","hi0","Math","min","max","slice"],"mappings":"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","sourcesContent":["import Bitmaps from './Bitmaps';\nimport Dimension from './Dimension';\nimport SortedIndex from './SortedIndex';\nimport {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\nexport default function CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\n\nCrossFilter.Definition = {\n  \"type\": \"CrossFilter\",\n  \"metadata\": {},\n  \"params\": [\n    { \"name\": \"fields\", \"type\": \"field\", \"array\": true, \"required\": true },\n    { \"name\": \"query\", \"type\": \"array\", \"array\": true, \"required\": true,\n      \"content\": {\"type\": \"number\", \"array\": true, \"length\": 2} }\n  ]\n};\n\nvar prototype = inherits(CrossFilter, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (!this._dims) {\n    return this.init(_, pulse);\n  } else {\n    var init = _.modified('fields')\n          || _.fields.some(function(f) { return pulse.modified(f.fields); });\n\n    return init\n      ? this.reinit(_, pulse)\n      : this.eval(_, pulse);\n  }\n};\n\nprototype.init = function(_, pulse) {\n  var fields = _.fields,\n      query = _.query,\n      indices = this._indices = {},\n      dims = this._dims = [],\n      m = query.length,\n      i = 0, key, index;\n\n  // instantiate indices and dimensions\n  for (; i<m; ++i) {\n    key = fields[i].fname;\n    index = indices[key] || (indices[key] = SortedIndex());\n    dims.push(Dimension(index, i, query[i]));\n  }\n\n  return this.eval(_, pulse);\n};\n\nprototype.reinit = function(_, pulse) {\n  var output = pulse.materialize().fork(),\n      fields = _.fields,\n      query = _.query,\n      indices = this._indices,\n      dims = this._dims,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      out = (output.rem = output.add),\n      mod = output.mod,\n      m = query.length,\n      adds = {}, add, index, key,\n      mods, remMap, modMap, i, n, f;\n\n  // set prev to current state\n  prev.set(curr);\n\n  // if pulse has remove tuples, process them first\n  if (pulse.rem.length) {\n    remMap = this.remove(_, pulse, output);\n  }\n\n  // if pulse has added tuples, add them to state\n  if (pulse.add.length) {\n    bits.add(pulse.add);\n  }\n\n  // if pulse has modified tuples, create an index map\n  if (pulse.mod.length) {\n    modMap = {};\n    for (mods=pulse.mod, i=0, n=mods.length; i<n; ++i) {\n      modMap[mods[i]._index] = 1;\n    }\n  }\n\n  // re-initialize indices as needed, update curr bitmap\n  for (i=0; i<m; ++i) {\n    f = fields[i];\n    if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n      key = f.fname;\n      if (!(add = adds[key])) {\n        indices[key] = index = SortedIndex();\n        adds[key] = add = index.insert(f, pulse.source, 0);\n      }\n      dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n    }\n  }\n\n  // visit each tuple\n  // if filter state changed, push index to add/rem\n  // else if in mod and passes a filter, push index to mod\n  for (i=0, n=bits.data().length; i<n; ++i) {\n    if (remMap[i]) { // skip if removed tuple\n      continue;\n    } else if (prev[i] !== curr[i]) { // add if state changed\n      out.push(i);\n    } else if (modMap[i] && curr[i] !== all) { // otherwise, pass mods through\n      mod.push(i);\n    }\n  }\n\n  bits.mask = (1 << m) - 1;\n  return output;\n};\n\nprototype.eval = function(_, pulse) {\n  var output = pulse.materialize().fork(),\n      m = this._dims.length,\n      mask = 0;\n\n  if (pulse.rem.length) {\n    this.remove(_, pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  if (_.modified('query') && !_.modified('fields')) {\n    mask |= this.update(_, pulse, output);\n  }\n\n  if (pulse.add.length) {\n    this.insert(_, pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  if (pulse.mod.length) {\n    this.modify(pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  this.value.mask = mask;\n  return output;\n};\n\nprototype.insert = function(_, pulse, output) {\n  var tuples = pulse.add,\n      bits = this.value,\n      dims = this._dims,\n      indices = this._indices,\n      fields = _.fields,\n      adds = {},\n      out = output.add,\n      k = bits.size(),\n      n = k + tuples.length,\n      m = dims.length, j, key, add;\n\n  // resize bitmaps and add tuples as needed\n  bits.resize(n, m);\n  bits.add(tuples);\n\n  var curr = bits.curr(),\n      prev = bits.prev(),\n      all  = bits.all();\n\n  // add to dimensional indices\n  for (j=0; j<m; ++j) {\n    key = fields[j].fname;\n    add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n    dims[j].onAdd(add, curr);\n  }\n\n  // set previous filters, output if passes at least one filter\n  for (; k<n; ++k) {\n    prev[k] = all;\n    if (curr[k] !== all) out.push(k);\n  }\n};\n\nprototype.modify = function(pulse, output) {\n  var out = output.mod,\n      bits = this.value,\n      curr = bits.curr(),\n      all  = bits.all(),\n      tuples = pulse.mod,\n      i, n, k;\n\n  for (i=0, n=tuples.length; i<n; ++i) {\n    k = tuples[i]._index;\n    if (curr[k] !== all) out.push(k);\n  }\n};\n\nprototype.remove = function(_, pulse, output) {\n  var indices = this._indices,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all  = bits.all(),\n      map = {},\n      out = output.rem,\n      tuples = pulse.rem,\n      i, n, k, f;\n\n  // process tuples, output if passes at least one filter\n  for (i=0, n=tuples.length; i<n; ++i) {\n    k = tuples[i]._index;\n    map[k] = 1; // build index map\n    prev[k] = (f = curr[k]);\n    curr[k] = all;\n    if (f !== all) out.push(k);\n  }\n\n  // remove from dimensional indices\n  for (k in indices) {\n    indices[k].remove(n, map);\n  }\n\n  this.reindex(pulse, n, map);\n  return map;\n};\n\n// reindex filters and indices after propagation completes\nprototype.reindex = function(pulse, num, map) {\n  var indices = this._indices,\n      bits = this.value;\n\n  pulse.runAfter(function() {\n    var indexMap = bits.remove(num, map);\n    for (var key in indices) indices[key].reindex(indexMap);\n  });\n};\n\nprototype.update = function(_, pulse, output) {\n  var dims = this._dims,\n      query = _.query,\n      stamp = pulse.stamp,\n      m = dims.length,\n      mask = 0, i, q;\n\n  // survey how many queries have changed\n  output.filters = 0;\n  for (q=0; q<m; ++q) {\n    if (_.modified('query', q)) { i = q; ++mask; }\n  }\n\n  if (mask === 1) {\n    // only one query changed, use more efficient update\n    mask = dims[i].one;\n    this.incrementOne(dims[i], query[i], output.add, output.rem);\n  } else {\n    // multiple queries changed, perform full record keeping\n    for (q=0, mask=0; q<m; ++q) {\n      if (!_.modified('query', q)) continue;\n      mask |= dims[q].one;\n      this.incrementAll(dims[q], query[q], stamp, output.add);\n      output.rem = output.add; // duplicate add/rem for downstream resolve\n    }\n  }\n\n  return mask;\n};\n\nprototype.incrementAll = function(dim, query, stamp, out) {\n  var bits = this.value,\n      seen = bits.seen(),\n      curr = bits.curr(),\n      prev = bits.prev(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one,\n      i, j, k;\n\n  // Fast incremental update based on previous lo index.\n  if (lo1 < lo0) {\n    for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  } else if (lo1 > lo0) {\n    for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  }\n\n  // Fast incremental update based on previous hi index.\n  if (hi1 > hi0) {\n    for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  } else if (hi1 < hi0) {\n    for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  }\n\n  dim.range = query.slice();\n};\n\nprototype.incrementOne = function(dim, query, add, rem) {\n  var bits = this.value,\n      curr = bits.curr(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one,\n      i, j, k;\n\n  // Fast incremental update based on previous lo index.\n  if (lo1 < lo0) {\n    for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      add.push(k);\n    }\n  } else if (lo1 > lo0) {\n    for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      rem.push(k);\n    }\n  }\n\n  // Fast incremental update based on previous hi index.\n  if (hi1 > hi0) {\n    for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      add.push(k);\n    }\n  } else if (hi1 < hi0) {\n    for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      rem.push(k);\n    }\n  }\n\n  dim.range = query.slice();\n};\n"]},"metadata":{},"sourceType":"module"}