{"ast":null,"code":"import { FACET_CHANNELS } from '../../channel';\nimport { title as fieldDefTitle } from '../../channeldef';\nimport { contains, getFirstDefined } from '../../util';\nimport { assembleAxis } from '../axis/assemble';\nimport { parseGuideResolve } from '../resolve';\nimport { getHeaderProperty } from './common';\nimport { isArray } from 'vega-util';\nexport function getHeaderType(orient) {\n  if (orient === 'top' || orient === 'left') {\n    return 'header';\n  }\n\n  return 'footer';\n}\nexport function parseFacetHeaders(model) {\n  for (const channel of FACET_CHANNELS) {\n    parseFacetHeader(model, channel);\n  }\n\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\n\nfunction parseFacetHeader(model, channel) {\n  var _a;\n\n  if (model.channelHasField(channel)) {\n    const fieldDef = model.facet[channel];\n    const titleConfig = getHeaderProperty('title', null, model.config, channel);\n    let title = fieldDefTitle(fieldDef, model.config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n\n    if (model.child.component.layoutHeaders[channel].title) {\n      // TODO: better handle multiline titles\n      title = isArray(title) ? title.join(', ') : title; // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n\n      title += ' / ' + model.child.component.layoutHeaders[channel].title;\n      model.child.component.layoutHeaders[channel].title = null;\n    }\n\n    const labelOrient = getHeaderProperty('labelOrient', fieldDef, model.config, channel);\n    const header = (_a = fieldDef.header, _a !== null && _a !== void 0 ? _a : {});\n    const labels = getFirstDefined(header.labels, true);\n    const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n    model.component.layoutHeaders[channel] = {\n      title,\n      facetFieldDef: fieldDef,\n      [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n    };\n  }\n}\n\nfunction makeHeaderComponent(model, channel, labels) {\n  const sizeType = channel === 'row' ? 'height' : 'width';\n  return {\n    labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\n\nfunction mergeChildAxis(model, channel) {\n  var _a;\n\n  const {\n    child\n  } = model;\n\n  if (child.component.axes[channel]) {\n    const {\n      layoutHeaders,\n      resolve\n    } = model.component;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      const headerChannel = channel === 'x' ? 'column' : 'row';\n      const layoutHeader = layoutHeaders[headerChannel];\n\n      for (const axisComponent of child.component.axes[channel]) {\n        const headerType = getHeaderType(axisComponent.get('orient'));\n        layoutHeader[headerType] = (_a = layoutHeader[headerType], _a !== null && _a !== void 0 ? _a : [makeHeaderComponent(model, headerChannel, false)]); // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n\n        const mainAxis = assembleAxis(axisComponent, 'main', model.config, {\n          header: true\n        }); // LayoutHeader no longer keep track of property precedence, thus let's combine.\n\n        layoutHeader[headerType][0].axes.push(mainAxis);\n        axisComponent.mainExtracted = true;\n      }\n    } else {// Otherwise do nothing for independent axes\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/header/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {AxisOrient} from 'vega';\nimport {FacetChannel, FACET_CHANNELS} from '../../channel';\nimport {title as fieldDefTitle} from '../../channeldef';\nimport {contains, getFirstDefined} from '../../util';\nimport {assembleAxis} from '../axis/assemble';\nimport {FacetModel} from '../facet';\nimport {parseGuideResolve} from '../resolve';\nimport {getHeaderProperty} from './common';\nimport {HeaderChannel, HeaderComponent} from './component';\nimport {isArray} from 'vega-util';\n\nexport function getHeaderType(orient: AxisOrient) {\n  if (orient === 'top' || orient === 'left') {\n    return 'header';\n  }\n  return 'footer';\n}\n\nexport function parseFacetHeaders(model: FacetModel) {\n  for (const channel of FACET_CHANNELS) {\n    parseFacetHeader(model, channel);\n  }\n\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\n\nfunction parseFacetHeader(model: FacetModel, channel: FacetChannel) {\n  if (model.channelHasField(channel)) {\n    const fieldDef = model.facet[channel];\n    const titleConfig = getHeaderProperty('title', null, model.config, channel);\n    let title = fieldDefTitle(fieldDef, model.config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n\n    if (model.child.component.layoutHeaders[channel].title) {\n      // TODO: better handle multiline titles\n      title = isArray(title) ? title.join(', ') : title;\n\n      // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n      title += ' / ' + model.child.component.layoutHeaders[channel].title;\n      model.child.component.layoutHeaders[channel].title = null;\n    }\n\n    const labelOrient = getHeaderProperty('labelOrient', fieldDef, model.config, channel);\n\n    const header = fieldDef.header ?? {};\n    const labels = getFirstDefined(header.labels, true);\n    const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n\n    model.component.layoutHeaders[channel] = {\n      title,\n      facetFieldDef: fieldDef,\n      [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n    };\n  }\n}\n\nfunction makeHeaderComponent(model: FacetModel, channel: HeaderChannel, labels: boolean): HeaderComponent {\n  const sizeType = channel === 'row' ? 'height' : 'width';\n\n  return {\n    labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\n\nfunction mergeChildAxis(model: FacetModel, channel: 'x' | 'y') {\n  const {child} = model;\n  if (child.component.axes[channel]) {\n    const {layoutHeaders, resolve} = model.component;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      const headerChannel = channel === 'x' ? 'column' : 'row';\n\n      const layoutHeader = layoutHeaders[headerChannel];\n      for (const axisComponent of child.component.axes[channel]) {\n        const headerType = getHeaderType(axisComponent.get('orient'));\n        layoutHeader[headerType] = layoutHeader[headerType] ?? [makeHeaderComponent(model, headerChannel, false)];\n\n        // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n        const mainAxis = assembleAxis(axisComponent, 'main', model.config, {header: true});\n        // LayoutHeader no longer keep track of property precedence, thus let's combine.\n        layoutHeader[headerType][0].axes.push(mainAxis);\n        axisComponent.mainExtracted = true;\n      }\n    } else {\n      // Otherwise do nothing for independent axes\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}