{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction vertexShaderSource() {\n  return `#version 300 es\nprecision highp float;\nprecision highp int;\n\nin vec2 position;\nin vec2 texCoords;\nout vec2 uv;\n\nvoid main() {\n  uv = texCoords;\n  gl_Position = vec4(position, 0, 1);\n}`;\n}\n\nexports.vertexShaderSource = vertexShaderSource;\n\nfunction fragmentShaderSource(sourceDims, targetDims, alignCorners) {\n  const sWidth = sourceDims.width;\n  const sHeight = sourceDims.height;\n  const tWidth = targetDims.width;\n  const tHeight = targetDims.height;\n  const effectiveInSize = [alignCorners && tWidth > 1 ? sWidth - 1 : sWidth, alignCorners && tHeight > 1 ? sHeight - 1 : sHeight];\n  const effectiveOutSize = [alignCorners && tWidth > 1 ? tWidth - 1 : tWidth, alignCorners && tHeight > 1 ? tHeight - 1 : tHeight];\n  const outputFragType = targetDims.depth === 3 ? 'vec3' : 'vec4';\n  const outputFragColor = targetDims.depth === 3 ? 'vec3(texSample.r,texSample.g,texSample.b)' : 'texSample';\n  const source = `#version 300 es\nprecision highp float;\n\nuniform sampler2D inputTexture;\nin vec2 uv;\nout ${outputFragType} fragColor;\n\nvec2 sourceDims = vec2(${sWidth}, ${sHeight});\nvec2 targetDims = vec2(${tWidth}, ${tHeight});\n\nconst vec2 inputToOutputRatio = vec2(\n    ${effectiveInSize[0] / effectiveOutSize[0]},\n    ${effectiveInSize[1] / effectiveOutSize[1]});\n\nvoid main() {\n  ivec2 targetCoords = ivec2(uv * targetDims);\n\n  vec2 sourceCoords = vec2(targetCoords) * inputToOutputRatio;\n\n  ivec2 sourceFloor = ivec2(sourceCoords);\n  ivec2 sourceCeil = ivec2(min(sourceDims - 1.0, ceil(sourceCoords)));\n\n  vec4 topLeft = texelFetch(inputTexture,\n    ivec2(sourceFloor.x, sourceFloor.y), 0);\n  vec4 bottomLeft = texelFetch(inputTexture,\n    ivec2(sourceCeil.x, sourceFloor.y), 0);\n  vec4 topRight = texelFetch(inputTexture,\n    ivec2(sourceFloor.x, sourceCeil.y), 0);\n  vec4 bottomRight = texelFetch(inputTexture,\n    ivec2(sourceCeil.x, sourceCeil.y), 0);\n\n  vec2 fracRC = sourceCoords - vec2(sourceFloor);\n\n  vec4 top = topLeft + (topRight - topLeft) * fracRC.y;\n  vec4 bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n  vec4 newValue = top + (bottom - top) * fracRC.x;\n\n  vec4 texSample = newValue;\n  fragColor = ${outputFragColor};\n}\n`;\n  return source;\n}\n\nexports.fragmentShaderSource = fragmentShaderSource;\n\nfunction vertices() {\n  return new Float32Array([// clang-format off\n  -1, -1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1]);\n}\n\nexports.vertices = vertices;\n\nfunction texCoords() {\n  return new Float32Array([// clang-format off\n  0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0]);\n}\n\nexports.texCoords = texCoords;","map":{"version":3,"sources":["../../src/camera/resize_bilinear_program_info.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;AAyBA,SAAgB,kBAAhB,GAAkC;AAChC,SAAO;;;;;;;;;;;EAAP;AAYD;;AAbD,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAeA,SAAgB,oBAAhB,CACI,UADJ,EAC4B,UAD5B,EACoD,YADpD,EACyE;AACvE,QAAM,MAAM,GAAG,UAAU,CAAC,KAA1B;AACA,QAAM,OAAO,GAAG,UAAU,CAAC,MAA3B;AACA,QAAM,MAAM,GAAG,UAAU,CAAC,KAA1B;AACA,QAAM,OAAO,GAAG,UAAU,CAAC,MAA3B;AAEA,QAAM,eAAe,GAAqB,CACvC,YAAY,IAAI,MAAM,GAAG,CAA1B,GAA+B,MAAM,GAAG,CAAxC,GAA4C,MADJ,EAEvC,YAAY,IAAI,OAAO,GAAG,CAA3B,GAAgC,OAAO,GAAG,CAA1C,GAA8C,OAFN,CAA1C;AAKA,QAAM,gBAAgB,GAAqB,CACxC,YAAY,IAAI,MAAM,GAAG,CAA1B,GAA+B,MAAM,GAAG,CAAxC,GAA4C,MADH,EAExC,YAAY,IAAI,OAAO,GAAG,CAA3B,GAAgC,OAAO,GAAG,CAA1C,GAA8C,OAFL,CAA3C;AAKA,QAAM,cAAc,GAAG,UAAU,CAAC,KAAX,KAAqB,CAArB,GAAyB,MAAzB,GAAkC,MAAzD;AACA,QAAM,eAAe,GAAG,UAAU,CAAC,KAAX,KAAqB,CAArB,GACpB,2CADoB,GAEpB,WAFJ;AAIA,QAAM,MAAM,GAAG;;;;;MAKX,cAAc;;yBAEK,MAAM,KAAK,OAAO;yBAClB,MAAM,KAAK,OAAO;;;MAGrC,eAAe,CAAC,CAAD,CAAf,GAAqB,gBAAgB,CAAC,CAAD,CAAG;MACxC,eAAe,CAAC,CAAD,CAAf,GAAqB,gBAAgB,CAAC,CAAD,CAAG;;;;;;;;;;;;;;;;;;;;;;;;;;gBA0B9B,eAAe;;CAtC7B;AA0CA,SAAO,MAAP;AACD;;AAjED,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAmEA,SAAgB,QAAhB,GAAwB;AACtB,SAAO,IAAI,YAAJ,CAAiB,CACtB;AACA,GAAC,CAFqB,EAElB,CAAC,CAFiB,EAGtB,CAAC,CAHqB,EAGlB,CAHkB,EAItB,CAJsB,EAInB,CAJmB,EAKtB,CALsB,EAKnB,CALmB,EAMtB,CAAC,CANqB,EAMlB,CAAC,CANiB,EAOtB,CAPsB,EAOnB,CAAC,CAPkB,CAAjB,CAAP;AAUD;;AAXD,OAAA,CAAA,QAAA,GAAA,QAAA;;AAaA,SAAgB,SAAhB,GAAyB;AACvB,SAAO,IAAI,YAAJ,CAAiB,CACtB;AACA,GAFsB,EAEnB,CAFmB,EAGtB,CAHsB,EAGnB,CAHmB,EAItB,CAJsB,EAInB,CAJmB,EAKtB,CALsB,EAKnB,CALmB,EAMtB,CANsB,EAMnB,CANmB,EAOtB,CAPsB,EAOnB,CAPmB,CAAjB,CAAP;AAUD;;AAXD,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction vertexShaderSource() {\n    return `#version 300 es\nprecision highp float;\nprecision highp int;\n\nin vec2 position;\nin vec2 texCoords;\nout vec2 uv;\n\nvoid main() {\n  uv = texCoords;\n  gl_Position = vec4(position, 0, 1);\n}`;\n}\nexports.vertexShaderSource = vertexShaderSource;\nfunction fragmentShaderSource(sourceDims, targetDims, alignCorners) {\n    const sWidth = sourceDims.width;\n    const sHeight = sourceDims.height;\n    const tWidth = targetDims.width;\n    const tHeight = targetDims.height;\n    const effectiveInSize = [\n        (alignCorners && tWidth > 1) ? sWidth - 1 : sWidth,\n        (alignCorners && tHeight > 1) ? sHeight - 1 : sHeight,\n    ];\n    const effectiveOutSize = [\n        (alignCorners && tWidth > 1) ? tWidth - 1 : tWidth,\n        (alignCorners && tHeight > 1) ? tHeight - 1 : tHeight,\n    ];\n    const outputFragType = targetDims.depth === 3 ? 'vec3' : 'vec4';\n    const outputFragColor = targetDims.depth === 3 ?\n        'vec3(texSample.r,texSample.g,texSample.b)' :\n        'texSample';\n    const source = `#version 300 es\nprecision highp float;\n\nuniform sampler2D inputTexture;\nin vec2 uv;\nout ${outputFragType} fragColor;\n\nvec2 sourceDims = vec2(${sWidth}, ${sHeight});\nvec2 targetDims = vec2(${tWidth}, ${tHeight});\n\nconst vec2 inputToOutputRatio = vec2(\n    ${effectiveInSize[0] / effectiveOutSize[0]},\n    ${effectiveInSize[1] / effectiveOutSize[1]});\n\nvoid main() {\n  ivec2 targetCoords = ivec2(uv * targetDims);\n\n  vec2 sourceCoords = vec2(targetCoords) * inputToOutputRatio;\n\n  ivec2 sourceFloor = ivec2(sourceCoords);\n  ivec2 sourceCeil = ivec2(min(sourceDims - 1.0, ceil(sourceCoords)));\n\n  vec4 topLeft = texelFetch(inputTexture,\n    ivec2(sourceFloor.x, sourceFloor.y), 0);\n  vec4 bottomLeft = texelFetch(inputTexture,\n    ivec2(sourceCeil.x, sourceFloor.y), 0);\n  vec4 topRight = texelFetch(inputTexture,\n    ivec2(sourceFloor.x, sourceCeil.y), 0);\n  vec4 bottomRight = texelFetch(inputTexture,\n    ivec2(sourceCeil.x, sourceCeil.y), 0);\n\n  vec2 fracRC = sourceCoords - vec2(sourceFloor);\n\n  vec4 top = topLeft + (topRight - topLeft) * fracRC.y;\n  vec4 bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n  vec4 newValue = top + (bottom - top) * fracRC.x;\n\n  vec4 texSample = newValue;\n  fragColor = ${outputFragColor};\n}\n`;\n    return source;\n}\nexports.fragmentShaderSource = fragmentShaderSource;\nfunction vertices() {\n    return new Float32Array([\n        // clang-format off\n        -1, -1,\n        -1, 1,\n        1, 1,\n        1, 1,\n        -1, -1,\n        1, -1,\n    ]);\n}\nexports.vertices = vertices;\nfunction texCoords() {\n    return new Float32Array([\n        // clang-format off\n        0, 0,\n        0, 1,\n        1, 1,\n        1, 1,\n        0, 0,\n        1, 0,\n    ]);\n}\nexports.texCoords = texCoords;\n//# sourceMappingURL=resize_bilinear_program_info.js.map"]},"metadata":{},"sourceType":"script"}