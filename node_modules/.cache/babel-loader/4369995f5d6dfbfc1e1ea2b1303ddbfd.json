{"ast":null,"code":"import bandSpace from './bandSpace';\nimport { range as sequence, bisectRight } from 'd3-array';\nimport { scaleOrdinal as ordinal } from 'd3-scale';\nexport function band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse],\n        space = bandSpace(n, paddingInner, paddingOuter);\n    step = (stop - start) / (space || 1);\n\n    if (round) {\n      step = Math.floor(step);\n    }\n\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n\n    if (round) {\n      start = Math.round(start);\n      bandwidth = Math.round(bandwidth);\n    }\n\n    var values = sequence(n).map(function (i) {\n      return start + step * i;\n    });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function (_) {\n    if (arguments.length) {\n      domain(_);\n      return rescale();\n    } else {\n      return domain();\n    }\n  };\n\n  scale.range = function (_) {\n    if (arguments.length) {\n      range = [+_[0], +_[1]];\n      return rescale();\n    } else {\n      return range.slice();\n    }\n  };\n\n  scale.rangeRound = function (_) {\n    range = [+_[0], +_[1]];\n    round = true;\n    return rescale();\n  };\n\n  scale.bandwidth = function () {\n    return bandwidth;\n  };\n\n  scale.step = function () {\n    return step;\n  };\n\n  scale.round = function (_) {\n    if (arguments.length) {\n      round = !!_;\n      return rescale();\n    } else {\n      return round;\n    }\n  };\n\n  scale.padding = function (_) {\n    if (arguments.length) {\n      paddingOuter = Math.max(0, Math.min(1, _));\n      paddingInner = paddingOuter;\n      return rescale();\n    } else {\n      return paddingInner;\n    }\n  };\n\n  scale.paddingInner = function (_) {\n    if (arguments.length) {\n      paddingInner = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return paddingInner;\n    }\n  };\n\n  scale.paddingOuter = function (_) {\n    if (arguments.length) {\n      paddingOuter = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return paddingOuter;\n    }\n  };\n\n  scale.align = function (_) {\n    if (arguments.length) {\n      align = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return align;\n    }\n  };\n\n  scale.invertRange = function (_) {\n    // bail if range has null or undefined values\n    if (_[0] == null || _[1] == null) return;\n    var lo = +_[0],\n        hi = +_[1],\n        reverse = range[1] < range[0],\n        values = reverse ? ordinalRange().reverse() : ordinalRange(),\n        n = values.length - 1,\n        a,\n        b,\n        t; // bail if either range endpoint is invalid\n\n    if (lo !== lo || hi !== hi) return; // order range inputs, bail if outside of scale range\n\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n\n    if (hi < values[0] || lo > range[1 - reverse]) return; // binary search to index into scale range\n\n    a = Math.max(0, bisectRight(values, lo) - 1);\n    b = lo === hi ? a : bisectRight(values, hi) - 1; // increment index a if lo is within padding gap\n\n    if (lo - values[a] > bandwidth + 1e-10) ++a;\n\n    if (reverse) {\n      // map + swap\n      t = a;\n      a = n - b;\n      b = n - t;\n    }\n\n    return a > b ? undefined : domain().slice(a, b + 1);\n  };\n\n  scale.invert = function (_) {\n    var value = scale.invertRange([_, _]);\n    return value ? value[0] : value;\n  };\n\n  scale.copy = function () {\n    return band().domain(domain()).range(range).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);\n  };\n\n  return rescale();\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n\n  scale.copy = function () {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nexport function point() {\n  return pointish(band().paddingInner(1));\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-encode/node_modules/vega-scale/src/scales/scaleBand.js"],"names":["bandSpace","range","sequence","bisectRight","scaleOrdinal","ordinal","band","scale","unknown","undefined","domain","ordinalRange","step","bandwidth","round","paddingInner","paddingOuter","align","rescale","n","length","reverse","start","stop","space","Math","floor","values","map","i","_","arguments","slice","rangeRound","padding","max","min","invertRange","lo","hi","a","b","t","invert","value","copy","pointish","point"],"mappings":"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","sourcesContent":["import bandSpace from './bandSpace';\nimport {range as sequence, bisectRight} from 'd3-array';\nimport {scaleOrdinal as ordinal} from 'd3-scale';\n\nexport function band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse],\n        space = bandSpace(n, paddingInner, paddingOuter);\n\n    step = (stop - start) / (space || 1);\n    if (round) {\n      step = Math.floor(step);\n    }\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) {\n      start = Math.round(start);\n      bandwidth = Math.round(bandwidth);\n    }\n    var values = sequence(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    if (arguments.length) {\n      domain(_);\n      return rescale();\n    } else {\n      return domain();\n    }\n  };\n\n  scale.range = function(_) {\n    if (arguments.length) {\n      range = [+_[0], +_[1]];\n      return rescale();\n    } else {\n      return range.slice();\n    }\n  };\n\n  scale.rangeRound = function(_) {\n    range = [+_[0], +_[1]];\n    round = true;\n    return rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    if (arguments.length) {\n      round = !!_;\n      return rescale();\n    } else {\n      return round;\n    }\n  };\n\n  scale.padding = function(_) {\n    if (arguments.length) {\n      paddingOuter = Math.max(0, Math.min(1, _));\n      paddingInner = paddingOuter;\n      return rescale();\n    } else {\n      return paddingInner;\n    }\n  };\n\n  scale.paddingInner = function(_) {\n    if (arguments.length) {\n      paddingInner = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return paddingInner;\n    }\n  };\n\n  scale.paddingOuter = function(_) {\n    if (arguments.length) {\n      paddingOuter = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return paddingOuter;\n    }\n  };\n\n  scale.align = function(_) {\n    if (arguments.length) {\n      align = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return align;\n    }\n  };\n\n  scale.invertRange = function(_) {\n    // bail if range has null or undefined values\n    if (_[0] == null || _[1] == null) return;\n\n    var lo = +_[0],\n        hi = +_[1],\n        reverse = range[1] < range[0],\n        values = reverse ? ordinalRange().reverse() : ordinalRange(),\n        n = values.length - 1, a, b, t;\n\n    // bail if either range endpoint is invalid\n    if (lo !== lo || hi !== hi) return;\n\n    // order range inputs, bail if outside of scale range\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n    if (hi < values[0] || lo > range[1-reverse]) return;\n\n    // binary search to index into scale range\n    a = Math.max(0, bisectRight(values, lo) - 1);\n    b = lo===hi ? a : bisectRight(values, hi) - 1;\n\n    // increment index a if lo is within padding gap\n    if (lo - values[a] > bandwidth + 1e-10) ++a;\n\n    if (reverse) {\n      // map + swap\n      t = a;\n      a = n - b;\n      b = n - t;\n    }\n    return (a > b) ? undefined : domain().slice(a, b+1);\n  };\n\n  scale.invert = function(_) {\n    var value = scale.invertRange([_, _]);\n    return value ? value[0] : value;\n  };\n\n  scale.copy = function() {\n    return band()\n        .domain(domain())\n        .range(range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return rescale();\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nexport function point() {\n  return pointish(band().paddingInner(1));\n}\n"]},"metadata":{},"sourceType":"module"}