{"ast":null,"code":"import { selector as parseSelector } from 'vega-event-selector';\nimport { stringValue } from 'vega-util';\nimport { X, Y } from '../../../channel';\nimport { BRUSH as INTERVAL_BRUSH } from '../interval';\nimport { default as scalesCompiler, domain } from './scales';\nconst ANCHOR = '_zoom_anchor';\nconst DELTA = '_zoom_delta';\nconst zoom = {\n  has: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.zoom;\n  },\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const hasScales = scalesCompiler.has(selCmpt);\n    const delta = name + DELTA;\n    const {\n      x,\n      y\n    } = selCmpt.project.hasChannel;\n    const sx = stringValue(model.scaleName(X));\n    const sy = stringValue(model.scaleName(Y));\n    let events = parseSelector(selCmpt.zoom, 'scope');\n\n    if (!hasScales) {\n      events = events.map(e => (e.markname = name + INTERVAL_BRUSH, e));\n    }\n\n    signals.push({\n      name: name + ANCHOR,\n      on: [{\n        events: events,\n        update: !hasScales ? `{x: x(unit), y: y(unit)}` : '{' + [sx ? `x: invert(${sx}, x(unit))` : '', sy ? `y: invert(${sy}, y(unit))` : ''].filter(expr => !!expr).join(', ') + '}'\n      }]\n    }, {\n      name: delta,\n      on: [{\n        events: events,\n        force: true,\n        update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'\n      }]\n    });\n\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', signals);\n    }\n\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\nexport default zoom;\n\nfunction onDelta(model, selCmpt, proj, size, signals) {\n  var _a;\n\n  const name = selCmpt.name;\n  const channel = proj.channel;\n  const hasScales = scalesCompiler.has(selCmpt);\n  const signal = signals.filter(s => s.name === proj.signals[hasScales ? 'data' : 'visual'])[0];\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt.get('type');\n  const base = hasScales ? domain(model, channel) : signal.name;\n  const delta = name + DELTA;\n  const anchor = `${name}${ANCHOR}.${channel}`;\n  const zoomFn = !hasScales ? 'zoomLinear' : scaleType === 'log' ? 'zoomLog' : scaleType === 'pow' ? 'zoomPow' : 'zoomLinear';\n  const update = `${zoomFn}(${base}, ${anchor}, ${delta}` + (hasScales && scaleType === 'pow' ? `, ${(_a = scaleCmpt.get('exponent'), _a !== null && _a !== void 0 ? _a : 1)}` : '') + ')';\n  signal.on.push({\n    events: {\n      signal: delta\n    },\n    update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/selection/transforms/zoom.ts"],"names":[],"mappings":"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","sourcesContent":["import {NewSignal} from 'vega';\nimport {selector as parseSelector} from 'vega-event-selector';\nimport {stringValue} from 'vega-util';\nimport {SelectionComponent} from '..';\nimport {ScaleChannel, X, Y} from '../../../channel';\nimport {UnitModel} from '../../unit';\nimport {BRUSH as INTERVAL_BRUSH} from '../interval';\nimport {SelectionProjection} from './project';\nimport {default as scalesCompiler, domain} from './scales';\nimport {TransformCompiler} from './transforms';\n\nconst ANCHOR = '_zoom_anchor';\nconst DELTA = '_zoom_delta';\n\nconst zoom: TransformCompiler = {\n  has: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.zoom;\n  },\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const hasScales = scalesCompiler.has(selCmpt);\n    const delta = name + DELTA;\n    const {x, y} = selCmpt.project.hasChannel;\n    const sx = stringValue(model.scaleName(X));\n    const sy = stringValue(model.scaleName(Y));\n    let events = parseSelector(selCmpt.zoom, 'scope');\n\n    if (!hasScales) {\n      events = events.map(e => ((e.markname = name + INTERVAL_BRUSH), e));\n    }\n\n    signals.push(\n      {\n        name: name + ANCHOR,\n        on: [\n          {\n            events: events,\n            update: !hasScales\n              ? `{x: x(unit), y: y(unit)}`\n              : '{' +\n                [sx ? `x: invert(${sx}, x(unit))` : '', sy ? `y: invert(${sy}, y(unit))` : '']\n                  .filter(expr => !!expr)\n                  .join(', ') +\n                '}'\n          }\n        ]\n      },\n      {\n        name: delta,\n        on: [\n          {\n            events: events,\n            force: true,\n            update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'\n          }\n        ]\n      }\n    );\n\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', signals);\n    }\n\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\n\nexport default zoom;\n\nfunction onDelta(\n  model: UnitModel,\n  selCmpt: SelectionComponent,\n  proj: SelectionProjection,\n  size: 'width' | 'height',\n  signals: NewSignal[]\n) {\n  const name = selCmpt.name;\n  const channel = proj.channel as ScaleChannel;\n  const hasScales = scalesCompiler.has(selCmpt);\n  const signal = signals.filter(s => s.name === proj.signals[hasScales ? 'data' : 'visual'])[0];\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt.get('type');\n  const base = hasScales ? domain(model, channel) : signal.name;\n  const delta = name + DELTA;\n  const anchor = `${name}${ANCHOR}.${channel}`;\n  const zoomFn = !hasScales\n    ? 'zoomLinear'\n    : scaleType === 'log'\n    ? 'zoomLog'\n    : scaleType === 'pow'\n    ? 'zoomPow'\n    : 'zoomLinear';\n  const update =\n    `${zoomFn}(${base}, ${anchor}, ${delta}` +\n    (hasScales && scaleType === 'pow' ? `, ${scaleCmpt.get('exponent') ?? 1}` : '') +\n    ')';\n\n  signal.on.push({\n    events: {signal: delta},\n    update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}