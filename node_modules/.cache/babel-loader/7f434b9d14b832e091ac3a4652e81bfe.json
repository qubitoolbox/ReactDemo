{"ast":null,"code":"import { array } from 'vega-util';\nimport { SCALE_CHANNELS } from '../../../channel';\nimport { isPathMark } from '../../../mark';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { VG_MARK_CONFIGS } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { color } from './color';\nimport { nonPosition } from './nonposition';\nimport { text } from './text';\nimport { tooltip } from './tooltip';\nimport { fieldInvalidPredicate } from './valueref';\nexport { color } from './color';\nexport { wrapCondition } from './conditional';\nexport { nonPosition } from './nonposition';\nexport { pointPosition } from './position-point';\nexport { pointOrRangePosition, rangePosition } from './position-range';\nexport { rectPosition } from './position-rect';\nexport { text } from './text';\nexport { tooltip } from './tooltip';\nexport function baseEncodeEntry(model, ignore) {\n  const {\n    fill = undefined,\n    stroke = undefined\n  } = ignore.color === 'include' ? color(model) : {};\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), tooltip(model)), text(model, 'href'));\n} // TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\n\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n  const {\n    config,\n    mark,\n    markDef\n  } = model;\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = allFieldsInvalidPredicate(model, {\n      invalid: true,\n      channels: SCALE_CHANNELS\n    });\n\n    if (test) {\n      return {\n        [channel]: [// prepend the invalid case\n        // TODO: support custom value\n        {\n          test,\n          value: null\n        }, ...array(valueRef)]\n      };\n    }\n  }\n\n  return valueRef ? {\n    [channel]: valueRef\n  } : {};\n}\n\nfunction markDefProperties(mark, ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = {\n        value: mark[prop]\n      };\n    }\n\n    return m;\n  }, {});\n}\n\nfunction allFieldsInvalidPredicate(model, {\n  invalid = false,\n  channels\n}) {\n  const filterIndex = channels.reduce((aggregator, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  const fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/base.ts"],"names":[],"mappings":"AAAA,SAAQ,KAAR,QAAoB,WAApB;AACA,SAA+B,cAA/B,QAAoD,kBAApD;AACA,SAAQ,UAAR,QAAkC,eAAlC;AACA,SAAQ,mBAAR,QAAkC,gBAAlC;AACA,SAAc,IAAd,QAAyB,eAAzB;AACA,SAAmC,eAAnC,QAAyD,sBAAzD;AACA,SAAQ,mBAAR,QAAkC,cAAlC;AAEA,SAAQ,KAAR,QAAoB,SAApB;AACA,SAAQ,WAAR,QAA0B,eAA1B;AACA,SAAQ,IAAR,QAAmB,QAAnB;AACA,SAAQ,OAAR,QAAsB,WAAtB;AACA,SAAQ,qBAAR,QAAoC,YAApC;AAEA,SAAQ,KAAR,QAAoB,SAApB;AACA,SAAQ,aAAR,QAA4B,eAA5B;AACA,SAAQ,WAAR,QAA0B,eAA1B;AACA,SAAQ,aAAR,QAA4B,kBAA5B;AACA,SAAQ,oBAAR,EAA8B,aAA9B,QAAkD,kBAAlD;AACA,SAAQ,YAAR,QAA2B,iBAA3B;AACA,SAAQ,IAAR,QAAmB,QAAnB;AACA,SAAQ,OAAR,QAAsB,WAAtB;AAIA,OAAM,SAAU,eAAV,CAA0B,KAA1B,EAA4C,MAA5C,EAA0D;AAC9D,QAAM;AAAC,IAAA,IAAI,GAAG,SAAR;AAAmB,IAAA,MAAM,GAAG;AAA5B,MAAyC,MAAM,CAAC,KAAP,KAAiB,SAAjB,GAA6B,KAAK,CAAC,KAAD,CAAlC,GAA4C,EAA3F;AACA,SAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,iBAAiB,CAAC,KAAK,CAAC,OAAP,EAAgB,MAAhB,CADtB,CAAA,EAEK,oBAAoB,CAAC,KAAD,EAAQ,MAAR,EAAgB,IAAhB,CAFzB,CAAA,EAGK,oBAAoB,CAAC,KAAD,EAAQ,QAAR,EAAkB,MAAlB,CAHzB,CAAA,EAIK,WAAW,CAAC,SAAD,EAAY,KAAZ,CAJhB,CAAA,EAKK,WAAW,CAAC,aAAD,EAAgB,KAAhB,CALhB,CAAA,EAMK,WAAW,CAAC,eAAD,EAAkB,KAAlB,CANhB,CAAA,EAOK,WAAW,CAAC,aAAD,EAAgB,KAAhB,CAPhB,CAAA,EAQK,OAAO,CAAC,KAAD,CARZ,CAAA,EASK,IAAI,CAAC,KAAD,EAAQ,MAAR,CATT,CAAA;AAWD,C,CAED;;AACA,SAAS,oBAAT,CAA8B,KAA9B,EAAgD,OAAhD,EAAkE,QAAlE,EAAqG;AACnG,QAAM;AAAC,IAAA,MAAD;AAAS,IAAA,IAAT;AAAe,IAAA;AAAf,MAA0B,KAAhC;AAEA,QAAM,OAAO,GAAG,mBAAmB,CAAC,SAAD,EAAY,OAAZ,EAAqB,MAArB,CAAnC;;AAEA,MAAI,OAAO,KAAK,MAAZ,IAAsB,QAAtB,IAAkC,CAAC,UAAU,CAAC,IAAD,CAAjD,EAAyD;AACvD;AACA;AACA,UAAM,IAAI,GAAG,yBAAyB,CAAC,KAAD,EAAQ;AAAC,MAAA,OAAO,EAAE,IAAV;AAAgB,MAAA,QAAQ,EAAE;AAA1B,KAAR,CAAtC;;AACA,QAAI,IAAJ,EAAU;AACR,aAAO;AACL,SAAC,OAAD,GAAW,CACT;AACA;AACA;AAAC,UAAA,IAAD;AAAO,UAAA,KAAK,EAAE;AAAd,SAHS,EAIT,GAAG,KAAK,CAAC,QAAD,CAJC;AADN,OAAP;AAQD;AACF;;AACD,SAAO,QAAQ,GAAG;AAAC,KAAC,OAAD,GAAW;AAAZ,GAAH,GAA2B,EAA1C;AACD;;AAED,SAAS,iBAAT,CAA2B,IAA3B,EAA0C,MAA1C,EAAwD;AACtD,SAAO,eAAe,CAAC,MAAhB,CAAuB,CAAC,CAAD,EAAI,IAAJ,KAAY;AACxC,QAAI,IAAI,CAAC,IAAD,CAAJ,KAAe,SAAf,IAA4B,MAAM,CAAC,IAAD,CAAN,KAAiB,QAAjD,EAA2D;AACzD,MAAA,CAAC,CAAC,IAAD,CAAD,GAAU;AAAC,QAAA,KAAK,EAAE,IAAI,CAAC,IAAD;AAAZ,OAAV;AACD;;AACD,WAAO,CAAP;AACD,GALM,EAKJ,EALI,CAAP;AAMD;;AAED,SAAS,yBAAT,CACE,KADF,EAEE;AAAC,EAAA,OAAO,GAAG,KAAX;AAAkB,EAAA;AAAlB,CAFF,EAE4E;AAE1E,QAAM,WAAW,GAAG,QAAQ,CAAC,MAAT,CAAgB,CAAC,UAAD,EAAyB,OAAzB,KAAoC;AACtE,UAAM,cAAc,GAAG,KAAK,CAAC,iBAAN,CAAwB,OAAxB,CAAvB;;AACA,QAAI,cAAJ,EAAoB;AAClB,YAAM,SAAS,GAAG,cAAc,CAAC,GAAf,CAAmB,MAAnB,CAAlB;AACA,YAAM,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB;AAAC,QAAA,IAAI,EAAE;AAAP,OAAvB,CAAd,CAFkB,CAIlB;;AACA,UAAI,KAAK,IAAI,mBAAmB,CAAC,SAAD,CAAhC,EAA6C;AAC3C,QAAA,UAAU,CAAC,KAAD,CAAV,GAAoB,IAApB;AACD;AACF;;AACD,WAAO,UAAP;AACD,GAZmB,EAYjB,EAZiB,CAApB;AAcA,QAAM,MAAM,GAAG,IAAI,CAAC,WAAD,CAAnB;;AACA,MAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB;AACrB,UAAM,EAAE,GAAG,OAAO,GAAG,IAAH,GAAU,IAA5B;AACA,WAAO,MAAM,CAAC,GAAP,CAAW,KAAK,IAAI,qBAAqB,CAAC,KAAD,EAAQ,OAAR,CAAzC,EAA2D,IAA3D,CAAgE,IAAI,EAAE,GAAtE,CAAP;AACD;;AACD,SAAO,SAAP;AACD","sourcesContent":["import {array} from 'vega-util';\nimport {Channel, ScaleChannel, SCALE_CHANNELS} from '../../../channel';\nimport {isPathMark, MarkDef} from '../../../mark';\nimport {hasContinuousDomain} from '../../../scale';\nimport {Dict, keys} from '../../../util';\nimport {VgEncodeEntry, VgValueRef, VG_MARK_CONFIGS} from '../../../vega.schema';\nimport {getMarkPropOrConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {color} from './color';\nimport {nonPosition} from './nonposition';\nimport {text} from './text';\nimport {tooltip} from './tooltip';\nimport {fieldInvalidPredicate} from './valueref';\n\nexport {color} from './color';\nexport {wrapCondition} from './conditional';\nexport {nonPosition} from './nonposition';\nexport {pointPosition} from './position-point';\nexport {pointOrRangePosition, rangePosition} from './position-range';\nexport {rectPosition} from './position-rect';\nexport {text} from './text';\nexport {tooltip} from './tooltip';\n\nexport type Ignore = Record<'color' | 'size' | 'orient' | 'align' | 'baseline', 'ignore' | 'include'>;\n\nexport function baseEncodeEntry(model: UnitModel, ignore: Ignore) {\n  const {fill = undefined, stroke = undefined} = ignore.color === 'include' ? color(model) : {};\n  return {\n    ...markDefProperties(model.markDef, ignore),\n    ...wrapAllFieldsInvalid(model, 'fill', fill),\n    ...wrapAllFieldsInvalid(model, 'stroke', stroke),\n    ...nonPosition('opacity', model),\n    ...nonPosition('fillOpacity', model),\n    ...nonPosition('strokeOpacity', model),\n    ...nonPosition('strokeWidth', model),\n    ...tooltip(model),\n    ...text(model, 'href')\n  };\n}\n\n// TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\nfunction wrapAllFieldsInvalid(model: UnitModel, channel: Channel, valueRef: VgValueRef | VgValueRef[]): VgEncodeEntry {\n  const {config, mark, markDef} = model;\n\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = allFieldsInvalidPredicate(model, {invalid: true, channels: SCALE_CHANNELS});\n    if (test) {\n      return {\n        [channel]: [\n          // prepend the invalid case\n          // TODO: support custom value\n          {test, value: null},\n          ...array(valueRef)\n        ]\n      };\n    }\n  }\n  return valueRef ? {[channel]: valueRef} : {};\n}\n\nfunction markDefProperties(mark: MarkDef, ignore: Ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = {value: mark[prop]};\n    }\n    return m;\n  }, {});\n}\n\nfunction allFieldsInvalidPredicate(\n  model: UnitModel,\n  {invalid = false, channels}: {invalid?: boolean; channels: ScaleChannel[]}\n) {\n  const filterIndex = channels.reduce((aggregator: Dict<true>, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {expr: 'datum'});\n\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n\n  const fields = keys(filterIndex);\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n  return undefined;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}