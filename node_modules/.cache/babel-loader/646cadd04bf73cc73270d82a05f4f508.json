{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { array, isArray } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../../channel';\nimport * as log from '../../../log';\nimport { hasContinuousDomain } from '../../../scale';\nimport { hash, keys, varName, replacePathInField, duplicate } from '../../../util';\nimport { TimeUnitNode } from '../../data/timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n  constructor(...items) {\n    this.items = items;\n    this.hasChannel = {};\n    this.hasField = {};\n  }\n\n}\nconst project = {\n  has: () => {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n  parse: (model, selCmpt, selDef) => {\n    var _a, _b, _c;\n\n    const name = selCmpt.name;\n    const proj = (_a = selCmpt.project, _a !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent());\n    const parsed = {};\n    const timeUnits = {};\n    const signals = new Set();\n\n    const signalName = (p, range) => {\n      const suffix = range === 'visual' ? p.channel : p.field;\n      let sg = varName(`${name}_${suffix}`);\n\n      for (let counter = 1; signals.has(sg); counter++) {\n        sg = varName(`${name}_${suffix}_${counter}`);\n      }\n\n      signals.add(sg);\n      return {\n        [range]: sg\n      };\n    }; // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    // Otherwise, use the default configuration.\n\n\n    if (!selDef.fields && !selDef.encodings) {\n      const cfg = model.config.selection[selDef.type];\n\n      if (selDef.init) {\n        for (const init of array(selDef.init)) {\n          for (const key of keys(init)) {\n            if (isSingleDefUnitChannel(key)) {\n              (selDef.encodings || (selDef.encodings = [])).push(key);\n            } else {\n              if (selDef.type === 'interval') {\n                log.warn('Interval selections should be initialized using \"x\" and/or \"y\" keys.');\n                selDef.encodings = cfg.encodings;\n              } else {\n                (selDef.fields || (selDef.fields = [])).push(key);\n              }\n            }\n          }\n        }\n      } else {\n        selDef.encodings = cfg.encodings;\n        selDef.fields = cfg.fields;\n      }\n    } // TODO: find a possible channel mapping for these fields.\n\n\n    for (const field of (_b = selDef.fields, _b !== null && _b !== void 0 ? _b : [])) {\n      const p = {\n        type: 'E',\n        field\n      };\n      p.signals = Object.assign({}, signalName(p, 'data'));\n      proj.items.push(p);\n      proj.hasField[field] = p;\n    }\n\n    for (const channel of (_c = selDef.encodings, _c !== null && _c !== void 0 ? _c : [])) {\n      const fieldDef = model.fieldDef(channel);\n\n      if (fieldDef) {\n        let field = fieldDef.field;\n\n        if (fieldDef.aggregate) {\n          log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n          continue;\n        } else if (!field) {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n          continue;\n        }\n\n        if (fieldDef.timeUnit) {\n          field = model.vgField(channel); // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n\n          const component = {\n            as: field,\n            field: fieldDef.field,\n            timeUnit: fieldDef.timeUnit\n          };\n          timeUnits[hash(component)] = component;\n        } // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n\n\n        if (!parsed[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          let type = 'E';\n\n          if (selCmpt.type === 'interval') {\n            const scaleType = model.getScaleComponent(channel).get('type');\n\n            if (hasContinuousDomain(scaleType)) {\n              type = 'R';\n            }\n          } else if (fieldDef.bin) {\n            type = 'R-RE';\n          }\n\n          const p = {\n            field,\n            channel,\n            type\n          };\n          p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n          proj.items.push(parsed[field] = p);\n          proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n\n    if (selDef.init) {\n      const parseInit = i => {\n        return proj.items.map(p => i[p.channel] !== undefined ? i[p.channel] : i[p.field]);\n      };\n\n      if (selDef.type === 'interval') {\n        selCmpt.init = parseInit(selDef.init);\n      } else {\n        const init = isArray(selDef.init) ? selDef.init : [selDef.init];\n        selCmpt.init = init.map(parseInit);\n      }\n    }\n\n    if (keys(timeUnits).length > 0) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n  signals: (model, selCmpt, allSignals) => {\n    const name = selCmpt.name + TUPLE_FIELDS;\n    const hasSignal = allSignals.filter(s => s.name === name);\n    return hasSignal.length > 0 ? allSignals : allSignals.concat({\n      name,\n      value: selCmpt.project.items.map(proj => {\n        const {\n          signals,\n          hasLegend\n        } = proj,\n              rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n\n        const p = duplicate(rest);\n        p.field = replacePathInField(p.field);\n        return p;\n      })\n    });\n  }\n};\nexport default project;","map":{"version":3,"sources":["../../../../../src/compile/selection/transforms/project.ts"],"names":[],"mappings":"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","sourcesContent":["import {array, isArray} from 'vega-util';\nimport {isSingleDefUnitChannel, ScaleChannel, SingleDefUnitChannel} from '../../../channel';\nimport * as log from '../../../log';\nimport {hasContinuousDomain} from '../../../scale';\nimport {SelectionInit, SelectionInitInterval} from '../../../selection';\nimport {Dict, hash, keys, varName, replacePathInField, duplicate} from '../../../util';\nimport {TimeUnitComponent, TimeUnitNode} from '../../data/timeunit';\nimport {TransformCompiler} from './transforms';\n\nexport const TUPLE_FIELDS = '_tuple_fields';\n\n/**\n * Do the selection tuples hold enumerated or ranged values for a field?\n * Ranged values can be left-right inclusive (R) or left-inclusive, right-exclusive (R-LE).\n */\nexport type TupleStoreType = 'E' | 'R' | 'R-RE';\n\nexport interface SelectionProjection {\n  type: TupleStoreType;\n  field: string;\n  channel?: SingleDefUnitChannel;\n  signals?: {data?: string; visual?: string};\n  hasLegend?: boolean;\n}\n\nexport class SelectionProjectionComponent {\n  public hasChannel: {[key in SingleDefUnitChannel]?: SelectionProjection};\n  public hasField: {[k: string]: SelectionProjection};\n  public timeUnit?: TimeUnitNode;\n  public items: SelectionProjection[];\n\n  constructor(...items: SelectionProjection[]) {\n    this.items = items;\n    this.hasChannel = {};\n    this.hasField = {};\n  }\n}\n\nconst project: TransformCompiler = {\n  has: () => {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n\n  parse: (model, selCmpt, selDef) => {\n    const name = selCmpt.name;\n    const proj = selCmpt.project ?? (selCmpt.project = new SelectionProjectionComponent());\n    const parsed: Dict<SelectionProjection> = {};\n    const timeUnits: Dict<TimeUnitComponent> = {};\n\n    const signals = new Set<string>();\n    const signalName = (p: SelectionProjection, range: 'data' | 'visual') => {\n      const suffix = range === 'visual' ? p.channel : p.field;\n      let sg = varName(`${name}_${suffix}`);\n      for (let counter = 1; signals.has(sg); counter++) {\n        sg = varName(`${name}_${suffix}_${counter}`);\n      }\n      signals.add(sg);\n      return {[range]: sg};\n    };\n\n    // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    // Otherwise, use the default configuration.\n    if (!selDef.fields && !selDef.encodings) {\n      const cfg = model.config.selection[selDef.type];\n\n      if (selDef.init) {\n        for (const init of array(selDef.init)) {\n          for (const key of keys(init)) {\n            if (isSingleDefUnitChannel(key)) {\n              (selDef.encodings || (selDef.encodings = [])).push(key as SingleDefUnitChannel);\n            } else {\n              if (selDef.type === 'interval') {\n                log.warn('Interval selections should be initialized using \"x\" and/or \"y\" keys.');\n                selDef.encodings = cfg.encodings;\n              } else {\n                (selDef.fields || (selDef.fields = [])).push(key);\n              }\n            }\n          }\n        }\n      } else {\n        selDef.encodings = cfg.encodings;\n        selDef.fields = cfg.fields;\n      }\n    }\n\n    // TODO: find a possible channel mapping for these fields.\n    for (const field of selDef.fields ?? []) {\n      const p: SelectionProjection = {type: 'E', field};\n      p.signals = {...signalName(p, 'data')};\n      proj.items.push(p);\n      proj.hasField[field] = p;\n    }\n\n    for (const channel of selDef.encodings ?? []) {\n      const fieldDef = model.fieldDef(channel);\n      if (fieldDef) {\n        let field = fieldDef.field;\n\n        if (fieldDef.aggregate) {\n          log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n          continue;\n        } else if (!field) {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n          continue;\n        }\n\n        if (fieldDef.timeUnit) {\n          field = model.vgField(channel);\n\n          // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n          const component = {\n            as: field,\n            field: fieldDef.field,\n            timeUnit: fieldDef.timeUnit\n          };\n          timeUnits[hash(component)] = component;\n        }\n\n        // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n        if (!parsed[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          let type: TupleStoreType = 'E';\n          if (selCmpt.type === 'interval') {\n            const scaleType = model.getScaleComponent(channel as ScaleChannel).get('type');\n            if (hasContinuousDomain(scaleType)) {\n              type = 'R';\n            }\n          } else if (fieldDef.bin) {\n            type = 'R-RE';\n          }\n\n          const p: SelectionProjection = {field, channel, type};\n          p.signals = {...signalName(p, 'data'), ...signalName(p, 'visual')};\n          proj.items.push((parsed[field] = p));\n          proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n\n    if (selDef.init) {\n      const parseInit = <T extends SelectionInit | SelectionInitInterval>(i: Dict<T>): T[] => {\n        return proj.items.map(p => (i[p.channel] !== undefined ? i[p.channel] : i[p.field]));\n      };\n\n      if (selDef.type === 'interval') {\n        selCmpt.init = parseInit(selDef.init);\n      } else {\n        const init = isArray(selDef.init) ? selDef.init : [selDef.init];\n        selCmpt.init = init.map(parseInit);\n      }\n    }\n\n    if (keys(timeUnits).length > 0) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n\n  signals: (model, selCmpt, allSignals) => {\n    const name = selCmpt.name + TUPLE_FIELDS;\n    const hasSignal = allSignals.filter(s => s.name === name);\n    return hasSignal.length > 0\n      ? allSignals\n      : allSignals.concat({\n          name,\n          value: selCmpt.project.items.map(proj => {\n            const {signals, hasLegend, ...rest} = proj;\n            const p = duplicate(rest);\n            p.field = replacePathInField(p.field);\n            return p;\n          })\n        });\n  }\n};\n\nexport default project;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}