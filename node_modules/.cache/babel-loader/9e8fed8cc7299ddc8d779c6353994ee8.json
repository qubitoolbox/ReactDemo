{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isContinuous, isFieldDef, title } from '../channeldef';\nimport { extractTransformsFromEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { keys, replaceAll, titlecase } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, getCompositeMarkTooltip, makeCompositeAggregatePartFactory } from './common';\nexport const ERRORBAR = 'errorbar';\nconst ERRORBAR_PART_INDEX = {\n  ticks: 1,\n  rule: 1\n};\nexport const ERRORBAR_PARTS = keys(ERRORBAR_PART_INDEX);\nexport const errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);\nexport function normalizeErrorBar(spec, {\n  config\n}) {\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAR, config);\n  const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);\n  const tick = {\n    type: 'tick',\n    orient: ticksOrient\n  };\n  return Object.assign(Object.assign({}, outerSpec), {\n    transform,\n    layer: [...makeErrorBarPart({\n      partName: 'ticks',\n      mark: tick,\n      positionPrefix: 'lower',\n      extraEncoding: tooltipEncoding\n    }), ...makeErrorBarPart({\n      partName: 'ticks',\n      mark: tick,\n      positionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    }), ...makeErrorBarPart({\n      partName: 'rule',\n      mark: 'rule',\n      positionPrefix: 'lower',\n      endPositionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    })]\n  });\n}\n\nfunction errorBarOrientAndInputType(spec, compositeMark) {\n  const {\n    encoding\n  } = spec;\n\n  if (errorBarIsInputTypeRaw(encoding)) {\n    return {\n      orient: compositeMarkOrient(spec, compositeMark),\n      inputType: 'raw'\n    };\n  }\n\n  const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);\n  const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);\n  const x = encoding.x;\n  const y = encoding.y;\n\n  if (isTypeAggregatedUpperLower) {\n    // type is aggregated-upper-lower\n    if (isTypeAggregatedError) {\n      throw new Error(compositeMark + ' cannot be both type aggregated-upper-lower and aggregated-error');\n    }\n\n    const x2 = encoding.x2;\n    const y2 = encoding.y2;\n\n    if (isFieldDef(x2) && isFieldDef(y2)) {\n      // having both x, x2 and y, y2\n      throw new Error(compositeMark + ' cannot have both x2 and y2');\n    } else if (isFieldDef(x2)) {\n      if (isFieldDef(x) && isContinuous(x)) {\n        // having x, x2 quantitative and field y, y2 are not specified\n        return {\n          orient: 'horizontal',\n          inputType: 'aggregated-upper-lower'\n        };\n      } else {\n        // having x, x2 that are not both quantitative\n        throw new Error('Both x and x2 have to be quantitative in ' + compositeMark);\n      }\n    } else if (isFieldDef(y2)) {\n      // y2 is a FieldDef\n      if (isFieldDef(y) && isContinuous(y)) {\n        // having y, y2 quantitative and field x, x2 are not specified\n        return {\n          orient: 'vertical',\n          inputType: 'aggregated-upper-lower'\n        };\n      } else {\n        // having y, y2 that are not both quantitative\n        throw new Error('Both y and y2 have to be quantitative in ' + compositeMark);\n      }\n    }\n\n    throw new Error('No ranged axis');\n  } else {\n    // type is aggregated-error\n    const xError = encoding.xError;\n    const xError2 = encoding.xError2;\n    const yError = encoding.yError;\n    const yError2 = encoding.yError2;\n\n    if (isFieldDef(xError2) && !isFieldDef(xError)) {\n      // having xError2 without xError\n      throw new Error(compositeMark + ' cannot have xError2 without xError');\n    }\n\n    if (isFieldDef(yError2) && !isFieldDef(yError)) {\n      // having yError2 without yError\n      throw new Error(compositeMark + ' cannot have yError2 without yError');\n    }\n\n    if (isFieldDef(xError) && isFieldDef(yError)) {\n      // having both xError and yError\n      throw new Error(compositeMark + ' cannot have both xError and yError with both are quantiative');\n    } else if (isFieldDef(xError)) {\n      if (isFieldDef(x) && isContinuous(x)) {\n        // having x and xError that are all quantitative\n        return {\n          orient: 'horizontal',\n          inputType: 'aggregated-error'\n        };\n      } else {\n        // having x, xError, and xError2 that are not all quantitative\n        throw new Error('All x, xError, and xError2 (if exist) have to be quantitative');\n      }\n    } else if (isFieldDef(yError)) {\n      if (isFieldDef(y) && isContinuous(y)) {\n        // having y and yError that are all quantitative\n        return {\n          orient: 'vertical',\n          inputType: 'aggregated-error'\n        };\n      } else {\n        // having y, yError, and yError2 that are not all quantitative\n        throw new Error('All y, yError, and yError2 (if exist) have to be quantitative');\n      }\n    }\n\n    throw new Error('No ranged axis');\n  }\n}\n\nfunction errorBarIsInputTypeRaw(encoding) {\n  return (isFieldDef(encoding.x) || isFieldDef(encoding.y)) && !isFieldDef(encoding.x2) && !isFieldDef(encoding.y2) && !isFieldDef(encoding.xError) && !isFieldDef(encoding.xError2) && !isFieldDef(encoding.yError) && !isFieldDef(encoding.yError2);\n}\n\nfunction errorBarIsInputTypeAggregatedUpperLower(encoding) {\n  return isFieldDef(encoding.x2) || isFieldDef(encoding.y2);\n}\n\nfunction errorBarIsInputTypeAggregatedError(encoding) {\n  return isFieldDef(encoding.xError) || isFieldDef(encoding.xError2) || isFieldDef(encoding.yError) || isFieldDef(encoding.yError2);\n}\n\nexport function errorBarParams(spec, compositeMark, config) {\n  var _a; // TODO: use selection\n\n\n  const {\n    mark,\n    encoding,\n    selection,\n    projection: _p\n  } = spec,\n        outerSpec = __rest(spec, [\"mark\", \"encoding\", \"selection\", \"projection\"]);\n\n  const markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  }; // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n\n  if (selection) {\n    log.warn(log.message.selectionNotSupported(compositeMark));\n  }\n\n  const {\n    orient,\n    inputType\n  } = errorBarOrientAndInputType(spec, compositeMark);\n  const {\n    continuousAxisChannelDef,\n    continuousAxisChannelDef2,\n    continuousAxisChannelDefError,\n    continuousAxisChannelDefError2,\n    continuousAxis\n  } = compositeMarkContinuousAxis(spec, orient, compositeMark);\n  const {\n    errorBarSpecificAggregate,\n    postAggregateCalculates,\n    tooltipSummary,\n    tooltipTitleWithFieldName\n  } = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);\n\n  const _b = continuousAxis,\n        oldContinuousAxisChannelDef = encoding[_b],\n        _c = continuousAxis === 'x' ? 'x2' : 'y2',\n        oldContinuousAxisChannelDef2 = encoding[_c],\n        _d = continuousAxis === 'x' ? 'xError' : 'yError',\n        oldContinuousAxisChannelDefError = encoding[_d],\n        _e = continuousAxis === 'x' ? 'xError2' : 'yError2',\n        oldContinuousAxisChannelDefError2 = encoding[_e],\n        oldEncodingWithoutContinuousAxis = __rest(encoding, [typeof _b === \"symbol\" ? _b : _b + \"\", typeof _c === \"symbol\" ? _c : _c + \"\", typeof _d === \"symbol\" ? _d : _d + \"\", typeof _e === \"symbol\" ? _e : _e + \"\"]);\n\n  const {\n    bins,\n    timeUnits,\n    aggregate: oldAggregate,\n    groupby: oldGroupBy,\n    encoding: encodingWithoutContinuousAxis\n  } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);\n  const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];\n  const groupby = inputType !== 'raw' ? [] : oldGroupBy;\n  const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);\n  return {\n    transform: [...(_a = outerSpec.transform, _a !== null && _a !== void 0 ? _a : []), ...bins, ...timeUnits, ...(aggregate.length === 0 ? [] : [{\n      aggregate,\n      groupby\n    }]), ...postAggregateCalculates],\n    groupby,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  };\n}\n\nfunction errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {\n  let errorBarSpecificAggregate = [];\n  let postAggregateCalculates = [];\n  const continuousFieldName = continuousAxisChannelDef.field;\n  let tooltipSummary;\n  let tooltipTitleWithFieldName = false;\n\n  if (inputType === 'raw') {\n    const center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === 'iqr' ? 'median' : 'mean' : config.errorbar.center;\n    const extent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n\n    if (center === 'median' !== (extent === 'iqr')) {\n      log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n    }\n\n    if (extent === 'stderr' || extent === 'stdev') {\n      errorBarSpecificAggregate = [{\n        op: extent,\n        field: continuousFieldName,\n        as: 'extent_' + continuousFieldName\n      }, {\n        op: center,\n        field: continuousFieldName,\n        as: 'center_' + continuousFieldName\n      }];\n      postAggregateCalculates = [{\n        calculate: `datum[\"center_${continuousFieldName}\"] + datum[\"extent_${continuousFieldName}\"]`,\n        as: 'upper_' + continuousFieldName\n      }, {\n        calculate: `datum[\"center_${continuousFieldName}\"] - datum[\"extent_${continuousFieldName}\"]`,\n        as: 'lower_' + continuousFieldName\n      }];\n      tooltipSummary = [{\n        fieldPrefix: 'center_',\n        titlePrefix: titlecase(center)\n      }, {\n        fieldPrefix: 'upper_',\n        titlePrefix: getTitlePrefix(center, extent, '+')\n      }, {\n        fieldPrefix: 'lower_',\n        titlePrefix: getTitlePrefix(center, extent, '-')\n      }];\n      tooltipTitleWithFieldName = true;\n    } else {\n      if (markDef.center && markDef.extent) {\n        log.warn(log.message.errorBarCenterIsNotNeeded(markDef.extent, compositeMark));\n      }\n\n      let centerOp;\n      let lowerExtentOp;\n      let upperExtentOp;\n\n      if (extent === 'ci') {\n        centerOp = 'mean';\n        lowerExtentOp = 'ci0';\n        upperExtentOp = 'ci1';\n      } else {\n        centerOp = 'median';\n        lowerExtentOp = 'q1';\n        upperExtentOp = 'q3';\n      }\n\n      errorBarSpecificAggregate = [{\n        op: lowerExtentOp,\n        field: continuousFieldName,\n        as: 'lower_' + continuousFieldName\n      }, {\n        op: upperExtentOp,\n        field: continuousFieldName,\n        as: 'upper_' + continuousFieldName\n      }, {\n        op: centerOp,\n        field: continuousFieldName,\n        as: 'center_' + continuousFieldName\n      }];\n      tooltipSummary = [{\n        fieldPrefix: 'upper_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: upperExtentOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }, {\n        fieldPrefix: 'lower_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: lowerExtentOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }, {\n        fieldPrefix: 'center_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: centerOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }];\n    }\n  } else {\n    if (markDef.center || markDef.extent) {\n      log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n    }\n\n    if (inputType === 'aggregated-upper-lower') {\n      tooltipSummary = [];\n      postAggregateCalculates = [{\n        calculate: `datum[\"${continuousAxisChannelDef2.field}\"]`,\n        as: 'upper_' + continuousFieldName\n      }, {\n        calculate: `datum[\"${continuousFieldName}\"]`,\n        as: 'lower_' + continuousFieldName\n      }];\n    } else if (inputType === 'aggregated-error') {\n      tooltipSummary = [{\n        fieldPrefix: '',\n        titlePrefix: continuousFieldName\n      }];\n      postAggregateCalculates = [{\n        calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError.field}\"]`,\n        as: 'upper_' + continuousFieldName\n      }];\n\n      if (continuousAxisChannelDefError2) {\n        postAggregateCalculates.push({\n          calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError2.field}\"]`,\n          as: 'lower_' + continuousFieldName\n        });\n      } else {\n        postAggregateCalculates.push({\n          calculate: `datum[\"${continuousFieldName}\"] - datum[\"${continuousAxisChannelDefError.field}\"]`,\n          as: 'lower_' + continuousFieldName\n        });\n      }\n    }\n\n    for (const postAggregateCalculate of postAggregateCalculates) {\n      tooltipSummary.push({\n        fieldPrefix: postAggregateCalculate.as.substring(0, 6),\n        titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum[\"', ''), '\"]', '')\n      });\n    }\n  }\n\n  return {\n    postAggregateCalculates,\n    errorBarSpecificAggregate,\n    tooltipSummary,\n    tooltipTitleWithFieldName\n  };\n}\n\nfunction getTitlePrefix(center, extent, operation) {\n  return titlecase(center) + ' ' + operation + ' ' + extent;\n}","map":{"version":3,"sources":["../../../src/compositemark/errorbar.ts"],"names":[],"mappings":"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","sourcesContent":["import {AggregateOp, Orientation, Text} from 'vega';\nimport {PositionChannel} from '../channel';\nimport {Field, isContinuous, isFieldDef, PositionFieldDef, SecondaryFieldDef, title, ValueDef} from '../channeldef';\nimport {Config} from '../config';\nimport {Data} from '../data';\nimport {Encoding, extractTransformsFromEncoding} from '../encoding';\nimport * as log from '../log';\nimport {isMarkDef, MarkDef} from '../mark';\nimport {NormalizerParams} from '../normalize';\nimport {GenericUnitSpec, NormalizedLayerSpec} from '../spec';\nimport {Step} from '../spec/base';\nimport {TitleParams} from '../title';\nimport {AggregatedFieldDef, CalculateTransform, Transform} from '../transform';\nimport {Flag, keys, replaceAll, titlecase} from '../util';\nimport {CompositeMarkNormalizer} from './base';\nimport {\n  compositeMarkContinuousAxis,\n  compositeMarkOrient,\n  CompositeMarkTooltipSummary,\n  GenericCompositeMarkDef,\n  getCompositeMarkTooltip,\n  makeCompositeAggregatePartFactory,\n  PartsMixins\n} from './common';\nimport {ErrorBand, ErrorBandDef} from './errorband';\n\nexport const ERRORBAR: 'errorbar' = 'errorbar';\nexport type ErrorBar = typeof ERRORBAR;\n\nexport type ErrorBarExtent = 'ci' | 'iqr' | 'stderr' | 'stdev';\nexport type ErrorBarCenter = 'mean' | 'median';\n\nexport type ErrorBarPart = 'ticks' | 'rule';\n\nexport type ErrorInputType = 'raw' | 'aggregated-upper-lower' | 'aggregated-error';\n\nconst ERRORBAR_PART_INDEX: Flag<ErrorBarPart> = {\n  ticks: 1,\n  rule: 1\n};\n\nexport interface ErrorExtraEncoding<F extends Field> {\n  /**\n   * Error value of x coordinates for error specified `\"errorbar\"` and `\"errorband\"`.\n   */\n  xError?: SecondaryFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Secondary error value of x coordinates for error specified `\"errorbar\"` and `\"errorband\"`.\n   */\n  // `xError2` cannot have type as it should have the same type as `xError`\n  xError2?: SecondaryFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Error value of y coordinates for error specified `\"errorbar\"` and `\"errorband\"`.\n   */\n  yError?: SecondaryFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Secondary error value of y coordinates for error specified `\"errorbar\"` and `\"errorband\"`.\n   */\n  // `yError2` cannot have type as it should have the same type as `yError`\n  yError2?: SecondaryFieldDef<F> | ValueDef<number>;\n}\n\nexport type ErrorEncoding<F extends Field> = Pick<Encoding<F>, PositionChannel | 'color' | 'detail' | 'opacity'> &\n  ErrorExtraEncoding<F>;\n\nexport const ERRORBAR_PARTS = keys(ERRORBAR_PART_INDEX);\n\nexport type ErrorBarPartsMixins = PartsMixins<ErrorBarPart>;\n\nexport interface ErrorBarConfig extends ErrorBarPartsMixins {\n  /**\n   * The center of the errorbar. Available options include:\n   * - `\"mean\"`: the mean of the data points.\n   * - `\"median\"`: the median of the data points.\n   *\n   * __Default value:__ `\"mean\"`.\n   * @hidden\n   */\n\n  // center is not needed right now but will be added back to the schema if future features require it.\n  center?: ErrorBarCenter;\n\n  /**\n   * The extent of the rule. Available options include:\n   * - `\"ci\"`: Extend the rule to the confidence interval of the mean.\n   * - `\"stderr\"`: The size of rule are set to the value of standard error, extending from the mean.\n   * - `\"stdev\"`: The size of rule are set to the value of standard deviation, extending from the mean.\n   * - `\"iqr\"`: Extend the rule to the q1 and q3.\n   *\n   * __Default value:__ `\"stderr\"`.\n   */\n  extent?: ErrorBarExtent;\n}\n\nexport type ErrorBarDef = GenericCompositeMarkDef<ErrorBar> &\n  ErrorBarConfig & {\n    /**\n     * Orientation of the error bar. This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.\n     */\n    orient?: Orientation;\n  };\n\nexport interface ErrorBarConfigMixins {\n  /**\n   * ErrorBar Config\n   */\n  errorbar?: ErrorBarConfig;\n}\n\nexport const errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);\n\nexport function normalizeErrorBar(\n  spec: GenericUnitSpec<ErrorEncoding<string>, ErrorBar | ErrorBarDef>,\n  {config}: NormalizerParams\n): NormalizedLayerSpec {\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAR, config);\n\n  const makeErrorBarPart = makeCompositeAggregatePartFactory<ErrorBarPartsMixins>(\n    markDef,\n    continuousAxis,\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis,\n    config.errorbar\n  );\n\n  const tick: MarkDef = {type: 'tick', orient: ticksOrient};\n\n  return {\n    ...outerSpec,\n    transform,\n    layer: [\n      ...makeErrorBarPart({\n        partName: 'ticks',\n        mark: tick,\n        positionPrefix: 'lower',\n        extraEncoding: tooltipEncoding\n      }),\n      ...makeErrorBarPart({\n        partName: 'ticks',\n        mark: tick,\n        positionPrefix: 'upper',\n        extraEncoding: tooltipEncoding\n      }),\n      ...makeErrorBarPart({\n        partName: 'rule',\n        mark: 'rule',\n        positionPrefix: 'lower',\n        endPositionPrefix: 'upper',\n        extraEncoding: tooltipEncoding\n      })\n    ]\n  };\n}\n\nfunction errorBarOrientAndInputType(\n  spec: GenericUnitSpec<ErrorEncoding<Field>, ErrorBar | ErrorBand | ErrorBarDef | ErrorBandDef>,\n  compositeMark: ErrorBar | ErrorBand\n): {\n  orient: Orientation;\n  inputType: ErrorInputType;\n} {\n  const {encoding} = spec;\n\n  if (errorBarIsInputTypeRaw(encoding)) {\n    return {\n      orient: compositeMarkOrient(spec, compositeMark),\n      inputType: 'raw'\n    };\n  }\n\n  const isTypeAggregatedUpperLower: boolean = errorBarIsInputTypeAggregatedUpperLower(encoding);\n  const isTypeAggregatedError: boolean = errorBarIsInputTypeAggregatedError(encoding);\n  const x = encoding.x;\n  const y = encoding.y;\n\n  if (isTypeAggregatedUpperLower) {\n    // type is aggregated-upper-lower\n\n    if (isTypeAggregatedError) {\n      throw new Error(compositeMark + ' cannot be both type aggregated-upper-lower and aggregated-error');\n    }\n\n    const x2 = encoding.x2;\n    const y2 = encoding.y2;\n\n    if (isFieldDef(x2) && isFieldDef(y2)) {\n      // having both x, x2 and y, y2\n      throw new Error(compositeMark + ' cannot have both x2 and y2');\n    } else if (isFieldDef(x2)) {\n      if (isFieldDef(x) && isContinuous(x)) {\n        // having x, x2 quantitative and field y, y2 are not specified\n        return {orient: 'horizontal', inputType: 'aggregated-upper-lower'};\n      } else {\n        // having x, x2 that are not both quantitative\n        throw new Error('Both x and x2 have to be quantitative in ' + compositeMark);\n      }\n    } else if (isFieldDef(y2)) {\n      // y2 is a FieldDef\n      if (isFieldDef(y) && isContinuous(y)) {\n        // having y, y2 quantitative and field x, x2 are not specified\n        return {orient: 'vertical', inputType: 'aggregated-upper-lower'};\n      } else {\n        // having y, y2 that are not both quantitative\n        throw new Error('Both y and y2 have to be quantitative in ' + compositeMark);\n      }\n    }\n    throw new Error('No ranged axis');\n  } else {\n    // type is aggregated-error\n\n    const xError = encoding.xError;\n    const xError2 = encoding.xError2;\n    const yError = encoding.yError;\n    const yError2 = encoding.yError2;\n\n    if (isFieldDef(xError2) && !isFieldDef(xError)) {\n      // having xError2 without xError\n      throw new Error(compositeMark + ' cannot have xError2 without xError');\n    }\n\n    if (isFieldDef(yError2) && !isFieldDef(yError)) {\n      // having yError2 without yError\n      throw new Error(compositeMark + ' cannot have yError2 without yError');\n    }\n\n    if (isFieldDef(xError) && isFieldDef(yError)) {\n      // having both xError and yError\n      throw new Error(compositeMark + ' cannot have both xError and yError with both are quantiative');\n    } else if (isFieldDef(xError)) {\n      if (isFieldDef(x) && isContinuous(x)) {\n        // having x and xError that are all quantitative\n        return {orient: 'horizontal', inputType: 'aggregated-error'};\n      } else {\n        // having x, xError, and xError2 that are not all quantitative\n        throw new Error('All x, xError, and xError2 (if exist) have to be quantitative');\n      }\n    } else if (isFieldDef(yError)) {\n      if (isFieldDef(y) && isContinuous(y)) {\n        // having y and yError that are all quantitative\n        return {orient: 'vertical', inputType: 'aggregated-error'};\n      } else {\n        // having y, yError, and yError2 that are not all quantitative\n        throw new Error('All y, yError, and yError2 (if exist) have to be quantitative');\n      }\n    }\n    throw new Error('No ranged axis');\n  }\n}\n\nfunction errorBarIsInputTypeRaw(encoding: ErrorEncoding<Field>): boolean {\n  return (\n    (isFieldDef(encoding.x) || isFieldDef(encoding.y)) &&\n    !isFieldDef(encoding.x2) &&\n    !isFieldDef(encoding.y2) &&\n    !isFieldDef(encoding.xError) &&\n    !isFieldDef(encoding.xError2) &&\n    !isFieldDef(encoding.yError) &&\n    !isFieldDef(encoding.yError2)\n  );\n}\n\nfunction errorBarIsInputTypeAggregatedUpperLower(encoding: ErrorEncoding<Field>): boolean {\n  return isFieldDef(encoding.x2) || isFieldDef(encoding.y2);\n}\n\nfunction errorBarIsInputTypeAggregatedError(encoding: ErrorEncoding<Field>): boolean {\n  return (\n    isFieldDef(encoding.xError) ||\n    isFieldDef(encoding.xError2) ||\n    isFieldDef(encoding.yError) ||\n    isFieldDef(encoding.yError2)\n  );\n}\n\nexport function errorBarParams<\n  M extends ErrorBar | ErrorBand,\n  MD extends GenericCompositeMarkDef<M> & (ErrorBarDef | ErrorBandDef)\n>(\n  spec: GenericUnitSpec<ErrorEncoding<string>, M | MD>,\n  compositeMark: M,\n  config: Config\n): {\n  transform: Transform[];\n  groupby: string[];\n  continuousAxisChannelDef: PositionFieldDef<string>;\n  continuousAxis: 'x' | 'y';\n  encodingWithoutContinuousAxis: ErrorEncoding<string>;\n  ticksOrient: Orientation;\n  markDef: MD;\n  outerSpec: {\n    data?: Data;\n    title?: Text | TitleParams;\n    name?: string;\n    description?: string;\n    transform?: Transform[];\n    width?: number | 'container' | Step;\n    height?: number | 'container' | Step;\n  };\n  tooltipEncoding: ErrorEncoding<string>;\n} {\n  // TODO: use selection\n  const {mark, encoding, selection, projection: _p, ...outerSpec} = spec;\n  const markDef: MD = isMarkDef(mark) ? mark : ({type: mark} as MD);\n\n  // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n  if (selection) {\n    log.warn(log.message.selectionNotSupported(compositeMark));\n  }\n\n  const {orient, inputType} = errorBarOrientAndInputType(spec, compositeMark);\n  const {\n    continuousAxisChannelDef,\n    continuousAxisChannelDef2,\n    continuousAxisChannelDefError,\n    continuousAxisChannelDefError2,\n    continuousAxis\n  } = compositeMarkContinuousAxis(spec, orient, compositeMark);\n\n  const {\n    errorBarSpecificAggregate,\n    postAggregateCalculates,\n    tooltipSummary,\n    tooltipTitleWithFieldName\n  } = errorBarAggregationAndCalculation(\n    markDef,\n    continuousAxisChannelDef,\n    continuousAxisChannelDef2,\n    continuousAxisChannelDefError,\n    continuousAxisChannelDefError2,\n    inputType,\n    compositeMark,\n    config\n  );\n\n  const {\n    [continuousAxis]: oldContinuousAxisChannelDef,\n    [continuousAxis === 'x' ? 'x2' : 'y2']: oldContinuousAxisChannelDef2,\n    [continuousAxis === 'x' ? 'xError' : 'yError']: oldContinuousAxisChannelDefError,\n    [continuousAxis === 'x' ? 'xError2' : 'yError2']: oldContinuousAxisChannelDefError2,\n    ...oldEncodingWithoutContinuousAxis\n  } = encoding;\n\n  const {\n    bins,\n    timeUnits,\n    aggregate: oldAggregate,\n    groupby: oldGroupBy,\n    encoding: encodingWithoutContinuousAxis\n  } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);\n\n  const aggregate: AggregatedFieldDef[] = [...oldAggregate, ...errorBarSpecificAggregate];\n  const groupby: string[] = inputType !== 'raw' ? [] : oldGroupBy;\n\n  const tooltipEncoding: ErrorEncoding<string> = getCompositeMarkTooltip(\n    tooltipSummary,\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis,\n    tooltipTitleWithFieldName\n  );\n\n  return {\n    transform: [\n      ...(outerSpec.transform ?? []),\n      ...bins,\n      ...timeUnits,\n      ...(aggregate.length === 0 ? [] : [{aggregate, groupby}]),\n      ...postAggregateCalculates\n    ],\n    groupby,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  };\n}\n\nfunction errorBarAggregationAndCalculation<\n  M extends ErrorBar | ErrorBand,\n  MD extends GenericCompositeMarkDef<M> & (ErrorBarDef | ErrorBandDef)\n>(\n  markDef: MD,\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  continuousAxisChannelDef2: SecondaryFieldDef<string>,\n  continuousAxisChannelDefError: SecondaryFieldDef<string>,\n  continuousAxisChannelDefError2: SecondaryFieldDef<string>,\n  inputType: ErrorInputType,\n  compositeMark: M,\n  config: Config\n): {\n  postAggregateCalculates: CalculateTransform[];\n  errorBarSpecificAggregate: AggregatedFieldDef[];\n  tooltipSummary: CompositeMarkTooltipSummary[];\n  tooltipTitleWithFieldName: boolean;\n} {\n  let errorBarSpecificAggregate: AggregatedFieldDef[] = [];\n  let postAggregateCalculates: CalculateTransform[] = [];\n  const continuousFieldName: string = continuousAxisChannelDef.field;\n\n  let tooltipSummary: CompositeMarkTooltipSummary[];\n  let tooltipTitleWithFieldName = false;\n\n  if (inputType === 'raw') {\n    const center: ErrorBarCenter = markDef.center\n      ? markDef.center\n      : markDef.extent\n      ? markDef.extent === 'iqr'\n        ? 'median'\n        : 'mean'\n      : config.errorbar.center;\n    const extent: ErrorBarExtent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n\n    if ((center === 'median') !== (extent === 'iqr')) {\n      log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n    }\n\n    if (extent === 'stderr' || extent === 'stdev') {\n      errorBarSpecificAggregate = [\n        {op: extent, field: continuousFieldName, as: 'extent_' + continuousFieldName},\n        {op: center, field: continuousFieldName, as: 'center_' + continuousFieldName}\n      ];\n\n      postAggregateCalculates = [\n        {\n          calculate: `datum[\"center_${continuousFieldName}\"] + datum[\"extent_${continuousFieldName}\"]`,\n          as: 'upper_' + continuousFieldName\n        },\n        {\n          calculate: `datum[\"center_${continuousFieldName}\"] - datum[\"extent_${continuousFieldName}\"]`,\n          as: 'lower_' + continuousFieldName\n        }\n      ];\n\n      tooltipSummary = [\n        {fieldPrefix: 'center_', titlePrefix: titlecase(center)},\n        {fieldPrefix: 'upper_', titlePrefix: getTitlePrefix(center, extent, '+')},\n        {fieldPrefix: 'lower_', titlePrefix: getTitlePrefix(center, extent, '-')}\n      ];\n      tooltipTitleWithFieldName = true;\n    } else {\n      if (markDef.center && markDef.extent) {\n        log.warn(log.message.errorBarCenterIsNotNeeded(markDef.extent, compositeMark));\n      }\n\n      let centerOp: AggregateOp;\n      let lowerExtentOp: AggregateOp;\n      let upperExtentOp: AggregateOp;\n      if (extent === 'ci') {\n        centerOp = 'mean';\n        lowerExtentOp = 'ci0';\n        upperExtentOp = 'ci1';\n      } else {\n        centerOp = 'median';\n        lowerExtentOp = 'q1';\n        upperExtentOp = 'q3';\n      }\n\n      errorBarSpecificAggregate = [\n        {op: lowerExtentOp, field: continuousFieldName, as: 'lower_' + continuousFieldName},\n        {op: upperExtentOp, field: continuousFieldName, as: 'upper_' + continuousFieldName},\n        {op: centerOp, field: continuousFieldName, as: 'center_' + continuousFieldName}\n      ];\n\n      tooltipSummary = [\n        {\n          fieldPrefix: 'upper_',\n          titlePrefix: title({field: continuousFieldName, aggregate: upperExtentOp, type: 'quantitative'}, config, {\n            allowDisabling: false\n          })\n        },\n        {\n          fieldPrefix: 'lower_',\n          titlePrefix: title({field: continuousFieldName, aggregate: lowerExtentOp, type: 'quantitative'}, config, {\n            allowDisabling: false\n          })\n        },\n        {\n          fieldPrefix: 'center_',\n          titlePrefix: title({field: continuousFieldName, aggregate: centerOp, type: 'quantitative'}, config, {\n            allowDisabling: false\n          })\n        }\n      ];\n    }\n  } else {\n    if (markDef.center || markDef.extent) {\n      log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n    }\n\n    if (inputType === 'aggregated-upper-lower') {\n      tooltipSummary = [];\n      postAggregateCalculates = [\n        {calculate: `datum[\"${continuousAxisChannelDef2.field}\"]`, as: 'upper_' + continuousFieldName},\n        {calculate: `datum[\"${continuousFieldName}\"]`, as: 'lower_' + continuousFieldName}\n      ];\n    } else if (inputType === 'aggregated-error') {\n      tooltipSummary = [{fieldPrefix: '', titlePrefix: continuousFieldName}];\n      postAggregateCalculates = [\n        {\n          calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError.field}\"]`,\n          as: 'upper_' + continuousFieldName\n        }\n      ];\n\n      if (continuousAxisChannelDefError2) {\n        postAggregateCalculates.push({\n          calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError2.field}\"]`,\n          as: 'lower_' + continuousFieldName\n        });\n      } else {\n        postAggregateCalculates.push({\n          calculate: `datum[\"${continuousFieldName}\"] - datum[\"${continuousAxisChannelDefError.field}\"]`,\n          as: 'lower_' + continuousFieldName\n        });\n      }\n    }\n\n    for (const postAggregateCalculate of postAggregateCalculates) {\n      tooltipSummary.push({\n        fieldPrefix: postAggregateCalculate.as.substring(0, 6),\n        titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum[\"', ''), '\"]', '')\n      });\n    }\n  }\n  return {postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName};\n}\n\nfunction getTitlePrefix(center: ErrorBarCenter, extent: ErrorBarExtent, operation: '+' | '-'): string {\n  return titlecase(center) + ' ' + operation + ' ' + extent;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}