{"ast":null,"code":"import { MAIN } from '../../data';\nimport { fieldIntersection, hash, hasIntersection, keys, some } from '../../util';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { OutputNode } from './dataflow';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { ParseNode } from './formatparse';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { FACET_SCALE_PREFIX } from './optimize';\nimport { BottomUpOptimizer, isDataSourceNode, TopDownOptimizer } from './optimizer';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\nimport { IdentifierNode } from './identifier';\nimport { requiresSelectionId } from '../selection';\n/**\n * Move parse nodes up to forks.\n */\n\nexport class MoveParseUp extends BottomUpOptimizer {\n  run(node) {\n    const parent = node.parent; // Move parse up by merging or swapping.\n\n    if (node instanceof ParseNode) {\n      if (isDataSourceNode(parent)) {\n        return this.flags;\n      }\n\n      if (parent.numChildren() > 1) {\n        // Don't move parse further up but continue with parent.\n        this.setContinue();\n        return this.flags;\n      }\n\n      if (parent instanceof ParseNode) {\n        this.setMutated();\n        parent.merge(node);\n      } else {\n        // Don't swap with nodes that produce something that the parse node depends on (e.g. lookup).\n        if (fieldIntersection(parent.producedFields(), node.dependentFields())) {\n          this.setContinue();\n          return this.flags;\n        }\n\n        this.setMutated();\n        node.swapWithParent();\n      }\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n\n}\n/**\n * Merge identical nodes at forks by comparing hashes.\n *\n * Does not need to iterate from leaves so we implement this with recursion as it's a bit simpler.\n */\n\nexport class MergeIdenticalNodes extends TopDownOptimizer {\n  mergeNodes(parent, nodes) {\n    const mergedNode = nodes.shift();\n\n    for (const node of nodes) {\n      parent.removeChild(node);\n      node.parent = mergedNode;\n      node.remove();\n    }\n  }\n\n  run(node) {\n    const hashes = node.children.map(x => x.hash());\n    const buckets = {};\n\n    for (let i = 0; i < hashes.length; i++) {\n      if (buckets[hashes[i]] === undefined) {\n        buckets[hashes[i]] = [node.children[i]];\n      } else {\n        buckets[hashes[i]].push(node.children[i]);\n      }\n    }\n\n    for (const k of keys(buckets)) {\n      if (buckets[k].length > 1) {\n        this.setMutated();\n        this.mergeNodes(node, buckets[k]);\n      }\n    }\n\n    for (const child of node.children) {\n      this.run(child);\n    }\n\n    return this.mutatedFlag;\n  }\n\n}\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\n\nexport class RemoveUnusedSubtrees extends BottomUpOptimizer {\n  run(node) {\n    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n      // no need to continue with parent because it is output node or will have children (there was a fork)\n      return this.flags;\n    } else {\n      this.setMutated();\n      node.remove();\n    }\n\n    return this.flags;\n  }\n\n}\n/**\n * Removes duplicate time unit nodes (as determined by the name of the\n * output field) that may be generated due to selections projected over\n * time units.\n *\n * TODO: Try to make this a top down optimizer that keeps only the first\n * insance of a time unit node.\n * TODO: Try to make a generic version of this that only keeps one node per hash.\n */\n\nexport class RemoveDuplicateTimeUnits extends BottomUpOptimizer {\n  constructor() {\n    super(...arguments);\n    this.fields = new Set();\n    this.prev = null;\n  }\n\n  run(node) {\n    this.setContinue();\n\n    if (node instanceof TimeUnitNode) {\n      const pfields = node.producedFields();\n\n      if (hasIntersection(pfields, this.fields)) {\n        this.setMutated();\n        this.prev.remove();\n      } else {\n        this.fields = new Set([...this.fields, ...pfields]);\n      }\n\n      this.prev = node;\n    }\n\n    return this.flags;\n  }\n\n  reset() {\n    this.fields.clear();\n  }\n\n}\n/**\n * Merge adjacent time unit nodes.\n */\n\nexport class MergeTimeUnits extends BottomUpOptimizer {\n  run(node) {\n    this.setContinue();\n    const parent = node.parent;\n    const timeUnitChildren = parent.children.filter(x => x instanceof TimeUnitNode);\n    const combination = timeUnitChildren.pop();\n\n    for (const timeUnit of timeUnitChildren) {\n      this.setMutated();\n      combination.merge(timeUnit);\n    }\n\n    return this.flags;\n  }\n\n}\n/**\n * Clones the subtree and ignores output nodes except for the leaves, which are renamed.\n */\n\nfunction cloneSubtree(facet) {\n  function clone(node) {\n    if (!(node instanceof FacetNode)) {\n      const copy = node.clone();\n\n      if (copy instanceof OutputNode) {\n        const newName = FACET_SCALE_PREFIX + copy.getSource();\n        copy.setSource(newName);\n        facet.model.component.data.outputNodes[newName] = copy;\n      } else if (copy instanceof AggregateNode || copy instanceof StackNode || copy instanceof WindowTransformNode || copy instanceof JoinAggregateTransformNode) {\n        copy.addDimensions(facet.fields);\n      }\n\n      node.children.flatMap(clone).forEach(n => n.parent = copy);\n      return [copy];\n    }\n\n    return node.children.flatMap(clone);\n  }\n\n  return clone;\n}\n/**\n * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.\n * After moving down the facet node, make a copy of the subtree and make it a child of the main output.\n */\n\n\nexport function moveFacetDown(node) {\n  if (node instanceof FacetNode) {\n    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {\n      // move down until we hit a fork or output node\n      const child = node.children[0];\n\n      if (child instanceof AggregateNode || child instanceof StackNode || child instanceof WindowTransformNode || child instanceof JoinAggregateTransformNode) {\n        child.addDimensions(node.fields);\n      }\n\n      child.swapWithParent();\n      moveFacetDown(node);\n    } else {\n      // move main to facet\n      const facetMain = node.model.component.data.main;\n      moveMainDownToFacet(facetMain); // replicate the subtree and place it before the facet's main node\n\n      const cloner = cloneSubtree(node);\n      const copy = node.children.map(cloner).flat();\n\n      for (const c of copy) {\n        c.parent = facetMain;\n      }\n    }\n  } else {\n    node.children.map(moveFacetDown);\n  }\n}\n\nfunction moveMainDownToFacet(node) {\n  if (node instanceof OutputNode && node.type === MAIN) {\n    if (node.numChildren() === 1) {\n      const child = node.children[0];\n\n      if (!(child instanceof FacetNode)) {\n        child.swapWithParent();\n        moveMainDownToFacet(node);\n      }\n    }\n  }\n}\n/**\n * Remove output nodes that are not required. Starting from a root.\n */\n\n\nexport class RemoveUnnecessaryOutputNodes extends TopDownOptimizer {\n  constructor() {\n    super();\n  }\n\n  run(node) {\n    if (node instanceof OutputNode && !node.isRequired()) {\n      this.setMutated();\n      node.remove();\n    }\n\n    for (const child of node.children) {\n      this.run(child);\n    }\n\n    return this.mutatedFlag;\n  }\n\n}\nexport class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer {\n  constructor(model) {\n    super();\n    this.requiresSelectionId = model && requiresSelectionId(model);\n  }\n\n  run(node) {\n    if (node instanceof IdentifierNode) {\n      // Only preserve IdentifierNodes if we have default discrete selections\n      // in our model tree, and if the nodes come after tuple producing nodes.\n      if (!(this.requiresSelectionId && (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode))) {\n        this.setMutated();\n        node.remove();\n      }\n    }\n\n    for (const child of node.children) {\n      this.run(child);\n    }\n\n    return this.mutatedFlag;\n  }\n\n}\n/**\n * Inserts an intermediate ParseNode containing all non-conflicting parse fields and removes the empty ParseNodes.\n *\n * We assume that dependent paths that do not have a parse node can be just merged.\n */\n\nexport class MergeParse extends BottomUpOptimizer {\n  run(node) {\n    const parent = node.parent;\n    const originalChildren = [...parent.children];\n    const parseChildren = parent.children.filter(child => child instanceof ParseNode);\n\n    if (parent.numChildren() > 1 && parseChildren.length >= 1) {\n      const commonParse = {};\n      const conflictingParse = new Set();\n\n      for (const parseNode of parseChildren) {\n        const parse = parseNode.parse;\n\n        for (const k of keys(parse)) {\n          if (!(k in commonParse)) {\n            commonParse[k] = parse[k];\n          } else if (commonParse[k] !== parse[k]) {\n            conflictingParse.add(k);\n          }\n        }\n      }\n\n      for (const field of conflictingParse) {\n        delete commonParse[field];\n      }\n\n      if (keys(commonParse).length !== 0) {\n        this.setMutated();\n        const mergedParseNode = new ParseNode(parent, commonParse);\n\n        for (const childNode of originalChildren) {\n          if (childNode instanceof ParseNode) {\n            for (const key of keys(commonParse)) {\n              delete childNode.parse[key];\n            }\n          }\n\n          parent.removeChild(childNode);\n          childNode.parent = mergedParseNode; // remove empty parse nodes\n\n          if (childNode instanceof ParseNode && keys(childNode.parse).length === 0) {\n            childNode.remove();\n          }\n        }\n      }\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n\n}\nexport class MergeAggregates extends BottomUpOptimizer {\n  run(node) {\n    const parent = node.parent;\n    const aggChildren = parent.children.filter(child => child instanceof AggregateNode); // Object which we'll use to map the fields which an aggregate is grouped by to\n    // the set of aggregates with that grouping. This is useful as only aggregates\n    // with the same group by can be merged\n\n    const groupedAggregates = {}; // Build groupedAggregates\n\n    for (const agg of aggChildren) {\n      const groupBys = hash(agg.groupBy);\n\n      if (!(groupBys in groupedAggregates)) {\n        groupedAggregates[groupBys] = [];\n      }\n\n      groupedAggregates[groupBys].push(agg);\n    } // Merge aggregateNodes with same key in groupedAggregates\n\n\n    for (const group of keys(groupedAggregates)) {\n      const mergeableAggs = groupedAggregates[group];\n\n      if (mergeableAggs.length > 1) {\n        const mergedAggs = mergeableAggs.pop();\n\n        for (const agg of mergeableAggs) {\n          if (mergedAggs.merge(agg)) {\n            parent.removeChild(agg);\n            agg.parent = mergedAggs;\n            agg.remove();\n            this.setMutated();\n          }\n        }\n      }\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n\n}\n/**\n * Merge bin nodes and move them up through forks. Stop at filters, parse, identifier as we want them to stay before the bin node.\n */\n\nexport class MergeBins extends BottomUpOptimizer {\n  constructor(model) {\n    super();\n    this.model = model;\n  }\n\n  run(node) {\n    const parent = node.parent;\n    const moveBinsUp = !(isDataSourceNode(parent) || parent instanceof FilterNode || parent instanceof ParseNode || parent instanceof IdentifierNode);\n    const promotableBins = [];\n    const remainingBins = [];\n\n    for (const child of parent.children) {\n      if (child instanceof BinNode) {\n        if (moveBinsUp && !fieldIntersection(parent.producedFields(), child.dependentFields())) {\n          promotableBins.push(child);\n        } else {\n          remainingBins.push(child);\n        }\n      }\n    }\n\n    if (promotableBins.length > 0) {\n      const promotedBin = promotableBins.pop();\n\n      for (const bin of promotableBins) {\n        promotedBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n\n      this.setMutated();\n\n      if (parent instanceof BinNode) {\n        parent.merge(promotedBin, this.model.renameSignal.bind(this.model));\n      } else {\n        promotedBin.swapWithParent();\n      }\n    }\n\n    if (remainingBins.length > 1) {\n      const remainingBin = remainingBins.pop();\n\n      for (const bin of remainingBins) {\n        remainingBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n\n      this.setMutated();\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n\n}\n/**\n * This optimizer takes output nodes that are at a fork and moves them before the fork.\n *\n * The algorithm iterates over the children and tries to find the last output node in a cahin of output nodes.\n * It then moves all output nodes before that main output node. All other children (and the children of the output nodes)\n * are inserted after the main output node.\n */\n\nexport class MergeOutputs extends BottomUpOptimizer {\n  run(node) {\n    const parent = node.parent;\n    const children = [...parent.children];\n    const hasOutputChild = some(children, child => child instanceof OutputNode);\n\n    if (!hasOutputChild || parent.numChildren() <= 1) {\n      this.setContinue();\n      return this.flags;\n    }\n\n    const otherChildren = []; // The output node we will connect all other nodes to\n    // output nodes will be added before, other nodes after\n\n    let mainOutput;\n\n    for (const child of children) {\n      if (child instanceof OutputNode) {\n        let lastOutput = child;\n\n        while (lastOutput.numChildren() === 1) {\n          const theChild = lastOutput.children[0];\n\n          if (theChild instanceof OutputNode) {\n            lastOutput = theChild;\n          } else {\n            break;\n          }\n        }\n\n        otherChildren.push(...lastOutput.children);\n\n        if (mainOutput) {\n          // Move the output nodes before the mainOutput. We do this by setting\n          // the parent of the first not to the parent of the main output and\n          // the main output's parent to the last output.\n          // note: the child is the first output\n          parent.removeChild(child);\n          child.parent = mainOutput.parent;\n          mainOutput.parent.removeChild(mainOutput);\n          mainOutput.parent = lastOutput;\n          this.setMutated();\n        } else {\n          mainOutput = lastOutput;\n        }\n      } else {\n        otherChildren.push(child);\n      }\n    }\n\n    if (otherChildren.length) {\n      this.setMutated();\n\n      for (const child of otherChildren) {\n        child.parent.removeChild(child);\n        child.parent = mainOutput;\n      }\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/optimizers.ts"],"names":[],"mappings":"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","sourcesContent":["import {MAIN, Parse} from '../../data';\nimport {Dict, fieldIntersection, hash, hasIntersection, keys, some} from '../../util';\nimport {Model} from '../model';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {ParseNode} from './formatparse';\nimport {JoinAggregateTransformNode} from './joinaggregate';\nimport {FACET_SCALE_PREFIX} from './optimize';\nimport {BottomUpOptimizer, isDataSourceNode, TopDownOptimizer} from './optimizer';\nimport * as optimizers from './optimizers';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\nimport {IdentifierNode} from './identifier';\nimport {requiresSelectionId} from '../selection';\n\nexport interface OptimizerFlags {\n  /**\n   * If true, iteration continues.\n   */\n  continueFlag: boolean;\n  /**\n   * If true, the tree has been mutated by the function.\n   */\n  mutatedFlag: boolean;\n}\n\n/**\n * Move parse nodes up to forks.\n */\nexport class MoveParseUp extends BottomUpOptimizer {\n  public run(node: DataFlowNode): OptimizerFlags {\n    const parent = node.parent;\n    // Move parse up by merging or swapping.\n    if (node instanceof ParseNode) {\n      if (isDataSourceNode(parent)) {\n        return this.flags;\n      }\n\n      if (parent.numChildren() > 1) {\n        // Don't move parse further up but continue with parent.\n        this.setContinue();\n        return this.flags;\n      }\n\n      if (parent instanceof ParseNode) {\n        this.setMutated();\n        parent.merge(node);\n      } else {\n        // Don't swap with nodes that produce something that the parse node depends on (e.g. lookup).\n        if (fieldIntersection(parent.producedFields(), node.dependentFields())) {\n          this.setContinue();\n          return this.flags;\n        }\n        this.setMutated();\n        node.swapWithParent();\n      }\n    }\n    this.setContinue();\n    return this.flags;\n  }\n}\n\n/**\n * Merge identical nodes at forks by comparing hashes.\n *\n * Does not need to iterate from leaves so we implement this with recursion as it's a bit simpler.\n */\nexport class MergeIdenticalNodes extends TopDownOptimizer {\n  public mergeNodes(parent: DataFlowNode, nodes: DataFlowNode[]) {\n    const mergedNode = nodes.shift();\n    for (const node of nodes) {\n      parent.removeChild(node);\n      node.parent = mergedNode;\n      node.remove();\n    }\n  }\n\n  public run(node: DataFlowNode): boolean {\n    const hashes = node.children.map(x => x.hash());\n    const buckets: {hash?: DataFlowNode[]} = {};\n\n    for (let i = 0; i < hashes.length; i++) {\n      if (buckets[hashes[i]] === undefined) {\n        buckets[hashes[i]] = [node.children[i]];\n      } else {\n        buckets[hashes[i]].push(node.children[i]);\n      }\n    }\n\n    for (const k of keys(buckets)) {\n      if (buckets[k].length > 1) {\n        this.setMutated();\n        this.mergeNodes(node, buckets[k]);\n      }\n    }\n    for (const child of node.children) {\n      this.run(child);\n    }\n    return this.mutatedFlag;\n  }\n}\n\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nexport class RemoveUnusedSubtrees extends BottomUpOptimizer {\n  public run(node: DataFlowNode): OptimizerFlags {\n    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n      // no need to continue with parent because it is output node or will have children (there was a fork)\n      return this.flags;\n    } else {\n      this.setMutated();\n      node.remove();\n    }\n    return this.flags;\n  }\n}\n\n/**\n * Removes duplicate time unit nodes (as determined by the name of the\n * output field) that may be generated due to selections projected over\n * time units.\n *\n * TODO: Try to make this a top down optimizer that keeps only the first\n * insance of a time unit node.\n * TODO: Try to make a generic version of this that only keeps one node per hash.\n */\nexport class RemoveDuplicateTimeUnits extends BottomUpOptimizer {\n  private fields = new Set<string>();\n  private prev: DataFlowNode = null;\n  public run(node: DataFlowNode): OptimizerFlags {\n    this.setContinue();\n    if (node instanceof TimeUnitNode) {\n      const pfields = node.producedFields();\n      if (hasIntersection(pfields, this.fields)) {\n        this.setMutated();\n        this.prev.remove();\n      } else {\n        this.fields = new Set([...this.fields, ...pfields]);\n      }\n      this.prev = node;\n    }\n    return this.flags;\n  }\n\n  public reset(): void {\n    this.fields.clear();\n  }\n}\n\n/**\n * Merge adjacent time unit nodes.\n */\nexport class MergeTimeUnits extends BottomUpOptimizer {\n  public run(node: DataFlowNode): OptimizerFlags {\n    this.setContinue();\n    const parent = node.parent;\n    const timeUnitChildren = parent.children.filter(x => x instanceof TimeUnitNode) as TimeUnitNode[];\n    const combination = timeUnitChildren.pop();\n    for (const timeUnit of timeUnitChildren) {\n      this.setMutated();\n      combination.merge(timeUnit);\n    }\n    return this.flags;\n  }\n}\n\n/**\n * Clones the subtree and ignores output nodes except for the leaves, which are renamed.\n */\nfunction cloneSubtree(facet: FacetNode) {\n  function clone(node: DataFlowNode): DataFlowNode[] {\n    if (!(node instanceof FacetNode)) {\n      const copy = node.clone();\n\n      if (copy instanceof OutputNode) {\n        const newName = FACET_SCALE_PREFIX + copy.getSource();\n        copy.setSource(newName);\n\n        facet.model.component.data.outputNodes[newName] = copy;\n      } else if (\n        copy instanceof AggregateNode ||\n        copy instanceof StackNode ||\n        copy instanceof WindowTransformNode ||\n        copy instanceof JoinAggregateTransformNode\n      ) {\n        copy.addDimensions(facet.fields);\n      }\n      node.children.flatMap(clone).forEach((n: DataFlowNode) => (n.parent = copy));\n\n      return [copy];\n    }\n\n    return node.children.flatMap(clone);\n  }\n  return clone;\n}\n\n/**\n * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.\n * After moving down the facet node, make a copy of the subtree and make it a child of the main output.\n */\nexport function moveFacetDown(node: DataFlowNode) {\n  if (node instanceof FacetNode) {\n    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {\n      // move down until we hit a fork or output node\n      const child = node.children[0];\n\n      if (\n        child instanceof AggregateNode ||\n        child instanceof StackNode ||\n        child instanceof WindowTransformNode ||\n        child instanceof JoinAggregateTransformNode\n      ) {\n        child.addDimensions(node.fields);\n      }\n\n      child.swapWithParent();\n      moveFacetDown(node);\n    } else {\n      // move main to facet\n\n      const facetMain = node.model.component.data.main;\n      moveMainDownToFacet(facetMain);\n\n      // replicate the subtree and place it before the facet's main node\n      const cloner = cloneSubtree(node);\n      const copy: DataFlowNode[] = node.children.map(cloner).flat();\n      for (const c of copy) {\n        c.parent = facetMain;\n      }\n    }\n  } else {\n    node.children.map(moveFacetDown);\n  }\n}\n\nfunction moveMainDownToFacet(node: DataFlowNode) {\n  if (node instanceof OutputNode && node.type === MAIN) {\n    if (node.numChildren() === 1) {\n      const child = node.children[0];\n      if (!(child instanceof FacetNode)) {\n        child.swapWithParent();\n        moveMainDownToFacet(node);\n      }\n    }\n  }\n}\n\n/**\n * Remove output nodes that are not required. Starting from a root.\n */\nexport class RemoveUnnecessaryOutputNodes extends TopDownOptimizer {\n  constructor() {\n    super();\n  }\n\n  public run(node: DataFlowNode): boolean {\n    if (node instanceof OutputNode && !node.isRequired()) {\n      this.setMutated();\n      node.remove();\n    }\n\n    for (const child of node.children) {\n      this.run(child);\n    }\n\n    return this.mutatedFlag;\n  }\n}\n\nexport class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer {\n  private requiresSelectionId: boolean;\n  constructor(model: Model) {\n    super();\n    this.requiresSelectionId = model && requiresSelectionId(model);\n  }\n\n  public run(node: DataFlowNode): boolean {\n    if (node instanceof IdentifierNode) {\n      // Only preserve IdentifierNodes if we have default discrete selections\n      // in our model tree, and if the nodes come after tuple producing nodes.\n      if (\n        !(\n          this.requiresSelectionId &&\n          (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode)\n        )\n      ) {\n        this.setMutated();\n        node.remove();\n      }\n    }\n\n    for (const child of node.children) {\n      this.run(child);\n    }\n\n    return this.mutatedFlag;\n  }\n}\n\n/**\n * Inserts an intermediate ParseNode containing all non-conflicting parse fields and removes the empty ParseNodes.\n *\n * We assume that dependent paths that do not have a parse node can be just merged.\n */\nexport class MergeParse extends BottomUpOptimizer {\n  public run(node: DataFlowNode): optimizers.OptimizerFlags {\n    const parent = node.parent;\n    const originalChildren = [...parent.children];\n    const parseChildren = parent.children.filter((child): child is ParseNode => child instanceof ParseNode);\n\n    if (parent.numChildren() > 1 && parseChildren.length >= 1) {\n      const commonParse: Parse = {};\n      const conflictingParse = new Set<string>();\n      for (const parseNode of parseChildren) {\n        const parse = parseNode.parse;\n        for (const k of keys(parse)) {\n          if (!(k in commonParse)) {\n            commonParse[k] = parse[k];\n          } else if (commonParse[k] !== parse[k]) {\n            conflictingParse.add(k);\n          }\n        }\n      }\n\n      for (const field of conflictingParse) {\n        delete commonParse[field];\n      }\n\n      if (keys(commonParse).length !== 0) {\n        this.setMutated();\n        const mergedParseNode = new ParseNode(parent, commonParse);\n        for (const childNode of originalChildren) {\n          if (childNode instanceof ParseNode) {\n            for (const key of keys(commonParse)) {\n              delete childNode.parse[key];\n            }\n          }\n\n          parent.removeChild(childNode);\n          childNode.parent = mergedParseNode;\n\n          // remove empty parse nodes\n          if (childNode instanceof ParseNode && keys(childNode.parse).length === 0) {\n            childNode.remove();\n          }\n        }\n      }\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n}\n\nexport class MergeAggregates extends BottomUpOptimizer {\n  public run(node: DataFlowNode): optimizers.OptimizerFlags {\n    const parent = node.parent;\n    const aggChildren = parent.children.filter((child): child is AggregateNode => child instanceof AggregateNode);\n\n    // Object which we'll use to map the fields which an aggregate is grouped by to\n    // the set of aggregates with that grouping. This is useful as only aggregates\n    // with the same group by can be merged\n    const groupedAggregates: Dict<AggregateNode[]> = {};\n\n    // Build groupedAggregates\n    for (const agg of aggChildren) {\n      const groupBys = hash(agg.groupBy);\n      if (!(groupBys in groupedAggregates)) {\n        groupedAggregates[groupBys] = [];\n      }\n      groupedAggregates[groupBys].push(agg);\n    }\n\n    // Merge aggregateNodes with same key in groupedAggregates\n    for (const group of keys(groupedAggregates)) {\n      const mergeableAggs = groupedAggregates[group];\n      if (mergeableAggs.length > 1) {\n        const mergedAggs = mergeableAggs.pop();\n        for (const agg of mergeableAggs) {\n          if (mergedAggs.merge(agg)) {\n            parent.removeChild(agg);\n            agg.parent = mergedAggs;\n            agg.remove();\n\n            this.setMutated();\n          }\n        }\n      }\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n}\n\n/**\n * Merge bin nodes and move them up through forks. Stop at filters, parse, identifier as we want them to stay before the bin node.\n */\nexport class MergeBins extends BottomUpOptimizer {\n  constructor(private model: Model) {\n    super();\n  }\n  public run(node: DataFlowNode): OptimizerFlags {\n    const parent = node.parent;\n    const moveBinsUp = !(\n      isDataSourceNode(parent) ||\n      parent instanceof FilterNode ||\n      parent instanceof ParseNode ||\n      parent instanceof IdentifierNode\n    );\n\n    const promotableBins: BinNode[] = [];\n    const remainingBins: BinNode[] = [];\n\n    for (const child of parent.children) {\n      if (child instanceof BinNode) {\n        if (moveBinsUp && !fieldIntersection(parent.producedFields(), child.dependentFields())) {\n          promotableBins.push(child);\n        } else {\n          remainingBins.push(child);\n        }\n      }\n    }\n\n    if (promotableBins.length > 0) {\n      const promotedBin = promotableBins.pop();\n      for (const bin of promotableBins) {\n        promotedBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n      this.setMutated();\n      if (parent instanceof BinNode) {\n        parent.merge(promotedBin, this.model.renameSignal.bind(this.model));\n      } else {\n        promotedBin.swapWithParent();\n      }\n    }\n    if (remainingBins.length > 1) {\n      const remainingBin = remainingBins.pop();\n      for (const bin of remainingBins) {\n        remainingBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n      this.setMutated();\n    }\n    this.setContinue();\n    return this.flags;\n  }\n}\n\n/**\n * This optimizer takes output nodes that are at a fork and moves them before the fork.\n *\n * The algorithm iterates over the children and tries to find the last output node in a cahin of output nodes.\n * It then moves all output nodes before that main output node. All other children (and the children of the output nodes)\n * are inserted after the main output node.\n */\nexport class MergeOutputs extends BottomUpOptimizer {\n  public run(node: DataFlowNode) {\n    const parent = node.parent;\n    const children = [...parent.children];\n    const hasOutputChild = some(children, child => child instanceof OutputNode);\n\n    if (!hasOutputChild || parent.numChildren() <= 1) {\n      this.setContinue();\n      return this.flags;\n    }\n\n    const otherChildren: DataFlowNode[] = [];\n\n    // The output node we will connect all other nodes to\n    // output nodes will be added before, other nodes after\n    let mainOutput: OutputNode;\n\n    for (const child of children) {\n      if (child instanceof OutputNode) {\n        let lastOutput = child;\n\n        while (lastOutput.numChildren() === 1) {\n          const theChild = lastOutput.children[0];\n          if (theChild instanceof OutputNode) {\n            lastOutput = theChild;\n          } else {\n            break;\n          }\n        }\n\n        otherChildren.push(...lastOutput.children);\n\n        if (mainOutput) {\n          // Move the output nodes before the mainOutput. We do this by setting\n          // the parent of the first not to the parent of the main output and\n          // the main output's parent to the last output.\n\n          // note: the child is the first output\n          parent.removeChild(child);\n          child.parent = mainOutput.parent;\n\n          mainOutput.parent.removeChild(mainOutput);\n          mainOutput.parent = lastOutput;\n\n          this.setMutated();\n        } else {\n          mainOutput = lastOutput;\n        }\n      } else {\n        otherChildren.push(child);\n      }\n    }\n\n    if (otherChildren.length) {\n      this.setMutated();\n      for (const child of otherChildren) {\n        child.parent.removeChild(child);\n        child.parent = mainOutput;\n      }\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}