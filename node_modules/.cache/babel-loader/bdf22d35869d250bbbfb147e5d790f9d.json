{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst d3_format_1 = require(\"d3-format\");\n\nconst vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nconst dom_1 = require(\"../util/dom\");\n\nconst math_1 = require(\"../util/math\");\n\nconst table_1 = require(\"./table\");\n\nconst defaultOpts = {\n  maxBins: 12,\n  fontSize: 11\n};\n/**\n * Renders a histogram of values\n *\n * ```js\n * const data = Array(100).fill(0)\n *   .map(x => Math.random() * 100 - (Math.random() * 50))\n *\n * // Push some special values for the stats table.\n * data.push(Infinity);\n * data.push(NaN);\n * data.push(0);\n *\n * const surface = { name: 'Histogram', tab: 'Charts' };\n * tfvis.render.histogram(surface, data);\n * ```\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\nfunction histogram(container, data, opts = {}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const values = prepareData(data);\n    const options = Object.assign({}, defaultOpts, opts);\n    const embedOpts = {\n      actions: false,\n      mode: 'vega-lite',\n      defaultStyle: false\n    };\n    const histogramContainer = dom_1.subSurface(container, 'histogram');\n\n    if (opts.stats !== false) {\n      const statsContainer = dom_1.subSurface(container, 'stats', {\n        prepend: true\n      });\n      let stats;\n\n      if (opts.stats) {\n        stats = opts.stats;\n      } else {\n        stats = math_1.arrayStats(values.map(x => x.value));\n      }\n\n      renderStats(stats, statsContainer, {\n        fontSize: options.fontSize\n      });\n    } // Now that we have rendered stats we need to remove any NaNs and Infinities\n    // before rendering the histogram\n\n\n    const filtered = [];\n\n    for (let i = 0; i < values.length; i++) {\n      const val = values[i].value;\n\n      if (val != null && isFinite(val)) {\n        filtered.push(values[i]);\n      }\n    }\n\n    const histogramSpec = {\n      'width': options.width || dom_1.getDefaultWidth(histogramContainer),\n      'height': options.height || dom_1.getDefaultHeight(histogramContainer),\n      'padding': 0,\n      'autosize': {\n        'type': 'fit',\n        'contains': 'padding',\n        'resize': true\n      },\n      'data': {\n        'values': filtered\n      },\n      'mark': {\n        'type': 'bar',\n        'tooltip': true\n      },\n      'config': {\n        'axis': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        },\n        'text': {\n          'fontSize': options.fontSize\n        },\n        'legend': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        }\n      },\n      'encoding': {\n        'x': {\n          'bin': {\n            'maxbins': options.maxBins\n          },\n          'field': 'value',\n          'type': 'quantitative'\n        },\n        'y': {\n          'aggregate': 'count',\n          'type': 'quantitative'\n        },\n        'color': {\n          'value': options.color || '#001B44'\n        }\n      }\n    };\n    return vega_embed_1.default(histogramContainer, histogramSpec, embedOpts);\n  });\n}\n\nexports.histogram = histogram;\n\nfunction renderStats(stats, container, opts) {\n  const format = d3_format_1.format(',.4~f');\n  const pctFormat = d3_format_1.format('.4~p');\n  const headers = [];\n  const vals = [];\n\n  if (stats.numVals != null) {\n    headers.push('Num Vals');\n    vals.push(format(stats.numVals));\n  }\n\n  if (stats.min != null) {\n    headers.push('Min');\n    vals.push(format(stats.min));\n  }\n\n  if (stats.max != null) {\n    headers.push('Max');\n    vals.push(format(stats.max));\n  }\n\n  if (stats.numZeros != null) {\n    headers.push('# Zeros');\n    let zeroPct = '';\n\n    if (stats.numVals) {\n      zeroPct = stats.numZeros > 0 ? `(${pctFormat(stats.numZeros / stats.numVals)})` : '';\n    }\n\n    vals.push(`${format(stats.numZeros)} ${zeroPct}`);\n  }\n\n  if (stats.numNans != null) {\n    headers.push('# NaNs');\n    let nanPct = '';\n\n    if (stats.numVals) {\n      nanPct = stats.numNans > 0 ? `(${pctFormat(stats.numNans / stats.numVals)})` : '';\n    }\n\n    vals.push(`${format(stats.numNans)} ${nanPct}`);\n  }\n\n  if (stats.numInfs != null) {\n    headers.push('# Infinity');\n    let infPct = '';\n\n    if (stats.numVals) {\n      infPct = stats.numInfs > 0 ? `(${pctFormat(stats.numInfs / stats.numVals)})` : '';\n    }\n\n    vals.push(`${format(stats.numInfs)} ${infPct}`);\n  }\n\n  table_1.table(container, {\n    headers,\n    values: [vals]\n  }, opts);\n}\n/**\n * Formats data to the internal format used by this chart.\n */\n\n\nfunction prepareData(data) {\n  if (data.length == null) {\n    throw new Error('input data must be an array');\n  }\n\n  if (data.length === 0) {\n    return [];\n  } else if (typeof data[0] === 'object') {\n    if (data[0].value == null) {\n      throw new Error('input data must have a value field');\n    } else {\n      return data;\n    }\n  } else {\n    const ret = Array(data.length);\n\n    for (let i = 0; i < data.length; i++) {\n      ret[i] = {\n        value: data[i]\n      };\n    }\n\n    return ret;\n  }\n}","map":{"version":3,"sources":["../../src/render/histogram.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {format as d3Format} from 'd3-format';\nimport embed, {Mode, VisualizationSpec} from 'vega-embed';\n\nimport {Drawable, HistogramOpts, HistogramStats, TypedArray} from '../types';\nimport {getDefaultHeight, getDefaultWidth, subSurface} from '../util/dom';\nimport {arrayStats} from '../util/math';\n\nimport {table} from './table';\n\nconst defaultOpts = {\n  maxBins: 12,\n  fontSize: 11,\n};\n\n/**\n * Renders a histogram of values\n *\n * ```js\n * const data = Array(100).fill(0)\n *   .map(x => Math.random() * 100 - (Math.random() * 50))\n *\n * // Push some special values for the stats table.\n * data.push(Infinity);\n * data.push(NaN);\n * data.push(0);\n *\n * const surface = { name: 'Histogram', tab: 'Charts' };\n * tfvis.render.histogram(surface, data);\n * ```\n */\n/** @doc {heading: 'Charts', namespace: 'render'} */\nexport async function histogram(\n    container: Drawable, data: Array<{value: number}>|number[]|TypedArray,\n    opts: HistogramOpts = {}) {\n  const values = prepareData(data);\n\n  const options = Object.assign({}, defaultOpts, opts);\n\n  const embedOpts = {\n    actions: false,\n    mode: 'vega-lite' as Mode,\n    defaultStyle: false,\n  };\n\n  const histogramContainer = subSurface(container, 'histogram');\n  if (opts.stats !== false) {\n    const statsContainer = subSurface(container, 'stats', {\n      prepend: true,\n    });\n    let stats: HistogramStats;\n\n    if (opts.stats) {\n      stats = opts.stats;\n    } else {\n      stats = arrayStats(values.map(x => x.value));\n    }\n    renderStats(stats, statsContainer, {fontSize: options.fontSize});\n  }\n\n  // Now that we have rendered stats we need to remove any NaNs and Infinities\n  // before rendering the histogram\n  const filtered = [];\n  for (let i = 0; i < values.length; i++) {\n    const val = values[i].value;\n    if (val != null && isFinite(val)) {\n      filtered.push(values[i]);\n    }\n  }\n\n  const histogramSpec: VisualizationSpec = {\n\n    'width': options.width || getDefaultWidth(histogramContainer),\n    'height': options.height || getDefaultHeight(histogramContainer),\n    'padding': 0,\n    'autosize': {\n      'type': 'fit',\n      'contains': 'padding',\n      'resize': true,\n    },\n    'data': {'values': filtered},\n    'mark': {\n      'type': 'bar',\n      'tooltip': true,\n    },\n    'config': {\n      'axis': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      },\n      'text': {'fontSize': options.fontSize},\n      'legend': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      }\n    },\n    'encoding': {\n      'x': {\n        'bin': {'maxbins': options.maxBins},\n        'field': 'value',\n        'type': 'quantitative',\n      },\n      'y': {\n        'aggregate': 'count',\n        'type': 'quantitative',\n      },\n      'color': {\n        'value': options.color || '#001B44',\n      }\n    }\n  };\n\n  return embed(histogramContainer, histogramSpec, embedOpts);\n}\n\nfunction renderStats(\n    stats: HistogramStats, container: HTMLElement, opts: {fontSize: number}) {\n  const format = d3Format(',.4~f');\n  const pctFormat = d3Format('.4~p');\n\n  const headers: string[] = [];\n  const vals: string[] = [];\n\n  if (stats.numVals != null) {\n    headers.push('Num Vals');\n    vals.push(format(stats.numVals));\n  }\n\n  if (stats.min != null) {\n    headers.push('Min');\n    vals.push(format(stats.min));\n  }\n\n  if (stats.max != null) {\n    headers.push('Max');\n    vals.push(format(stats.max));\n  }\n\n  if (stats.numZeros != null) {\n    headers.push('# Zeros');\n    let zeroPct = '';\n    if (stats.numVals) {\n      zeroPct = stats.numZeros > 0 ?\n          `(${pctFormat(stats.numZeros / stats.numVals)})` :\n          '';\n    }\n\n    vals.push(`${format(stats.numZeros)} ${zeroPct}`);\n  }\n\n  if (stats.numNans != null) {\n    headers.push('# NaNs');\n    let nanPct = '';\n    if (stats.numVals) {\n      nanPct = stats.numNans > 0 ?\n          `(${pctFormat(stats.numNans / stats.numVals)})` :\n          '';\n    }\n\n    vals.push(`${format(stats.numNans)} ${nanPct}`);\n  }\n\n  if (stats.numInfs != null) {\n    headers.push('# Infinity');\n    let infPct = '';\n    if (stats.numVals) {\n      infPct = stats.numInfs > 0 ?\n          `(${pctFormat(stats.numInfs / stats.numVals)})` :\n          '';\n    }\n\n    vals.push(`${format(stats.numInfs)} ${infPct}`);\n  }\n\n  table(container, {headers, values: [vals]}, opts);\n}\n\n/**\n * Formats data to the internal format used by this chart.\n */\nfunction prepareData(data: Array<{value: number}>|number[]|\n                     TypedArray): Array<{value: number}> {\n  if (data.length == null) {\n    throw new Error('input data must be an array');\n  }\n\n  if (data.length === 0) {\n    return [];\n  } else if (typeof data[0] === 'object') {\n    if ((data[0] as {value: number}).value == null) {\n      throw new Error('input data must have a value field');\n    } else {\n      return data as Array<{value: number}>;\n    }\n  } else {\n    const ret = Array(data.length);\n    for (let i = 0; i < data.length; i++) {\n      ret[i] = {value: data[i]};\n    }\n    return ret;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}