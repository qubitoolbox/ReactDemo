{"ast":null,"code":"import * as log from '../../log';\nimport { checkLinks } from './debug';\nimport { BottomUpOptimizer } from './optimizer';\nimport * as optimizers from './optimizers';\nexport const FACET_SCALE_PREFIX = 'scale_';\nexport const MAX_OPTIMIZATION_RUNS = 5;\n/**\n * Return all leaf nodes.\n */\n\nfunction getLeaves(roots) {\n  const leaves = [];\n\n  function append(node) {\n    if (node.numChildren() === 0) {\n      leaves.push(node);\n    } else {\n      node.children.forEach(append);\n    }\n  }\n\n  roots.forEach(append);\n  return leaves;\n}\n\nexport function isTrue(x) {\n  return x;\n}\n/**\n * Run the specified optimizer on the provided nodes.\n *\n * @param optimizer The optimizer instance to run.\n * @param nodes A set of nodes to optimize.\n * @param flag Flag that will be or'ed with return valued from optimization calls to the nodes.\n */\n\nfunction runOptimizer(optimizer, nodes) {\n  const flags = nodes.map(node => {\n    if (optimizer instanceof BottomUpOptimizer) {\n      const runFlags = optimizer.optimizeNextFromLeaves(node);\n      optimizer.reset();\n      return runFlags;\n    } else {\n      return optimizer.run(node);\n    }\n  });\n  return flags.some(isTrue);\n}\n\nfunction optimizationDataflowHelper(dataComponent, model) {\n  let roots = dataComponent.sources;\n  const mutatedFlags = new Set();\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveUnnecessaryOutputNodes(), roots));\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveUnnecessaryIdentifierNodes(model), roots)); // remove source nodes that don't have any children because they also don't have output nodes\n\n  roots = roots.filter(r => r.numChildren() > 0);\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveUnusedSubtrees(), getLeaves(roots)));\n  roots = roots.filter(r => r.numChildren() > 0);\n  mutatedFlags.add(runOptimizer(new optimizers.MoveParseUp(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeBins(model), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveDuplicateTimeUnits(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeParse(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeAggregates(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeTimeUnits(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeIdenticalNodes(), roots));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeOutputs(), getLeaves(roots)));\n  dataComponent.sources = roots;\n  return mutatedFlags.has(true);\n}\n/**\n * Optimizes the dataflow of the passed in data component.\n */\n\n\nexport function optimizeDataflow(data, model) {\n  // check before optimizations\n  checkLinks(data.sources);\n  let firstPassCounter = 0;\n  let secondPassCounter = 0;\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model)) {\n      break;\n    }\n\n    firstPassCounter++;\n  } // move facets down and make a copy of the subtree so that we can have scales at the top level\n\n\n  data.sources.map(optimizers.moveFacetDown);\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model)) {\n      break;\n    }\n\n    secondPassCounter++;\n  } // check after optimizations\n\n\n  checkLinks(data.sources);\n\n  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {\n    log.warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/data/optimize.ts"],"names":[],"mappings":"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","sourcesContent":["import * as log from '../../log';\nimport {Model} from '../model';\nimport {DataFlowNode} from './dataflow';\nimport {checkLinks} from './debug';\nimport {DataComponent} from '.';\nimport {BottomUpOptimizer, TopDownOptimizer} from './optimizer';\nimport * as optimizers from './optimizers';\n\nexport const FACET_SCALE_PREFIX = 'scale_';\nexport const MAX_OPTIMIZATION_RUNS = 5;\n\n/**\n * Return all leaf nodes.\n */\nfunction getLeaves(roots: DataFlowNode[]) {\n  const leaves: DataFlowNode[] = [];\n  function append(node: DataFlowNode) {\n    if (node.numChildren() === 0) {\n      leaves.push(node);\n    } else {\n      node.children.forEach(append);\n    }\n  }\n\n  roots.forEach(append);\n  return leaves;\n}\n\nexport function isTrue(x: boolean) {\n  return x;\n}\n\n/**\n * Run the specified optimizer on the provided nodes.\n *\n * @param optimizer The optimizer instance to run.\n * @param nodes A set of nodes to optimize.\n * @param flag Flag that will be or'ed with return valued from optimization calls to the nodes.\n */\nfunction runOptimizer(optimizer: BottomUpOptimizer | TopDownOptimizer, nodes: DataFlowNode[]): boolean {\n  const flags = nodes.map(node => {\n    if (optimizer instanceof BottomUpOptimizer) {\n      const runFlags = optimizer.optimizeNextFromLeaves(node);\n      optimizer.reset();\n      return runFlags;\n    } else {\n      return optimizer.run(node);\n    }\n  });\n  return flags.some(isTrue);\n}\n\nfunction optimizationDataflowHelper(dataComponent: DataComponent, model: Model) {\n  let roots = dataComponent.sources;\n  const mutatedFlags: Set<boolean> = new Set();\n\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveUnnecessaryOutputNodes(), roots));\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveUnnecessaryIdentifierNodes(model), roots));\n\n  // remove source nodes that don't have any children because they also don't have output nodes\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveUnusedSubtrees(), getLeaves(roots)));\n\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  mutatedFlags.add(runOptimizer(new optimizers.MoveParseUp(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeBins(model), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveDuplicateTimeUnits(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeParse(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeAggregates(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeTimeUnits(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeIdenticalNodes(), roots));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeOutputs(), getLeaves(roots)));\n\n  dataComponent.sources = roots;\n\n  return mutatedFlags.has(true);\n}\n\n/**\n * Optimizes the dataflow of the passed in data component.\n */\nexport function optimizeDataflow(data: DataComponent, model: Model) {\n  // check before optimizations\n  checkLinks(data.sources);\n\n  let firstPassCounter = 0;\n  let secondPassCounter = 0;\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model)) {\n      break;\n    }\n    firstPassCounter++;\n  }\n\n  // move facets down and make a copy of the subtree so that we can have scales at the top level\n  data.sources.map(optimizers.moveFacetDown);\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model)) {\n      break;\n    }\n    secondPassCounter++;\n  }\n\n  // check after optimizations\n  checkLinks(data.sources);\n\n  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {\n    log.warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}