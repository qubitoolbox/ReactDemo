{"ast":null,"code":"import { isString } from 'vega-util';\nimport { initConfig } from '../config';\nimport * as log from '../log';\nimport { isLayerSpec, isUnitSpec } from '../spec';\nimport { deepEqual } from '../util';\nimport { CoreNormalizer } from './core';\nexport function normalize(spec, config) {\n  if (config === undefined) {\n    config = initConfig(spec.config);\n  }\n\n  const normalizedSpec = normalizeGenericSpec(spec, config);\n  const {\n    width,\n    height\n  } = spec;\n  const autosize = normalizeAutoSize(normalizedSpec, {\n    width,\n    height,\n    autosize: spec.autosize\n  }, config);\n  return Object.assign(Object.assign({}, normalizedSpec), autosize ? {\n    autosize\n  } : {});\n}\nconst normalizer = new CoreNormalizer();\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n */\n\nfunction normalizeGenericSpec(spec, config = {}) {\n  return normalizer.map(spec, {\n    config\n  });\n}\n\nfunction _normalizeAutoSize(autosize) {\n  return isString(autosize) ? {\n    type: autosize\n  } : autosize !== null && autosize !== void 0 ? autosize : {};\n}\n/**\n * Normalize autosize and deal with width or height == \"container\".\n */\n\n\nexport function normalizeAutoSize(spec, sizeInfo, config) {\n  let {\n    width,\n    height\n  } = sizeInfo;\n  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);\n  const autosizeDefault = {};\n\n  if (!isFitCompatible) {\n    // If spec is not compatible with autosize == \"fit\", discard width/height == container\n    if (width == 'container') {\n      log.warn(log.message.containerSizeNonSingle('width'));\n      width = undefined;\n    }\n\n    if (height == 'container') {\n      log.warn(log.message.containerSizeNonSingle('height'));\n      height = undefined;\n    }\n  } else {\n    // Default autosize parameters to fit when width/height is \"container\"\n    if (width == 'container' && height == 'container') {\n      autosizeDefault.type = 'fit';\n      autosizeDefault.contains = 'padding';\n    } else if (width == 'container') {\n      autosizeDefault.type = 'fit-x';\n      autosizeDefault.contains = 'padding';\n    } else if (height == 'container') {\n      autosizeDefault.type = 'fit-y';\n      autosizeDefault.contains = 'padding';\n    }\n  }\n\n  const autosize = Object.assign(Object.assign(Object.assign({\n    type: 'pad'\n  }, autosizeDefault), config ? _normalizeAutoSize(config.autosize) : {}), _normalizeAutoSize(spec.autosize));\n\n  if (autosize.type === 'fit' && !isFitCompatible) {\n    log.warn(log.message.FIT_NON_SINGLE);\n    autosize.type = 'pad';\n  }\n\n  if (width == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-x')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('width'));\n  }\n\n  if (height == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-y')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('height'));\n  } // Delete autosize property if it's Vega's default\n\n\n  if (deepEqual(autosize, {\n    type: 'pad'\n  })) {\n    return undefined;\n  }\n\n  return autosize;\n}","map":{"version":3,"sources":["../../../src/normalize/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {isString} from 'vega-util';\nimport {Config, initConfig} from '../config';\nimport * as log from '../log';\nimport {\n  ExtendedLayerSpec,\n  FacetedUnitSpec,\n  GenericSpec,\n  isLayerSpec,\n  isUnitSpec,\n  LayoutSizeMixins,\n  NormalizedSpec,\n  TopLevelSpec,\n  UnitSpec\n} from '../spec';\nimport {AutoSizeParams, AutosizeType, TopLevel} from '../spec/toplevel';\nimport {deepEqual} from '../util';\nimport {NormalizerParams} from './base';\nimport {CoreNormalizer} from './core';\n\nexport function normalize(\n  spec: TopLevelSpec & LayoutSizeMixins,\n  config?: Config\n): TopLevel<NormalizedSpec> & LayoutSizeMixins {\n  if (config === undefined) {\n    config = initConfig(spec.config);\n  }\n\n  const normalizedSpec = normalizeGenericSpec(spec, config);\n\n  const {width, height} = spec;\n  const autosize = normalizeAutoSize(normalizedSpec, {width, height, autosize: spec.autosize}, config);\n\n  return {\n    ...normalizedSpec,\n    ...(autosize ? {autosize} : {})\n  };\n}\n\nconst normalizer = new CoreNormalizer();\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n */\nfunction normalizeGenericSpec(spec: GenericSpec<UnitSpec, ExtendedLayerSpec> | FacetedUnitSpec, config: Config = {}) {\n  return normalizer.map(spec, {config});\n}\n\nfunction _normalizeAutoSize(autosize: AutosizeType | AutoSizeParams) {\n  return isString(autosize) ? {type: autosize} : autosize ?? {};\n}\n\n/**\n * Normalize autosize and deal with width or height == \"container\".\n */\nexport function normalizeAutoSize(\n  spec: TopLevel<NormalizedSpec>,\n  sizeInfo: {autosize: AutosizeType | AutoSizeParams} & LayoutSizeMixins,\n  config?: Config\n) {\n  let {width, height} = sizeInfo;\n\n  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);\n  const autosizeDefault: AutoSizeParams = {};\n\n  if (!isFitCompatible) {\n    // If spec is not compatible with autosize == \"fit\", discard width/height == container\n    if (width == 'container') {\n      log.warn(log.message.containerSizeNonSingle('width'));\n      width = undefined;\n    }\n    if (height == 'container') {\n      log.warn(log.message.containerSizeNonSingle('height'));\n      height = undefined;\n    }\n  } else {\n    // Default autosize parameters to fit when width/height is \"container\"\n    if (width == 'container' && height == 'container') {\n      autosizeDefault.type = 'fit';\n      autosizeDefault.contains = 'padding';\n    } else if (width == 'container') {\n      autosizeDefault.type = 'fit-x';\n      autosizeDefault.contains = 'padding';\n    } else if (height == 'container') {\n      autosizeDefault.type = 'fit-y';\n      autosizeDefault.contains = 'padding';\n    }\n  }\n\n  const autosize: AutoSizeParams = {\n    type: 'pad',\n    ...autosizeDefault,\n    ...(config ? _normalizeAutoSize(config.autosize) : {}),\n    ..._normalizeAutoSize(spec.autosize)\n  };\n\n  if (autosize.type === 'fit' && !isFitCompatible) {\n    log.warn(log.message.FIT_NON_SINGLE);\n    autosize.type = 'pad';\n  }\n\n  if (width == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-x')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('width'));\n  }\n  if (height == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-y')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('height'));\n  }\n\n  // Delete autosize property if it's Vega's default\n  if (deepEqual(autosize, {type: 'pad'})) {\n    return undefined;\n  }\n\n  return autosize;\n}\n\nexport {NormalizerParams};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}