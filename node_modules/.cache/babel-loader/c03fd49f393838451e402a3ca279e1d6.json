{"ast":null,"code":"import { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getTypedFieldDef, hasConditionalFieldDef, isFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { normalizeEncoding } from '../encoding';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { stack } from '../stack';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { normalizeMarkDef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { replaceRepeaterInEncoding } from './repeater';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\n\nexport class UnitModel extends ModelWithField {\n  constructor(spec, parent, parentGivenName, parentGivenSize = {}, repeater, config) {\n    var _a;\n\n    super(spec, 'unit', parent, parentGivenName, config, repeater, undefined, spec.view);\n    this.specifiedScales = {};\n    this.specifiedAxes = {};\n    this.specifiedLegends = {};\n    this.specifiedProjection = {};\n    this.selection = {};\n    this.children = [];\n    const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n    const encodingWithRepeaterReplaced = replaceRepeaterInEncoding((_a = spec.encoding, _a !== null && _a !== void 0 ? _a : {}), repeater);\n    this.markDef = normalizeMarkDef(spec.mark, encodingWithRepeaterReplaced, config, {\n      graticule: spec.data && isGraticuleGenerator(spec.data)\n    });\n    const encoding = this.encoding = normalizeEncoding(encodingWithRepeaterReplaced, this.markDef);\n    this.size = initLayoutSize({\n      encoding,\n      size: Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {\n        width: spec.width\n      } : {}), spec.height ? {\n        height: spec.height\n      } : {})\n    }); // calculate stack properties\n\n    this.stack = stack(mark, encoding);\n    this.specifiedScales = this.initScales(mark, encoding);\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegend(encoding);\n    this.specifiedProjection = spec.projection; // Selections will be initialized upon parse.\n\n    this.selection = spec.selection;\n  }\n\n  get hasProjection() {\n    const {\n      encoding\n    } = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n  /**\n   * Return specified Vega-Lite scale domain for a particular channel\n   * @param channel\n   */\n\n\n  scaleDomain(channel) {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n\n  axis(channel) {\n    return this.specifiedAxes[channel];\n  }\n\n  legend(channel) {\n    return this.specifiedLegends[channel];\n  }\n\n  initScales(mark, encoding) {\n    return SCALE_CHANNELS.reduce((scales, channel) => {\n      let fieldDef;\n      let specifiedScale;\n      const channelDef = encoding[channel];\n\n      if (isFieldDef(channelDef)) {\n        fieldDef = channelDef;\n        specifiedScale = channelDef.scale;\n      } else if (hasConditionalFieldDef(channelDef)) {\n        // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n        fieldDef = channelDef.condition;\n        specifiedScale = channelDef.condition['scale'];\n      }\n\n      if (fieldDef) {\n        scales[channel] = specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : {};\n      }\n\n      return scales;\n    }, {});\n  }\n\n  initAxes(encoding) {\n    return [X, Y].reduce((_axis, channel) => {\n      // Position Axis\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n\n      if (isFieldDef(channelDef) || channel === X && isFieldDef(encoding.x2) || channel === Y && isFieldDef(encoding.y2)) {\n        const axisSpec = isFieldDef(channelDef) ? channelDef.axis : null;\n\n        if (axisSpec !== null) {\n          _axis[channel] = Object.assign({}, axisSpec);\n        }\n      }\n\n      return _axis;\n    }, {});\n  }\n\n  initLegend(encoding) {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const channelDef = encoding[channel];\n\n      if (channelDef) {\n        const legend = isFieldDef(channelDef) ? channelDef.legend : hasConditionalFieldDef(channelDef) // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n        ? channelDef.condition['legend'] : null;\n\n        if (legend !== null && legend !== false && supportLegend(channel)) {\n          _legend[channel] = Object.assign({}, legend);\n        }\n      }\n\n      return _legend;\n    }, {});\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n  }\n\n  parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n\n  parseSelections() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  parseMarkGroup() {\n    this.component.mark = parseMarkGroups(this);\n  }\n\n  parseAxesAndHeaders() {\n    this.component.axes = parseUnitAxes(this);\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  assembleSignals() {\n    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n  }\n\n  assembleSelectionData(data) {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  assembleLayout() {\n    return null;\n  }\n\n  assembleLayoutSignals() {\n    return assembleLayoutSignals(this);\n  }\n\n  assembleMarks() {\n    var _a;\n\n    let marks = (_a = this.component.mark, _a !== null && _a !== void 0 ? _a : []); // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n\n  getMapping() {\n    return this.encoding;\n  }\n\n  get mark() {\n    return this.markDef.type;\n  }\n\n  channelHasField(channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  fieldDef(channel) {\n    const channelDef = this.encoding[channel];\n    return getTypedFieldDef(channelDef);\n  }\n\n}","map":{"version":3,"sources":["../../../src/compile/unit.ts"],"names":[],"mappings":"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","sourcesContent":["import {NewSignal} from 'vega';\nimport {Axis} from '../axis';\nimport {\n  Channel,\n  GEOPOSITION_CHANNELS,\n  NONPOSITION_SCALE_CHANNELS,\n  ScaleChannel,\n  SCALE_CHANNELS,\n  SingleDefChannel,\n  supportLegend,\n  X,\n  Y\n} from '../channel';\nimport {getTypedFieldDef, hasConditionalFieldDef, isFieldDef, TypedFieldDef} from '../channeldef';\nimport {Config} from '../config';\nimport {isGraticuleGenerator} from '../data';\nimport * as vlEncoding from '../encoding';\nimport {Encoding, normalizeEncoding} from '../encoding';\nimport {Legend} from '../legend';\nimport {GEOSHAPE, isMarkDef, Mark, MarkDef} from '../mark';\nimport {Projection} from '../projection';\nimport {Domain, Scale} from '../scale';\nimport {SelectionDef} from '../selection';\nimport {LayoutSizeMixins, NormalizedUnitSpec} from '../spec';\nimport {stack, StackProperties} from '../stack';\nimport {Dict} from '../util';\nimport {VgData, VgLayout} from '../vega.schema';\nimport {assembleAxisSignals} from './axis/assemble';\nimport {AxisIndex} from './axis/component';\nimport {parseUnitAxes} from './axis/parse';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {initLayoutSize} from './layoutsize/init';\nimport {parseUnitLayoutSize} from './layoutsize/parse';\nimport {LegendIndex} from './legend/component';\nimport {normalizeMarkDef} from './mark/init';\nimport {parseMarkGroups} from './mark/mark';\nimport {isLayerModel, Model, ModelWithField} from './model';\nimport {RepeaterValue, replaceRepeaterInEncoding} from './repeater';\nimport {ScaleIndex} from './scale/component';\nimport {\n  assembleTopLevelSignals,\n  assembleUnitSelectionData,\n  assembleUnitSelectionMarks,\n  assembleUnitSelectionSignals\n} from './selection/assemble';\nimport {parseUnitSelection} from './selection/parse';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n  public readonly markDef: MarkDef;\n  public readonly encoding: Encoding<string>;\n\n  public readonly specifiedScales: ScaleIndex = {};\n\n  public readonly stack: StackProperties;\n\n  protected specifiedAxes: AxisIndex = {};\n\n  protected specifiedLegends: LegendIndex = {};\n\n  public specifiedProjection: Projection = {};\n\n  public readonly selection: Dict<SelectionDef> = {};\n  public children: Model[] = [];\n\n  constructor(\n    spec: NormalizedUnitSpec,\n    parent: Model,\n    parentGivenName: string,\n    parentGivenSize: LayoutSizeMixins = {},\n    repeater: RepeaterValue,\n    config: Config\n  ) {\n    super(spec, 'unit', parent, parentGivenName, config, repeater, undefined, spec.view);\n\n    const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n\n    const encodingWithRepeaterReplaced = replaceRepeaterInEncoding(spec.encoding ?? {}, repeater);\n\n    this.markDef = normalizeMarkDef(spec.mark, encodingWithRepeaterReplaced, config, {\n      graticule: spec.data && isGraticuleGenerator(spec.data)\n    });\n    const encoding = (this.encoding = normalizeEncoding(encodingWithRepeaterReplaced, this.markDef));\n\n    this.size = initLayoutSize({\n      encoding,\n      size: {\n        ...parentGivenSize,\n        ...(spec.width ? {width: spec.width} : {}),\n        ...(spec.height ? {height: spec.height} : {})\n      }\n    });\n\n    // calculate stack properties\n    this.stack = stack(mark, encoding);\n    this.specifiedScales = this.initScales(mark, encoding);\n\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegend(encoding);\n    this.specifiedProjection = spec.projection;\n\n    // Selections will be initialized upon parse.\n    this.selection = spec.selection;\n  }\n\n  public get hasProjection(): boolean {\n    const {encoding} = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n\n  /**\n   * Return specified Vega-Lite scale domain for a particular channel\n   * @param channel\n   */\n  public scaleDomain(channel: ScaleChannel): Domain {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n\n  public axis(channel: Channel): Axis {\n    return this.specifiedAxes[channel];\n  }\n\n  public legend(channel: Channel): Legend {\n    return this.specifiedLegends[channel];\n  }\n\n  private initScales(mark: Mark, encoding: Encoding<string>): ScaleIndex {\n    return SCALE_CHANNELS.reduce((scales, channel) => {\n      let fieldDef: TypedFieldDef<string>;\n      let specifiedScale: Scale;\n\n      const channelDef = encoding[channel];\n\n      if (isFieldDef(channelDef)) {\n        fieldDef = channelDef;\n        specifiedScale = channelDef.scale;\n      } else if (hasConditionalFieldDef<string, any>(channelDef)) {\n        // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n        fieldDef = channelDef.condition;\n        specifiedScale = channelDef.condition['scale'];\n      }\n\n      if (fieldDef) {\n        scales[channel] = specifiedScale ?? {};\n      }\n      return scales;\n    }, {} as ScaleIndex);\n  }\n\n  private initAxes(encoding: Encoding<string>): AxisIndex {\n    return [X, Y].reduce((_axis, channel) => {\n      // Position Axis\n\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n      if (\n        isFieldDef(channelDef) ||\n        (channel === X && isFieldDef(encoding.x2)) ||\n        (channel === Y && isFieldDef(encoding.y2))\n      ) {\n        const axisSpec = isFieldDef(channelDef) ? channelDef.axis : null;\n\n        if (axisSpec !== null) {\n          _axis[channel] = {\n            ...axisSpec\n          };\n        }\n      }\n      return _axis;\n    }, {});\n  }\n\n  private initLegend(encoding: Encoding<string>): LegendIndex {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const channelDef = encoding[channel];\n      if (channelDef) {\n        const legend = isFieldDef(channelDef)\n          ? channelDef.legend\n          : hasConditionalFieldDef<string, any>(channelDef) // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n          ? channelDef.condition['legend']\n          : null;\n\n        if (legend !== null && legend !== false && supportLegend(channel)) {\n          _legend[channel] = {...legend};\n        }\n      }\n\n      return _legend;\n    }, {});\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n  }\n\n  public parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n\n  public parseSelections() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  public parseMarkGroup() {\n    this.component.mark = parseMarkGroups(this);\n  }\n\n  public parseAxesAndHeaders() {\n    this.component.axes = parseUnitAxes(this);\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): NewSignal[] {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  public assembleSignals(): NewSignal[] {\n    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n  }\n\n  public assembleSelectionData(data: readonly VgData[]): VgData[] {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  public assembleLayout(): VgLayout {\n    return null;\n  }\n\n  public assembleLayoutSignals(): NewSignal[] {\n    return assembleLayoutSignals(this);\n  }\n\n  public assembleMarks() {\n    let marks = this.component.mark ?? [];\n\n    // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n\n  protected getMapping() {\n    return this.encoding;\n  }\n\n  public get mark(): Mark {\n    return this.markDef.type;\n  }\n\n  public channelHasField(channel: Channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  public fieldDef(channel: SingleDefChannel) {\n    const channelDef = this.encoding[channel];\n    return getTypedFieldDef<string>(channelDef);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}