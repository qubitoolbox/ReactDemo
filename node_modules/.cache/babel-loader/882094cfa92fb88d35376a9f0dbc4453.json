{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tf = __importStar(require(\"@tensorflow/tfjs\"));\n\nconst vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nconst dom_1 = require(\"../util/dom\");\n\nconst utils_1 = require(\"../util/utils\");\n\nconst render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a heatmap.\n *\n * ```js\n * const cols = 50;\n * const rows = 20;\n * const values = [];\n * for (let i = 0; i < cols; i++) {\n *   const col = []\n *   for (let j = 0; j < rows; j++) {\n *     col.push(i * j)\n *   }\n *   values.push(col);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Heatmap', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n * ```js\n * const data = {\n *   values: [[4, 2, 8, 20], [1, 7, 2, 10], [3, 3, 20, 13]],\n *   xTickLabels: ['cheese', 'pig', 'font'],\n *   yTickLabels: ['speed', 'smoothness', 'dexterity', 'mana'],\n * }\n *\n * // Render to visor\n * const surface = { name: 'Heatmap w Custom Labels', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\n\nfunction heatmap(container, data, opts = {}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const options = Object.assign({}, defaultOpts, opts);\n    const drawArea = render_utils_1.getDrawArea(container);\n    let inputValues = data.values;\n\n    if (options.rowMajor) {\n      inputValues = yield convertToRowMajor(data.values);\n    } // Data validation\n\n\n    const {\n      xTickLabels,\n      yTickLabels\n    } = data;\n\n    if (xTickLabels != null) {\n      const dimension = 0;\n      assertLabelsMatchShape(inputValues, xTickLabels, dimension);\n    } // Note that we will only do a check on the first element of the second\n    // dimension. We do not protect users against passing in a ragged array.\n\n\n    if (yTickLabels != null) {\n      const dimension = 1;\n      assertLabelsMatchShape(inputValues, yTickLabels, dimension);\n    } //\n    // Format data for vega spec; an array of objects, one for for each cell\n    // in the matrix.\n    //\n    // If custom labels are passed in for xTickLabels or yTickLabels we need\n    // to make sure they are 'unique' before mapping them to visual properties.\n    // We therefore append the index of the label to the datum that will be used\n    // for that label in the x or y axis. We could do this in all cases but choose\n    // not to to avoid unnecessary string operations.\n    //\n    // We use IDX_SEPARATOR to demarcate the added index\n\n\n    const IDX_SEPARATOR = '@tfidx@';\n    const values = [];\n\n    if (inputValues instanceof tf.Tensor) {\n      utils_1.assert(inputValues.rank === 2, 'Input to renderHeatmap must be a 2d array or Tensor2d'); // This is a slightly specialized version of TensorBuffer.get, inlining it\n      // avoids the overhead of a function call per data element access and is\n      // specialized to only deal with the 2d case.\n\n      const inputArray = yield inputValues.data();\n      const [numRows, numCols] = inputValues.shape;\n\n      for (let row = 0; row < numRows; row++) {\n        const x = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;\n\n        for (let col = 0; col < numCols; col++) {\n          const y = yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;\n          const index = row * numCols + col;\n          const value = inputArray[index];\n          values.push({\n            x,\n            y,\n            value\n          });\n        }\n      }\n    } else {\n      const inputArray = inputValues;\n\n      for (let row = 0; row < inputArray.length; row++) {\n        const x = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;\n\n        for (let col = 0; col < inputArray[row].length; col++) {\n          const y = yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;\n          const value = inputArray[row][col];\n          values.push({\n            x,\n            y,\n            value\n          });\n        }\n      }\n    }\n\n    const embedOpts = {\n      actions: false,\n      mode: 'vega-lite',\n      defaultStyle: false\n    };\n    const spec = {\n      'width': options.width || dom_1.getDefaultWidth(drawArea),\n      'height': options.height || dom_1.getDefaultHeight(drawArea),\n      'padding': 0,\n      'autosize': {\n        'type': 'fit',\n        'contains': 'padding',\n        'resize': true\n      },\n      'config': {\n        'axis': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        },\n        'text': {\n          'fontSize': options.fontSize\n        },\n        'legend': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        },\n        'scale': {\n          'bandPaddingInner': 0,\n          'bandPaddingOuter': 0\n        }\n      },\n      'data': {\n        'values': values\n      },\n      'mark': {\n        'type': 'rect',\n        'tooltip': true\n      },\n      'encoding': {\n        'x': {\n          'field': 'x',\n          'type': options.xType,\n          'title': options.xLabel,\n          'sort': 'x'\n        },\n        'y': {\n          'field': 'y',\n          'type': options.yType,\n          'title': options.yLabel,\n          'sort': 'y'\n        },\n        'fill': {\n          'field': 'value',\n          'type': 'quantitative'\n        }\n      }\n    }; //\n    // Format custom labels to remove the appended indices\n    //\n\n    const suffixPattern = `${IDX_SEPARATOR}\\\\d+$`;\n    const suffixRegex = new RegExp(suffixPattern);\n\n    if (xTickLabels) {\n      // @ts-ignore\n      spec.encoding.x.axis = {\n        'labelExpr': `replace(datum.value, regexp(/${suffixPattern}/), '')`\n      };\n    }\n\n    if (yTickLabels) {\n      // @ts-ignore\n      spec.encoding.y.axis = {\n        'labelExpr': `replace(datum.value, regexp(/${suffixPattern}/), '')`\n      };\n    } // Customize tooltip formatting to remove the appended indices\n\n\n    if (xTickLabels || yTickLabels) {\n      //@ts-ignore\n      embedOpts.tooltip = {\n        sanitize: value => {\n          const valueString = String(value);\n          return valueString.replace(suffixRegex, '');\n        }\n      };\n    }\n\n    let colorRange;\n\n    switch (options.colorMap) {\n      case 'blues':\n        colorRange = ['#f7fbff', '#4292c6'];\n        break;\n\n      case 'greyscale':\n        colorRange = ['#000000', '#ffffff'];\n        break;\n\n      case 'viridis':\n      default:\n        colorRange = 'viridis';\n        break;\n    }\n\n    if (colorRange !== 'viridis') {\n      const fill = spec.encoding.fill; // @ts-ignore\n\n      fill.scale = {\n        'range': colorRange\n      };\n    }\n\n    if (options.domain) {\n      const fill = spec.encoding.fill; // @ts-ignore\n\n      if (fill.scale != null) {\n        // @ts-ignore\n        fill.scale = Object.assign({}, fill.scale, {\n          'domain': options.domain\n        });\n      } else {\n        // @ts-ignore\n        fill.scale = {\n          'domain': options.domain\n        };\n      }\n    }\n\n    yield vega_embed_1.default(drawArea, spec, embedOpts);\n  });\n}\n\nexports.heatmap = heatmap;\n\nfunction convertToRowMajor(inputValues) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let originalShape;\n    let transposed;\n\n    if (inputValues instanceof tf.Tensor) {\n      originalShape = inputValues.shape;\n      transposed = inputValues.transpose();\n    } else {\n      originalShape = [inputValues.length, inputValues[0].length];\n      transposed = tf.tidy(() => tf.tensor2d(inputValues).transpose());\n    }\n\n    utils_1.assert(transposed.rank === 2, 'Input to renderHeatmap must be a 2d array or Tensor2d'); // Download the intermediate tensor values and\n    // dispose the transposed tensor.\n\n    const transposedValues = yield transposed.array();\n    transposed.dispose();\n    const transposedShape = [transposedValues.length, transposedValues[0].length];\n    utils_1.assert(originalShape[0] === transposedShape[1] && originalShape[1] === transposedShape[0], `Unexpected transposed shape. Original ${originalShape} : Transposed ${transposedShape}`);\n    return transposedValues;\n  });\n}\n\nfunction assertLabelsMatchShape(inputValues, labels, dimension) {\n  const shape = inputValues instanceof tf.Tensor ? inputValues.shape : [inputValues.length, inputValues[0].length];\n\n  if (dimension === 0) {\n    utils_1.assert(shape[0] === labels.length, `Length of xTickLabels (${labels.length}) must match number of rows` + ` (${shape[0]})`);\n  } else if (dimension === 1) {\n    utils_1.assert(shape[1] === labels.length, `Length of yTickLabels (${labels.length}) must match number of columns (${shape[1]})`);\n  }\n}\n\nconst defaultOpts = {\n  xLabel: null,\n  yLabel: null,\n  xType: 'ordinal',\n  yType: 'ordinal',\n  colorMap: 'viridis',\n  fontSize: 12,\n  domain: null,\n  rowMajor: false\n};","map":{"version":3,"sources":["../../src/render/heatmap.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport embed, {Mode, VisualizationSpec} from 'vega-embed';\n\nimport {Drawable, HeatmapData, HeatmapOptions} from '../types';\nimport {getDefaultHeight, getDefaultWidth} from '../util/dom';\nimport {assert} from '../util/utils';\n\nimport {getDrawArea} from './render_utils';\n\n/**\n * Renders a heatmap.\n *\n * ```js\n * const cols = 50;\n * const rows = 20;\n * const values = [];\n * for (let i = 0; i < cols; i++) {\n *   const col = []\n *   for (let j = 0; j < rows; j++) {\n *     col.push(i * j)\n *   }\n *   values.push(col);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Heatmap', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n * ```js\n * const data = {\n *   values: [[4, 2, 8, 20], [1, 7, 2, 10], [3, 3, 20, 13]],\n *   xTickLabels: ['cheese', 'pig', 'font'],\n *   yTickLabels: ['speed', 'smoothness', 'dexterity', 'mana'],\n * }\n *\n * // Render to visor\n * const surface = { name: 'Heatmap w Custom Labels', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n */\n/** @doc {heading: 'Charts', namespace: 'render'} */\nexport async function heatmap(\n    container: Drawable, data: HeatmapData,\n    opts: HeatmapOptions = {}): Promise<void> {\n  const options = Object.assign({}, defaultOpts, opts);\n  const drawArea = getDrawArea(container);\n\n  let inputValues = data.values;\n  if (options.rowMajor) {\n    inputValues = await convertToRowMajor(data.values);\n  }\n\n  // Data validation\n  const {xTickLabels, yTickLabels} = data;\n  if (xTickLabels != null) {\n    const dimension = 0;\n    assertLabelsMatchShape(inputValues, xTickLabels, dimension);\n  }\n\n  // Note that we will only do a check on the first element of the second\n  // dimension. We do not protect users against passing in a ragged array.\n  if (yTickLabels != null) {\n    const dimension = 1;\n    assertLabelsMatchShape(inputValues, yTickLabels, dimension);\n  }\n\n  //\n  // Format data for vega spec; an array of objects, one for for each cell\n  // in the matrix.\n  //\n  // If custom labels are passed in for xTickLabels or yTickLabels we need\n  // to make sure they are 'unique' before mapping them to visual properties.\n  // We therefore append the index of the label to the datum that will be used\n  // for that label in the x or y axis. We could do this in all cases but choose\n  // not to to avoid unnecessary string operations.\n  //\n  // We use IDX_SEPARATOR to demarcate the added index\n  const IDX_SEPARATOR = '@tfidx@';\n\n  const values: MatrixEntry[] = [];\n  if (inputValues instanceof tf.Tensor) {\n    assert(\n        inputValues.rank === 2,\n        'Input to renderHeatmap must be a 2d array or Tensor2d');\n\n    // This is a slightly specialized version of TensorBuffer.get, inlining it\n    // avoids the overhead of a function call per data element access and is\n    // specialized to only deal with the 2d case.\n    const inputArray = await inputValues.data();\n    const [numRows, numCols] = inputValues.shape;\n\n    for (let row = 0; row < numRows; row++) {\n      const x = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;\n      for (let col = 0; col < numCols; col++) {\n        const y =\n            yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;\n\n        const index = (row * numCols) + col;\n        const value = inputArray[index];\n\n        values.push({x, y, value});\n      }\n    }\n  } else {\n    const inputArray = inputValues;\n    for (let row = 0; row < inputArray.length; row++) {\n      const x = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;\n      for (let col = 0; col < inputArray[row].length; col++) {\n        const y =\n            yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;\n        const value = inputArray[row][col];\n        values.push({x, y, value});\n      }\n    }\n  }\n\n  const embedOpts = {\n    actions: false,\n    mode: 'vega-lite' as Mode,\n    defaultStyle: false,\n  };\n\n  const spec: VisualizationSpec = {\n    'width': options.width || getDefaultWidth(drawArea),\n    'height': options.height || getDefaultHeight(drawArea),\n    'padding': 0,\n    'autosize': {\n      'type': 'fit',\n      'contains': 'padding',\n      'resize': true,\n    },\n    'config': {\n      'axis': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      },\n      'text': {'fontSize': options.fontSize},\n      'legend': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      },\n      'scale': {'bandPaddingInner': 0, 'bandPaddingOuter': 0},\n    },\n    'data': {'values': values},\n    'mark': {'type': 'rect', 'tooltip': true},\n    'encoding': {\n      'x': {\n        'field': 'x',\n        'type': options.xType,\n        'title': options.xLabel,\n        'sort': 'x',\n      },\n      'y': {\n        'field': 'y',\n        'type': options.yType,\n        'title': options.yLabel,\n        'sort': 'y',\n      },\n      'fill': {\n        'field': 'value',\n        'type': 'quantitative',\n      }\n    }\n  };\n\n  //\n  // Format custom labels to remove the appended indices\n  //\n  const suffixPattern = `${IDX_SEPARATOR}\\\\d+$`;\n  const suffixRegex = new RegExp(suffixPattern);\n  if (xTickLabels) {\n    // @ts-ignore\n    spec.encoding.x.axis = {\n      'labelExpr': `replace(datum.value, regexp(/${suffixPattern}/), '')`,\n    };\n  }\n\n  if (yTickLabels) {\n    // @ts-ignore\n    spec.encoding.y.axis = {\n      'labelExpr': `replace(datum.value, regexp(/${suffixPattern}/), '')`,\n    };\n  }\n\n  // Customize tooltip formatting to remove the appended indices\n  if (xTickLabels || yTickLabels) {\n    //@ts-ignore\n    embedOpts.tooltip = {\n      sanitize: (value: string|number) => {\n        const valueString = String(value);\n        return valueString.replace(suffixRegex, '');\n      }\n    };\n  }\n\n  let colorRange: string[]|string;\n  switch (options.colorMap) {\n    case 'blues':\n      colorRange = ['#f7fbff', '#4292c6'];\n      break;\n    case 'greyscale':\n      colorRange = ['#000000', '#ffffff'];\n      break;\n    case 'viridis':\n    default:\n      colorRange = 'viridis';\n      break;\n  }\n\n  if (colorRange !== 'viridis') {\n    const fill = spec.encoding.fill;\n    // @ts-ignore\n    fill.scale = {'range': colorRange};\n  }\n\n  if (options.domain) {\n    const fill = spec.encoding.fill;\n    // @ts-ignore\n    if (fill.scale != null) {\n      // @ts-ignore\n      fill.scale = Object.assign({}, fill.scale, {'domain': options.domain});\n    } else {\n      // @ts-ignore\n      fill.scale = {'domain': options.domain};\n    }\n  }\n\n  await embed(drawArea, spec, embedOpts);\n}\n\nasync function convertToRowMajor(inputValues: number[][]|\n                                 tf.Tensor2D): Promise<number[][]> {\n  let originalShape: number[];\n  let transposed: tf.Tensor2D;\n  if (inputValues instanceof tf.Tensor) {\n    originalShape = inputValues.shape;\n    transposed = inputValues.transpose();\n  } else {\n    originalShape = [inputValues.length, inputValues[0].length];\n    transposed = tf.tidy(() => tf.tensor2d(inputValues).transpose());\n  }\n\n  assert(\n      transposed.rank === 2,\n      'Input to renderHeatmap must be a 2d array or Tensor2d');\n\n  // Download the intermediate tensor values and\n  // dispose the transposed tensor.\n  const transposedValues = await transposed.array();\n  transposed.dispose();\n\n  const transposedShape = [transposedValues.length, transposedValues[0].length];\n  assert(\n      originalShape[0] === transposedShape[1] &&\n          originalShape[1] === transposedShape[0],\n      `Unexpected transposed shape. Original ${originalShape} : Transposed ${\n          transposedShape}`);\n  return transposedValues;\n}\n\nfunction assertLabelsMatchShape(\n    inputValues: number[][]|tf.Tensor2D, labels: string[], dimension: 0|1) {\n  const shape = inputValues instanceof tf.Tensor ?\n      inputValues.shape :\n      [inputValues.length, inputValues[0].length];\n  if (dimension === 0) {\n    assert(\n        shape[0] === labels.length,\n        `Length of xTickLabels (${labels.length}) must match number of rows` +\n            ` (${shape[0]})`);\n  } else if (dimension === 1) {\n    assert(\n        shape[1] === labels.length,\n        `Length of yTickLabels (${\n            labels.length}) must match number of columns (${shape[1]})`);\n  }\n}\n\nconst defaultOpts: HeatmapOptions = {\n  xLabel: null,\n  yLabel: null,\n  xType: 'ordinal',\n  yType: 'ordinal',\n  colorMap: 'viridis',\n  fontSize: 12,\n  domain: null,\n  rowMajor: false,\n};\n\ninterface MatrixEntry {\n  x: string|number;\n  y: string|number;\n  value: number;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}