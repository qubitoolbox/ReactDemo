{"ast":null,"code":"import clip from './marks/clip';\nimport definition from './marks/definition';\nimport interactive from './marks/interactive';\nimport parseData from './marks/data';\nimport parseFacet from './marks/facet';\nimport parseSubflow from './marks/subflow';\nimport getRole from './marks/role';\nimport { GroupMark } from './marks/marktypes';\nimport { FrameRole, MarkRole, ScopeRole } from './marks/roles';\nimport { encoders } from './encode/encode-util';\nimport parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport parseSpec from './spec';\nimport DataScope from '../DataScope';\nimport { fieldRef, isSignal, ref } from '../util';\nimport { error } from 'vega-util';\nimport { Bound, Collect, DataJoin, Mark, Encode, Overlap, Render, Sieve, SortItems, ViewLayout } from '../transforms';\nexport default function (spec, scope) {\n  var role = getRole(spec),\n      group = spec.type === GroupMark,\n      facet = spec.from && spec.from.facet,\n      layout = spec.layout || role === ScopeRole || role === FrameRole,\n      nested = role === MarkRole || layout || facet,\n      overlap = spec.overlap,\n      ops,\n      op,\n      input,\n      store,\n      enc,\n      bound,\n      render,\n      sieve,\n      name,\n      joinRef,\n      markRef,\n      encodeRef,\n      layoutRef,\n      boundRef; // resolve input data\n\n  input = parseData(spec.from, group, scope); // data join to map tuples to visual items\n\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  joinRef = ref(op); // collect visual items\n\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  })); // connect visual items to scenegraph\n\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  markRef = ref(op); // add visual encoders\n\n  op = enc = scope.add(Encode(encoders(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  }))); // monitor parent marks to propagate changes\n\n  op.params.parent = scope.encode(); // add post-encoding transforms, if defined\n\n  if (spec.transform) {\n    spec.transform.forEach(function (_) {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  } // if item sort specified, perform post-encoding\n\n\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  encodeRef = ref(op); // add view layout operator if needed\n\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  } // compute bounding boxes\n\n\n  bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound); // if group mark, recurse to parse nested content\n\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : parseSpec(spec, scope); // guide group, we can avoid nested scopes\n\n    scope.popState();\n\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  } // if requested, add overlap removal transform\n\n\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  } // render / sieve items\n\n\n  render = scope.add(Render({\n    pulse: boundRef\n  }));\n  sieve = scope.add(Sieve({\n    pulse: ref(render)\n  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(function (on) {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  var method = overlap.method,\n      bound = overlap.bound,\n      sep = overlap.separation,\n      tol;\n  var params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n\n  if (bound) {\n    tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/mark.js"],"names":["clip","definition","interactive","parseData","parseFacet","parseSubflow","getRole","GroupMark","FrameRole","MarkRole","ScopeRole","encoders","parseTransform","parseTrigger","parseSpec","DataScope","fieldRef","isSignal","ref","error","Bound","Collect","DataJoin","Mark","Encode","Overlap","Render","Sieve","SortItems","ViewLayout","spec","scope","role","group","type","facet","from","layout","nested","overlap","ops","op","input","store","enc","bound","render","sieve","name","joinRef","markRef","encodeRef","layoutRef","boundRef","add","key","undefined","pulse","clean","markdef","context","$context","groups","lookup","parent","signals","signalRef","index","markpath","encode","style","mod","params","transform","forEach","_","tx","md","metadata","generates","changes","nomod","sort","compareRef","objectProperty","legends","mark","operators","pop","pushState","popState","push","parseOverlap","addData","on","insert","remove","toggle","source","method","sep","separation","tol","signal","order","field","tolerance","boundTolerance","boundScale","scaleRef","scale","boundOrient","orient"],"mappings":"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","sourcesContent":["import clip from './marks/clip';\nimport definition from './marks/definition';\nimport interactive from './marks/interactive';\nimport parseData from './marks/data';\nimport parseFacet from './marks/facet';\nimport parseSubflow from './marks/subflow';\nimport getRole from './marks/role';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole, MarkRole, ScopeRole} from './marks/roles';\nimport {encoders} from './encode/encode-util';\nimport parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport parseSpec from './spec';\nimport DataScope from '../DataScope';\nimport {fieldRef, isSignal, ref} from '../util';\nimport {error} from 'vega-util';\nimport {Bound, Collect, DataJoin, Mark, Encode, Overlap, Render, Sieve, SortItems, ViewLayout} from '../transforms';\n\nexport default function(spec, scope) {\n  var role = getRole(spec),\n      group = spec.type === GroupMark,\n      facet = spec.from && spec.from.facet,\n      layout = spec.layout || role === ScopeRole || role === FrameRole,\n      nested = role === MarkRole || layout || facet,\n      overlap = spec.overlap,\n      ops, op, input, store, enc, bound, render, sieve, name,\n      joinRef, markRef, encodeRef, layoutRef, boundRef;\n\n  // resolve input data\n  input = parseData(spec.from, group, scope);\n\n  // data join to map tuples to visual items\n  op = scope.add(DataJoin({\n    key:   input.key || (spec.key ? fieldRef(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  joinRef = ref(op);\n\n  // collect visual items\n  op = store = scope.add(Collect({pulse: joinRef}));\n\n  // connect visual items to scenegraph\n  op = scope.add(Mark({\n    markdef:     definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip:        clip(spec.clip, scope),\n    context:     {$context: true},\n    groups:      scope.lookup(),\n    parent:      scope.signals.parent ? scope.signalRef('parent') : null,\n    index:       scope.markpath(),\n    pulse:       ref(op)\n  }));\n  markRef = ref(op);\n\n  // add visual encoders\n  op = enc = scope.add(Encode(encoders(\n    spec.encode, spec.type, role, spec.style, scope,\n    {mod: false, pulse: markRef}\n  )));\n\n  // monitor parent marks to propagate changes\n  op.params.parent = scope.encode();\n\n  // add post-encoding transforms, if defined\n  if (spec.transform) {\n    spec.transform.forEach(function(_) {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  }\n\n  // if item sort specified, perform post-encoding\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort:  scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  encodeRef = ref(op);\n\n  // add view layout operator if needed\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout:   scope.objectProperty(spec.layout),\n      legends:  scope.legends,\n      mark:     markRef,\n      pulse:    encodeRef\n    }));\n    layoutRef = ref(layout);\n  }\n\n  // compute bounding boxes\n  bound = scope.add(Bound({mark: markRef, pulse: layoutRef || encodeRef}));\n  boundRef = ref(bound);\n\n  // if group mark, recurse to parse nested content\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) { ops = scope.operators; ops.pop(); if (layout) ops.pop(); }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input)          // explicit facet\n        : nested ? parseSubflow(spec, scope, input) // standard mark group\n        : parseSpec(spec, scope); // guide group, we can avoid nested scopes\n    scope.popState();\n\n    if (nested) { if (layout) ops.push(layout); ops.push(bound); }\n  }\n\n  // if requested, add overlap removal transform\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  }\n\n  // render / sieve items\n  render = scope.add(Render({pulse: boundRef}));\n  sieve = scope.add(Sieve({pulse: ref(render)}, undefined, scope.parent()));\n\n  // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(function(on) {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  var method = overlap.method,\n      bound = overlap.bound,\n      sep = overlap.separation, tol;\n\n  var params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse:  source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({field: overlap.order});\n  }\n\n  if (bound) {\n    tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n"]},"metadata":{},"sourceType":"module"}