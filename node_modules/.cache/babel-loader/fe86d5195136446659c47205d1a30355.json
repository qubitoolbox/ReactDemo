{"ast":null,"code":"import { CallExpression, parse } from 'vega-expression';\nimport { codeGenerator, codegenParams, SignalPrefix } from 'vega-functions';\nimport { error, hasOwnProperty, isString, stringValue } from 'vega-util';\nexport default function (expr, scope, preamble) {\n  var params = {},\n      ast,\n      gen; // parse the expression to an abstract syntax tree (ast)\n\n  try {\n    expr = isString(expr) ? expr : stringValue(expr) + '';\n    ast = parse(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  } // analyze ast function calls for dependencies\n\n\n  ast.visit(function visitor(node) {\n    if (node.type !== CallExpression) return;\n    var name = node.callee.name,\n        visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  }); // perform code generation\n\n  gen = codeGenerator(ast); // collect signal dependencies\n\n  gen.globals.forEach(function (name) {\n    var signalName = SignalPrefix + name;\n\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  }); // return generated expression code and dependencies\n\n  return {\n    $expr: preamble ? preamble + 'return(' + gen.code + ');' : gen.code,\n    $fields: gen.fields,\n    $params: params\n  };\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/expression.js"],"names":["CallExpression","parse","codeGenerator","codegenParams","SignalPrefix","error","hasOwnProperty","isString","stringValue","expr","scope","preamble","params","ast","gen","err","visit","visitor","node","type","name","callee","visitors","arguments","globals","forEach","signalName","getSignal","signalRef","$expr","code","$fields","fields","$params"],"mappings":"AAAA,SAAQA,cAAR,EAAwBC,KAAxB,QAAoC,iBAApC;AACA,SAAQC,aAAR,EAAuBC,aAAvB,EAAsCC,YAAtC,QAAyD,gBAAzD;AACA,SAAQC,KAAR,EAAeC,cAAf,EAA+BC,QAA/B,EAAyCC,WAAzC,QAA2D,WAA3D;AAEA,eAAe,UAASC,IAAT,EAAeC,KAAf,EAAsBC,QAAtB,EAAgC;AAC7C,MAAIC,MAAM,GAAG,EAAb;AAAA,MAAiBC,GAAjB;AAAA,MAAsBC,GAAtB,CAD6C,CAG7C;;AACA,MAAI;AACFL,IAAAA,IAAI,GAAGF,QAAQ,CAACE,IAAD,CAAR,GAAiBA,IAAjB,GAAyBD,WAAW,CAACC,IAAD,CAAX,GAAoB,EAApD;AACAI,IAAAA,GAAG,GAAGZ,KAAK,CAACQ,IAAD,CAAX;AACD,GAHD,CAGE,OAAOM,GAAP,EAAY;AACZV,IAAAA,KAAK,CAAC,6BAA6BI,IAA9B,CAAL;AACD,GAT4C,CAW7C;;;AACAI,EAAAA,GAAG,CAACG,KAAJ,CAAU,SAASC,OAAT,CAAiBC,IAAjB,EAAuB;AAC/B,QAAIA,IAAI,CAACC,IAAL,KAAcnB,cAAlB,EAAkC;AAClC,QAAIoB,IAAI,GAAGF,IAAI,CAACG,MAAL,CAAYD,IAAvB;AAAA,QACIJ,KAAK,GAAGb,aAAa,CAACmB,QAAd,CAAuBF,IAAvB,CADZ;AAEA,QAAIJ,KAAJ,EAAWA,KAAK,CAACI,IAAD,EAAOF,IAAI,CAACK,SAAZ,EAAuBb,KAAvB,EAA8BE,MAA9B,CAAL;AACZ,GALD,EAZ6C,CAmB7C;;AACAE,EAAAA,GAAG,GAAGZ,aAAa,CAACW,GAAD,CAAnB,CApB6C,CAsB7C;;AACAC,EAAAA,GAAG,CAACU,OAAJ,CAAYC,OAAZ,CAAoB,UAASL,IAAT,EAAe;AACjC,QAAIM,UAAU,GAAGtB,YAAY,GAAGgB,IAAhC;;AACA,QAAI,CAACd,cAAc,CAACM,MAAD,EAASc,UAAT,CAAf,IAAuChB,KAAK,CAACiB,SAAN,CAAgBP,IAAhB,CAA3C,EAAkE;AAChER,MAAAA,MAAM,CAACc,UAAD,CAAN,GAAqBhB,KAAK,CAACkB,SAAN,CAAgBR,IAAhB,CAArB;AACD;AACF,GALD,EAvB6C,CA8B7C;;AACA,SAAO;AACLS,IAAAA,KAAK,EAAIlB,QAAQ,GAAGA,QAAQ,GAAG,SAAX,GAAuBG,GAAG,CAACgB,IAA3B,GAAkC,IAArC,GAA4ChB,GAAG,CAACgB,IAD5D;AAELC,IAAAA,OAAO,EAAEjB,GAAG,CAACkB,MAFR;AAGLC,IAAAA,OAAO,EAAErB;AAHJ,GAAP;AAKD","sourcesContent":["import {CallExpression, parse} from 'vega-expression';\nimport {codeGenerator, codegenParams, SignalPrefix} from 'vega-functions';\nimport {error, hasOwnProperty, isString, stringValue} from 'vega-util';\n\nexport default function(expr, scope, preamble) {\n  var params = {}, ast, gen;\n\n  // parse the expression to an abstract syntax tree (ast)\n  try {\n    expr = isString(expr) ? expr : (stringValue(expr) + '');\n    ast = parse(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  }\n\n  // analyze ast function calls for dependencies\n  ast.visit(function visitor(node) {\n    if (node.type !== CallExpression) return;\n    var name = node.callee.name,\n        visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  });\n\n  // perform code generation\n  gen = codeGenerator(ast);\n\n  // collect signal dependencies\n  gen.globals.forEach(function(name) {\n    var signalName = SignalPrefix + name;\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  });\n\n  // return generated expression code and dependencies\n  return {\n    $expr:   preamble ? preamble + 'return(' + gen.code + ');' : gen.code,\n    $fields: gen.fields,\n    $params: params\n  };\n}\n"]},"metadata":{},"sourceType":"module"}