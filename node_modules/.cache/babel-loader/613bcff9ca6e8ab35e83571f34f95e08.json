{"ast":null,"code":"import { array, hasOwnProperty, toSet } from 'vega-util';\nimport invertRange from './scales/invertRange';\nimport invertRangeExtent from './scales/invertRangeExtent';\nimport { Identity, Linear, Log, Pow, Sqrt, Symlog, Time, UTC, Sequential, Diverging, Quantile, Quantize, Threshold, BinOrdinal, Ordinal, Band, Point, Continuous as C, Discrete as D, Discretizing as Z, Interpolating as I, Temporal as T } from './scales/types';\nimport { band as scaleBand, point as scalePoint } from './scales/scaleBand';\nimport { scaleBinOrdinal } from './scales/scaleBinOrdinal';\nimport * as $ from 'd3-scale'; // scale registry\n\nconst scales = {};\n/**\n * Augment scales with their type and needed inverse methods.\n */\n\nfunction create(type, constructor, metadata) {\n  const ctr = function scale() {\n    var s = constructor();\n\n    if (!s.invertRange) {\n      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : undefined;\n    }\n\n    s.type = type;\n    return s;\n  };\n\n  ctr.metadata = toSet(array(metadata));\n  return ctr;\n}\n\nexport function scale(type, scale, metadata) {\n  if (arguments.length > 1) {\n    scales[type] = create(type, scale, metadata);\n    return this;\n  } else {\n    return isValidScaleType(type) ? scales[type] : undefined;\n  }\n} // identity scale\n\nscale(Identity, $.scaleIdentity); // continuous scales\n\nscale(Linear, $.scaleLinear, C);\nscale(Log, $.scaleLog, [C, Log]);\nscale(Pow, $.scalePow, C);\nscale(Sqrt, $.scaleSqrt, C);\nscale(Symlog, $.scaleSymlog, C);\nscale(Time, $.scaleTime, [C, T]);\nscale(UTC, $.scaleUtc, [C, T]); // sequential scales\n\nscale(Sequential, $.scaleSequential, [C, I]); // backwards compat\n\nscale(`${Sequential}-${Linear}`, $.scaleSequential, [C, I]);\nscale(`${Sequential}-${Log}`, $.scaleSequentialLog, [C, I, Log]);\nscale(`${Sequential}-${Pow}`, $.scaleSequentialPow, [C, I]);\nscale(`${Sequential}-${Sqrt}`, $.scaleSequentialSqrt, [C, I]);\nscale(`${Sequential}-${Symlog}`, $.scaleSequentialSymlog, [C, I]); // diverging scales\n\nscale(`${Diverging}-${Linear}`, $.scaleDiverging, [C, I]);\nscale(`${Diverging}-${Log}`, $.scaleDivergingLog, [C, I, Log]);\nscale(`${Diverging}-${Pow}`, $.scaleDivergingPow, [C, I]);\nscale(`${Diverging}-${Sqrt}`, $.scaleDivergingSqrt, [C, I]);\nscale(`${Diverging}-${Symlog}`, $.scaleDivergingSymlog, [C, I]); // discretizing scales\n\nscale(Quantile, $.scaleQuantile, [Z, Quantile]);\nscale(Quantize, $.scaleQuantize, Z);\nscale(Threshold, $.scaleThreshold, Z); // discrete scales\n\nscale(BinOrdinal, scaleBinOrdinal, [D, Z]);\nscale(Ordinal, $.scaleOrdinal, D);\nscale(Band, scaleBand, D);\nscale(Point, scalePoint, D);\nexport function isValidScaleType(type) {\n  return hasOwnProperty(scales, type);\n}\n\nfunction hasType(key, type) {\n  const s = scales[key];\n  return s && s.metadata[type];\n}\n\nexport function isContinuous(key) {\n  return hasType(key, C);\n}\nexport function isDiscrete(key) {\n  return hasType(key, D);\n}\nexport function isDiscretizing(key) {\n  return hasType(key, Z);\n}\nexport function isLogarithmic(key) {\n  return hasType(key, Log);\n}\nexport function isTemporal(key) {\n  return hasType(key, T);\n}\nexport function isInterpolating(key) {\n  return hasType(key, I);\n}\nexport function isQuantile(key) {\n  return hasType(key, Quantile);\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/node_modules/vega-scale/src/scales.js"],"names":["array","hasOwnProperty","toSet","invertRange","invertRangeExtent","Identity","Linear","Log","Pow","Sqrt","Symlog","Time","UTC","Sequential","Diverging","Quantile","Quantize","Threshold","BinOrdinal","Ordinal","Band","Point","Continuous","C","Discrete","D","Discretizing","Z","Interpolating","I","Temporal","T","band","scaleBand","point","scalePoint","scaleBinOrdinal","$","scales","create","type","constructor","metadata","ctr","scale","s","invert","invertExtent","undefined","arguments","length","isValidScaleType","scaleIdentity","scaleLinear","scaleLog","scalePow","scaleSqrt","scaleSymlog","scaleTime","scaleUtc","scaleSequential","scaleSequentialLog","scaleSequentialPow","scaleSequentialSqrt","scaleSequentialSymlog","scaleDiverging","scaleDivergingLog","scaleDivergingPow","scaleDivergingSqrt","scaleDivergingSymlog","scaleQuantile","scaleQuantize","scaleThreshold","scaleOrdinal","hasType","key","isContinuous","isDiscrete","isDiscretizing","isLogarithmic","isTemporal","isInterpolating","isQuantile"],"mappings":"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","sourcesContent":["import {array, hasOwnProperty, toSet} from 'vega-util';\nimport invertRange from './scales/invertRange';\nimport invertRangeExtent from './scales/invertRangeExtent';\n\nimport {\n  Identity,\n  Linear, Log, Pow, Sqrt, Symlog,\n  Time, UTC, Sequential, Diverging,\n  Quantile, Quantize, Threshold,\n  BinOrdinal, Ordinal, Band, Point,\n  Continuous as C,\n  Discrete as D,\n  Discretizing as Z,\n  Interpolating as I,\n  Temporal as T\n} from './scales/types';\n\nimport {\n  band as scaleBand,\n  point as scalePoint\n} from './scales/scaleBand';\n\nimport {\n  scaleBinOrdinal\n} from './scales/scaleBinOrdinal';\n\nimport * as $ from 'd3-scale';\n\n// scale registry\nconst scales = {};\n\n/**\n * Augment scales with their type and needed inverse methods.\n */\nfunction create(type, constructor, metadata) {\n  const ctr = function scale() {\n    var s = constructor();\n\n    if (!s.invertRange) {\n      s.invertRange = s.invert ? invertRange(s)\n        : s.invertExtent ? invertRangeExtent(s)\n        : undefined;\n    }\n\n    s.type = type;\n    return s;\n  };\n\n  ctr.metadata = toSet(array(metadata));\n\n  return ctr;\n}\n\nexport function scale(type, scale, metadata) {\n  if (arguments.length > 1) {\n    scales[type] = create(type, scale, metadata);\n    return this;\n  } else {\n    return isValidScaleType(type) ? scales[type] : undefined;\n  }\n}\n\n// identity scale\nscale(Identity, $.scaleIdentity);\n\n// continuous scales\nscale(Linear, $.scaleLinear, C);\nscale(Log, $.scaleLog, [C, Log]);\nscale(Pow, $.scalePow, C);\nscale(Sqrt, $.scaleSqrt, C);\nscale(Symlog, $.scaleSymlog, C);\nscale(Time, $.scaleTime, [C, T]);\nscale(UTC, $.scaleUtc, [C, T]);\n\n// sequential scales\nscale(Sequential, $.scaleSequential, [C, I]); // backwards compat\nscale(`${Sequential}-${Linear}`, $.scaleSequential, [C, I]);\nscale(`${Sequential}-${Log}`, $.scaleSequentialLog, [C, I, Log]);\nscale(`${Sequential}-${Pow}`, $.scaleSequentialPow, [C, I]);\nscale(`${Sequential}-${Sqrt}`, $.scaleSequentialSqrt, [C, I]);\nscale(`${Sequential}-${Symlog}`, $.scaleSequentialSymlog, [C, I]);\n\n// diverging scales\nscale(`${Diverging}-${Linear}`, $.scaleDiverging, [C, I]);\nscale(`${Diverging}-${Log}`, $.scaleDivergingLog, [C, I, Log]);\nscale(`${Diverging}-${Pow}`, $.scaleDivergingPow, [C, I]);\nscale(`${Diverging}-${Sqrt}`, $.scaleDivergingSqrt, [C, I]);\nscale(`${Diverging}-${Symlog}`, $.scaleDivergingSymlog, [C, I]);\n\n// discretizing scales\nscale(Quantile, $.scaleQuantile, [Z, Quantile]);\nscale(Quantize, $.scaleQuantize, Z);\nscale(Threshold, $.scaleThreshold, Z);\n\n// discrete scales\nscale(BinOrdinal, scaleBinOrdinal, [D, Z]);\nscale(Ordinal, $.scaleOrdinal, D);\nscale(Band, scaleBand, D);\nscale(Point, scalePoint, D);\n\nexport function isValidScaleType(type) {\n  return hasOwnProperty(scales, type);\n}\n\nfunction hasType(key, type) {\n  const s = scales[key];\n  return s && s.metadata[type];\n}\n\nexport function isContinuous(key) {\n  return hasType(key, C);\n}\n\nexport function isDiscrete(key) {\n  return hasType(key, D);\n}\n\nexport function isDiscretizing(key) {\n  return hasType(key, Z);\n}\n\nexport function isLogarithmic(key) {\n  return hasType(key, Log);\n}\n\nexport function isTemporal(key) {\n  return hasType(key, T);\n}\n\nexport function isInterpolating(key) {\n  return hasType(key, I);\n}\n\nexport function isQuantile(key) {\n  return hasType(key, Quantile);\n}\n"]},"metadata":{},"sourceType":"module"}