{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst visor_1 = require(\"./components/visor\");\n\nlet visorSingleton;\nconst DEFAULT_TAB = 'Visor';\nconst VISOR_CONTAINER_ID = 'tfjs-visor-container';\n/**\n * The primary interface to the visor is the visor() function.\n *\n * This returns a singleton instance of the Visor class. The\n * singleton object will be replaced if the visor is removed from the DOM for\n * some reason.\n *\n * ```js\n * // Show the visor\n * tfvis.visor();\n * ```\n *\n */\n\n/** @doc {heading: 'Visor & Surfaces'} */\n\nfunction visor() {\n  if (typeof document === 'undefined') {\n    throw new Error('No document defined. This library needs a browser/dom to work');\n  }\n\n  if (document.getElementById(VISOR_CONTAINER_ID) && visorSingleton != null) {\n    return visorSingleton;\n  } // Create the container\n\n\n  let visorEl = document.getElementById(VISOR_CONTAINER_ID);\n\n  if (visorEl == null) {\n    visorEl = document.createElement('div');\n    visorEl.id = VISOR_CONTAINER_ID;\n    document.body.appendChild(visorEl);\n  }\n\n  let renderRoot;\n\n  function renderVisor(domNode, surfaceList) {\n    let visorInstance = null;\n    renderRoot = visor_1.VisorComponent.render(domNode, renderRoot, {\n      ref: r => visorInstance = r,\n      surfaceList: Array.from(surfaceList.values())\n    }); // Side effect of VisorComponent.render() is to assign visorInstance\n\n    return visorInstance;\n  } // TODO: consider changing this type. Possibly lift into top level state\n  // object\n\n\n  const surfaceList = new Map();\n  const visorComponentInstance = renderVisor(visorEl, surfaceList);\n  visorSingleton = new Visor(visorComponentInstance, visorEl, surfaceList, renderVisor);\n  return visorSingleton;\n}\n\nexports.visor = visor;\n/**\n * An instance of the visor. An instance of this class is created using the\n * `visor()` function.\n */\n\n/** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\nclass Visor {\n  constructor(visorComponent, visorEl, surfaceList, renderVisor) {\n    this.visorComponent = visorComponent;\n    this.el = visorEl;\n    this.surfaceList = surfaceList;\n    this.renderVisor = renderVisor;\n  }\n  /**\n   * Creates a surface on the visor\n   *\n   * Most methods in tfjs-vis that take a surface also take a SurfaceInfo\n   * so you rarely need to call this method unless you want to make a custom\n   * plot.\n   *\n   * ```js\n   * // Create a surface on a tab\n   * tfvis.visor().surface({name: 'My Surface', tab: 'My Tab'});\n   * ```\n   *\n   * ```js\n   * // Create a surface and specify its height\n   * tfvis.visor().surface({name: 'Custom Height', tab: 'My Tab', styles: {\n   *    height: 500\n   * }})\n   * ```\n   *\n   * @param options\n   */\n\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\n\n  surface(options) {\n    const {\n      name\n    } = options;\n    const tab = options.tab == null ? DEFAULT_TAB : options.tab;\n\n    if (name == null || // tslint:disable-next-line\n    !(typeof name === 'string' || name instanceof String)) {\n      throw new Error( // tslint:disable-next-line\n      'You must pass a config object with a \\'name\\' property to create or retrieve a surface');\n    }\n\n    const finalOptions = Object.assign({}, options, {\n      tab\n    });\n    const key = `${name}-${tab}`;\n\n    if (!this.surfaceList.has(key)) {\n      this.surfaceList.set(key, finalOptions);\n    }\n\n    this.renderVisor(this.el, this.surfaceList);\n    return this.visorComponent.getSurface(name, tab);\n  }\n  /**\n   * Returns a boolean indicating if the visor is in 'fullscreen' mode\n   */\n\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\n\n  isFullscreen() {\n    return this.visorComponent.isFullscreen();\n  }\n  /**\n   * Returns a boolean indicating if the visor is open\n   */\n\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\n\n  isOpen() {\n    return this.visorComponent.isOpen();\n  }\n  /**\n   * Closes the visor.\n   */\n\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\n\n  close() {\n    return this.visorComponent.close();\n  }\n  /**\n   * Opens the visor.\n   */\n\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\n\n  open() {\n    return this.visorComponent.open();\n  }\n  /**\n   * Toggles the visor (closed vs open).\n   */\n\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\n\n  toggle() {\n    return this.visorComponent.toggle();\n  }\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\n\n  toggleFullScreen() {\n    return this.visorComponent.toggleFullScreen();\n  }\n  /**\n   * Binds the ~ (tilde) key to toggle the visor.\n   *\n   * This is called by default when the visor is initially created.\n   */\n\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\n\n  bindKeys() {\n    return this.visorComponent.bindKeys();\n  }\n  /**\n   * Unbinds the keyboard control to toggle the visor.\n   */\n\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\n\n  unbindKeys() {\n    return this.visorComponent.unbindKeys();\n  }\n  /**\n   * Sets the active tab for the visor.\n   */\n\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n\n\n  setActiveTab(tabName) {\n    const tabs = this.visorComponent.state.tabs;\n\n    if (!tabs.has(tabName)) {\n      throw new Error(`Tab '${tabName}' does not exist`);\n    }\n\n    this.visorComponent.setState({\n      activeTab: tabName\n    });\n  }\n\n}\n\nexports.Visor = Visor;","map":{"version":3,"sources":["../src/visor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {VisorComponent} from './components/visor';\nimport {SurfaceInfo, SurfaceInfoStrict} from './types';\n\nlet visorSingleton: Visor;\nconst DEFAULT_TAB = 'Visor';\nconst VISOR_CONTAINER_ID = 'tfjs-visor-container';\n\n/**\n * The primary interface to the visor is the visor() function.\n *\n * This returns a singleton instance of the Visor class. The\n * singleton object will be replaced if the visor is removed from the DOM for\n * some reason.\n *\n * ```js\n * // Show the visor\n * tfvis.visor();\n * ```\n *\n */\n/** @doc {heading: 'Visor & Surfaces'} */\nexport function visor(): Visor {\n  if (typeof document === 'undefined') {\n    throw new Error(\n        'No document defined. This library needs a browser/dom to work');\n  }\n\n  if (document.getElementById(VISOR_CONTAINER_ID) && visorSingleton != null) {\n    return visorSingleton;\n  }\n\n  // Create the container\n  let visorEl = document.getElementById(VISOR_CONTAINER_ID);\n\n  if (visorEl == null) {\n    visorEl = document.createElement('div');\n    visorEl.id = VISOR_CONTAINER_ID;\n    document.body.appendChild(visorEl);\n  }\n\n  let renderRoot: Element;\n  function renderVisor(\n      domNode: HTMLElement,\n      surfaceList: Map<string, SurfaceInfoStrict>): VisorComponent {\n    let visorInstance: VisorComponent = null;\n    renderRoot = VisorComponent.render(domNode, renderRoot, {\n      ref: (r: VisorComponent) => visorInstance = r,\n      surfaceList: Array.from(surfaceList.values()),\n    });\n    // Side effect of VisorComponent.render() is to assign visorInstance\n    return visorInstance;\n  }\n\n  // TODO: consider changing this type. Possibly lift into top level state\n  // object\n  const surfaceList: Map<string, SurfaceInfoStrict> = new Map();\n  const visorComponentInstance: VisorComponent =\n      renderVisor(visorEl, surfaceList);\n\n  visorSingleton =\n      new Visor(visorComponentInstance, visorEl, surfaceList, renderVisor);\n\n  return visorSingleton;\n}\n\n/**\n * An instance of the visor. An instance of this class is created using the\n * `visor()` function.\n */\n/** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\nexport class Visor {\n  private visorComponent: VisorComponent;\n  private surfaceList: Map<string, SurfaceInfoStrict>;\n  private renderVisor:\n      (domNode: HTMLElement,\n       surfaceList: Map<string, SurfaceInfoStrict>) => VisorComponent;\n\n  /**\n   * The underlying html element of the visor.\n   */\n  public el: HTMLElement;\n\n  constructor(\n      visorComponent: VisorComponent, visorEl: HTMLElement,\n      surfaceList: Map<string, SurfaceInfoStrict>,\n      renderVisor:\n          (domNode: HTMLElement,\n           surfaceList: Map<string, SurfaceInfoStrict>) => VisorComponent) {\n    this.visorComponent = visorComponent;\n    this.el = visorEl;\n    this.surfaceList = surfaceList;\n    this.renderVisor = renderVisor;\n  }\n\n  /**\n   * Creates a surface on the visor\n   *\n   * Most methods in tfjs-vis that take a surface also take a SurfaceInfo\n   * so you rarely need to call this method unless you want to make a custom\n   * plot.\n   *\n   * ```js\n   * // Create a surface on a tab\n   * tfvis.visor().surface({name: 'My Surface', tab: 'My Tab'});\n   * ```\n   *\n   * ```js\n   * // Create a surface and specify its height\n   * tfvis.visor().surface({name: 'Custom Height', tab: 'My Tab', styles: {\n   *    height: 500\n   * }})\n   * ```\n   *\n   * @param options\n   */\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n  surface(options: SurfaceInfo) {\n    const {name} = options;\n    const tab = options.tab == null ? DEFAULT_TAB : options.tab;\n\n    if (name == null ||\n        // tslint:disable-next-line\n        !(typeof name === 'string' || name as any instanceof String)) {\n      throw new Error(\n          // tslint:disable-next-line\n          'You must pass a config object with a \\'name\\' property to create or retrieve a surface');\n    }\n\n    const finalOptions: SurfaceInfoStrict = {\n      ...options,\n      tab,\n    };\n\n    const key = `${name}-${tab}`;\n    if (!this.surfaceList.has(key)) {\n      this.surfaceList.set(key, finalOptions);\n    }\n\n    this.renderVisor(this.el, this.surfaceList);\n    return this.visorComponent.getSurface(name, tab);\n  }\n\n  /**\n   * Returns a boolean indicating if the visor is in 'fullscreen' mode\n   */\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n  isFullscreen() {\n    return this.visorComponent.isFullscreen();\n  }\n\n  /**\n   * Returns a boolean indicating if the visor is open\n   */\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n  isOpen() {\n    return this.visorComponent.isOpen();\n  }\n\n  /**\n   * Closes the visor.\n   */\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n  close() {\n    return this.visorComponent.close();\n  }\n\n  /**\n   * Opens the visor.\n   */\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n  open() {\n    return this.visorComponent.open();\n  }\n\n  /**\n   * Toggles the visor (closed vs open).\n   */\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n  toggle() {\n    return this.visorComponent.toggle();\n  }\n\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n  toggleFullScreen() {\n    return this.visorComponent.toggleFullScreen();\n  }\n\n  /**\n   * Binds the ~ (tilde) key to toggle the visor.\n   *\n   * This is called by default when the visor is initially created.\n   */\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n  bindKeys() {\n    return this.visorComponent.bindKeys();\n  }\n\n  /**\n   * Unbinds the keyboard control to toggle the visor.\n   */\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n  unbindKeys() {\n    return this.visorComponent.unbindKeys();\n  }\n\n  /**\n   * Sets the active tab for the visor.\n   */\n  /** @doc {heading: 'Visor & Surfaces', subheading: 'Visor Methods'} */\n  setActiveTab(tabName: string) {\n    const tabs = this.visorComponent.state.tabs;\n    if (!tabs.has(tabName)) {\n      throw new Error(`Tab '${tabName}' does not exist`);\n    }\n    this.visorComponent.setState({activeTab: tabName});\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}