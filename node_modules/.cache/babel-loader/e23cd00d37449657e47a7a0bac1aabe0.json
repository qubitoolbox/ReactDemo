{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isString } from 'vega-util';\nimport { binToString, isBinning, isSelectionExtent } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash, keys, replacePathInField, unique, vals, varName } from '../../util';\nimport { binFormatExpression } from '../common';\nimport { isUnitModel } from '../model';\nimport { parseSelectionBinExtent } from '../selection/parse';\nimport { DataFlowNode } from './dataflow';\n\nfunction rangeFormula(model, fieldDef, channel, config) {\n  var _a, _b;\n\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n    const guide = isUnitModel(model) ? (_b = (_a = model.axis(channel), _a !== null && _a !== void 0 ? _a : model.legend(channel)), _b !== null && _b !== void 0 ? _b : {}) : {};\n    const startField = vgField(fieldDef, {\n      expr: 'datum'\n    });\n    const endField = vgField(fieldDef, {\n      expr: 'datum',\n      binSuffix: 'end'\n    });\n    return {\n      formulaAs: vgField(fieldDef, {\n        binSuffix: 'range',\n        forAs: true\n      }),\n      formula: binFormatExpression(startField, endField, guide.format, config)\n    };\n  }\n\n  return {};\n}\n\nfunction binKey(bin, field) {\n  return `${binToString(bin)}_${field}`;\n}\n\nfunction getSignalsFromModel(model, key) {\n  return {\n    signal: model.getName(`${key}_bins`),\n    extentSignal: model.getName(`${key}_extent`)\n  };\n}\n\nexport function getBinSignalName(model, field, bin) {\n  var _a;\n\n  const normalizedBin = (_a = normalizeBin(bin, undefined), _a !== null && _a !== void 0 ? _a : {});\n  const key = binKey(normalizedBin, field);\n  return model.getName(`${key}_bins`);\n}\n\nfunction isBinTransform(t) {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t, bin, model) {\n  let as;\n  let span;\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {\n      forAs: true\n    }), vgField(t, {\n      binSuffix: 'end',\n      forAs: true\n    })];\n  }\n\n  const normalizedBin = Object.assign({}, normalizeBin(bin, undefined));\n  const key = binKey(normalizedBin, t.field);\n  const {\n    signal,\n    extentSignal\n  } = getSignalsFromModel(model, key);\n\n  if (isSelectionExtent(normalizedBin.extent)) {\n    const ext = normalizedBin.extent;\n    const selName = ext.selection;\n    span = parseSelectionBinExtent(model.getSelectionComponent(varName(selName), selName), ext);\n    delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n  }\n\n  const binComponent = Object.assign(Object.assign(Object.assign({\n    bin: normalizedBin,\n    field: t.field,\n    as: [as]\n  }, signal ? {\n    signal\n  } : {}), extentSignal ? {\n    extentSignal\n  } : {}), span ? {\n    span\n  } : {});\n  return {\n    key,\n    binComponent\n  };\n}\n\nexport class BinNode extends DataFlowNode {\n  constructor(parent, bins) {\n    super(parent);\n    this.bins = bins;\n  }\n\n  clone() {\n    return new BinNode(null, duplicate(this.bins));\n  }\n\n  static makeFromEncoding(parent, model) {\n    const bins = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n        const {\n          key,\n          binComponent\n        } = createBinComponent(fieldDef, fieldDef.bin, model);\n        binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));\n      }\n\n      return binComponentIndex;\n    }, {});\n\n    if (keys(bins).length === 0) {\n      return null;\n    }\n\n    return new BinNode(parent, bins);\n  }\n  /**\n   * Creates a bin node from BinTransform.\n   * The optional parameter should provide\n   */\n\n\n  static makeFromTransform(parent, t, model) {\n    const {\n      key,\n      binComponent\n    } = createBinComponent(t, t.bin, model);\n    return new BinNode(parent, {\n      [key]: binComponent\n    });\n  }\n  /**\n   * Merge bin nodes. This method either integrates the bin config from the other node\n   * or if this node already has a bin config, renames the corresponding signal in the model.\n   */\n\n\n  merge(other, renameSignal) {\n    for (const key of keys(other.bins)) {\n      if (key in this.bins) {\n        renameSignal(other.bins[key].signal, this.bins[key].signal); // Ensure that we don't have duplicate names for signal pairs\n\n        this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n      } else {\n        this.bins[key] = other.bins[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n\n  producedFields() {\n    return new Set(vals(this.bins).map(c => c.as).flat(2));\n  }\n\n  dependentFields() {\n    return new Set(vals(this.bins).map(c => c.field));\n  }\n\n  hash() {\n    return `Bin ${hash(this.bins)}`;\n  }\n\n  assemble() {\n    return vals(this.bins).flatMap(bin => {\n      const transform = [];\n      const [binAs, ...remainingAs] = bin.as;\n\n      const _a = bin.bin,\n            {\n        extent\n      } = _a,\n            params = __rest(_a, [\"extent\"]);\n\n      const binTrans = Object.assign(Object.assign(Object.assign({\n        type: 'bin',\n        field: replacePathInField(bin.field),\n        as: binAs,\n        signal: bin.signal\n      }, !isSelectionExtent(extent) ? {\n        extent\n      } : {\n        extent: null\n      }), bin.span ? {\n        span: {\n          signal: `span(${bin.span})`\n        }\n      } : {}), params);\n\n      if (!extent && bin.extentSignal) {\n        transform.push({\n          type: 'extent',\n          field: replacePathInField(bin.field),\n          signal: bin.extentSignal\n        });\n        binTrans.extent = {\n          signal: bin.extentSignal\n        };\n      }\n\n      transform.push(binTrans);\n\n      for (const as of remainingAs) {\n        for (let i = 0; i < 2; i++) {\n          transform.push({\n            type: 'formula',\n            expr: vgField({\n              field: binAs[i]\n            }, {\n              expr: 'datum'\n            }),\n            as: as[i]\n          });\n        }\n      }\n\n      if (bin.formula) {\n        transform.push({\n          type: 'formula',\n          expr: bin.formula,\n          as: bin.formulaAs\n        });\n      }\n\n      return transform;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/bin.ts"],"names":[],"mappings":"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","sourcesContent":["import {BinTransform as VgBinTransform, Transforms as VgTransform} from 'vega';\nimport {isString} from 'vega-util';\nimport {BinParams, binToString, isBinning, isSelectionExtent} from '../../bin';\nimport {Channel} from '../../channel';\nimport {binRequiresRange, FieldName, isTypedFieldDef, normalizeBin, TypedFieldDef, vgField} from '../../channeldef';\nimport {Config} from '../../config';\nimport {BinTransform} from '../../transform';\nimport {Dict, duplicate, hash, keys, replacePathInField, unique, vals, varName} from '../../util';\nimport {binFormatExpression} from '../common';\nimport {isUnitModel, Model, ModelWithField} from '../model';\nimport {parseSelectionBinExtent} from '../selection/parse';\nimport {DataFlowNode} from './dataflow';\n\nfunction rangeFormula(model: ModelWithField, fieldDef: TypedFieldDef<string>, channel: Channel, config: Config) {\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n\n    const guide = isUnitModel(model) ? model.axis(channel) ?? model.legend(channel) ?? {} : {};\n\n    const startField = vgField(fieldDef, {expr: 'datum'});\n    const endField = vgField(fieldDef, {expr: 'datum', binSuffix: 'end'});\n\n    return {\n      formulaAs: vgField(fieldDef, {binSuffix: 'range', forAs: true}),\n      formula: binFormatExpression(startField, endField, guide.format, config)\n    };\n  }\n  return {};\n}\n\nfunction binKey(bin: BinParams, field: string) {\n  return `${binToString(bin)}_${field}`;\n}\n\nfunction getSignalsFromModel(model: Model, key: string) {\n  return {\n    signal: model.getName(`${key}_bins`),\n    extentSignal: model.getName(`${key}_extent`)\n  };\n}\n\nexport function getBinSignalName(model: Model, field: string, bin: boolean | BinParams) {\n  const normalizedBin = normalizeBin(bin, undefined) ?? {};\n  const key = binKey(normalizedBin, field);\n  return model.getName(`${key}_bins`);\n}\n\nfunction isBinTransform(t: TypedFieldDef<string> | BinTransform): t is BinTransform {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t: TypedFieldDef<string> | BinTransform, bin: boolean | BinParams, model: Model) {\n  let as: [string, string];\n  let span: string;\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {forAs: true}), vgField(t, {binSuffix: 'end', forAs: true})];\n  }\n\n  const normalizedBin = {...normalizeBin(bin, undefined)};\n  const key = binKey(normalizedBin, t.field);\n  const {signal, extentSignal} = getSignalsFromModel(model, key);\n\n  if (isSelectionExtent(normalizedBin.extent)) {\n    const ext = normalizedBin.extent;\n    const selName = ext.selection;\n    span = parseSelectionBinExtent(model.getSelectionComponent(varName(selName), selName), ext);\n    delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n  }\n\n  const binComponent: BinComponent = {\n    bin: normalizedBin,\n    field: t.field,\n    as: [as],\n    ...(signal ? {signal} : {}),\n    ...(extentSignal ? {extentSignal} : {}),\n    ...(span ? {span} : {})\n  };\n\n  return {key, binComponent};\n}\n\nexport interface BinComponent {\n  bin: BinParams;\n  field: FieldName;\n  extentSignal?: string;\n  signal?: string;\n  span?: string;\n\n  /** Pairs of strings of the names of start and end signals */\n  as: [string, string][];\n\n  // Range Formula\n\n  formula?: string;\n  formulaAs?: string;\n}\n\nexport class BinNode extends DataFlowNode {\n  public clone() {\n    return new BinNode(null, duplicate(this.bins));\n  }\n\n  constructor(parent: DataFlowNode, private bins: Dict<BinComponent>) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: ModelWithField) {\n    const bins = model.reduceFieldDef((binComponentIndex: Dict<BinComponent>, fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n        const {key, binComponent} = createBinComponent(fieldDef, fieldDef.bin, model);\n        binComponentIndex[key] = {\n          ...binComponent,\n          ...binComponentIndex[key],\n          ...rangeFormula(model, fieldDef, channel, model.config)\n        };\n      }\n      return binComponentIndex;\n    }, {} as Dict<BinComponent>);\n\n    if (keys(bins).length === 0) {\n      return null;\n    }\n\n    return new BinNode(parent, bins);\n  }\n\n  /**\n   * Creates a bin node from BinTransform.\n   * The optional parameter should provide\n   */\n  public static makeFromTransform(parent: DataFlowNode, t: BinTransform, model: Model) {\n    const {key, binComponent} = createBinComponent(t, t.bin, model);\n    return new BinNode(parent, {\n      [key]: binComponent\n    });\n  }\n\n  /**\n   * Merge bin nodes. This method either integrates the bin config from the other node\n   * or if this node already has a bin config, renames the corresponding signal in the model.\n   */\n  public merge(other: BinNode, renameSignal: (s1: string, s2: string) => void) {\n    for (const key of keys(other.bins)) {\n      if (key in this.bins) {\n        renameSignal(other.bins[key].signal, this.bins[key].signal);\n        // Ensure that we don't have duplicate names for signal pairs\n        this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n      } else {\n        this.bins[key] = other.bins[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n    other.remove();\n  }\n\n  public producedFields() {\n    return new Set(\n      vals(this.bins)\n        .map(c => c.as)\n        .flat(2)\n    );\n  }\n\n  public dependentFields() {\n    return new Set(vals(this.bins).map(c => c.field));\n  }\n\n  public hash() {\n    return `Bin ${hash(this.bins)}`;\n  }\n\n  public assemble(): VgTransform[] {\n    return vals(this.bins).flatMap(bin => {\n      const transform: VgTransform[] = [];\n\n      const [binAs, ...remainingAs] = bin.as;\n      const {extent, ...params} = bin.bin;\n      const binTrans: VgBinTransform = {\n        type: 'bin',\n        field: replacePathInField(bin.field),\n        as: binAs,\n        signal: bin.signal,\n        ...(!isSelectionExtent(extent) ? {extent} : {extent: null}),\n        ...(bin.span ? {span: {signal: `span(${bin.span})`}} : {}),\n        ...params\n      };\n\n      if (!extent && bin.extentSignal) {\n        transform.push({\n          type: 'extent',\n          field: replacePathInField(bin.field),\n          signal: bin.extentSignal\n        });\n        binTrans.extent = {signal: bin.extentSignal};\n      }\n\n      transform.push(binTrans);\n\n      for (const as of remainingAs) {\n        for (let i = 0; i < 2; i++) {\n          transform.push({\n            type: 'formula',\n            expr: vgField({field: binAs[i]}, {expr: 'datum'}),\n            as: as[i]\n          });\n        }\n      }\n\n      if (bin.formula) {\n        transform.push({\n          type: 'formula',\n          expr: bin.formula,\n          as: bin.formulaAs\n        });\n      }\n      return transform;\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}