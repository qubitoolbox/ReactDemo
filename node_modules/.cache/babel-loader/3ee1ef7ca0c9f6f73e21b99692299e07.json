{"ast":null,"code":"import isArray from './isArray';\nimport isObject from './isObject';\nexport function mergeConfig(...configs) {\n  return configs.reduce((out, source) => {\n    for (var key in source) {\n      if (key === 'signals') {\n        // for signals, we merge the signals arrays\n        // source signals take precedence over\n        // existing signals with the same name\n        out.signals = mergeNamed(out.signals, source.signals);\n      } else {\n        // otherwise, merge objects subject to recursion constraints\n        // for legend block, recurse for the layout entry only\n        // for style block, recurse for all properties\n        // otherwise, no recursion: objects overwrite, no merging\n        var r = key === 'legend' ? {\n          'layout': 1\n        } : key === 'style' ? true : null;\n        writeConfig(out, key, source[key], r);\n      }\n    }\n\n    return out;\n  }, {});\n}\nexport function writeConfig(output, key, value, recurse) {\n  var k, o;\n\n  if (isObject(value) && !isArray(value)) {\n    o = isObject(output[key]) ? output[key] : output[key] = {};\n\n    for (k in value) {\n      if (recurse && (recurse === true || recurse[k])) {\n        writeConfig(o, k, value[k]);\n      } else {\n        o[k] = value[k];\n      }\n    }\n  } else {\n    output[key] = value;\n  }\n}\n\nfunction mergeNamed(a, b) {\n  if (a == null) return b;\n  const map = {},\n        out = [];\n\n  function add(_) {\n    if (!map[_.name]) {\n      map[_.name] = 1;\n      out.push(_);\n    }\n  }\n\n  b.forEach(add);\n  a.forEach(add);\n  return out;\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-lite/node_modules/vega-util/src/mergeConfig.js"],"names":["isArray","isObject","mergeConfig","configs","reduce","out","source","key","signals","mergeNamed","r","writeConfig","output","value","recurse","k","o","a","b","map","add","_","name","push","forEach"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,WAApB;AACA,OAAOC,QAAP,MAAqB,YAArB;AAEA,OAAO,SAASC,WAAT,CAAqB,GAAGC,OAAxB,EAAiC;AACtC,SAAOA,OAAO,CAACC,MAAR,CAAe,CAACC,GAAD,EAAMC,MAAN,KAAiB;AACrC,SAAK,IAAIC,GAAT,IAAgBD,MAAhB,EAAwB;AACtB,UAAIC,GAAG,KAAK,SAAZ,EAAuB;AACrB;AACA;AACA;AACAF,QAAAA,GAAG,CAACG,OAAJ,GAAcC,UAAU,CAACJ,GAAG,CAACG,OAAL,EAAcF,MAAM,CAACE,OAArB,CAAxB;AACD,OALD,MAKO;AACL;AACA;AACA;AACA;AACA,YAAIE,CAAC,GAAGH,GAAG,KAAK,QAAR,GAAmB;AAAC,oBAAU;AAAX,SAAnB,GACJA,GAAG,KAAK,OAAR,GAAkB,IAAlB,GACA,IAFJ;AAGAI,QAAAA,WAAW,CAACN,GAAD,EAAME,GAAN,EAAWD,MAAM,CAACC,GAAD,CAAjB,EAAwBG,CAAxB,CAAX;AACD;AACF;;AACD,WAAOL,GAAP;AACD,GAnBM,EAmBJ,EAnBI,CAAP;AAoBD;AAED,OAAO,SAASM,WAAT,CAAqBC,MAArB,EAA6BL,GAA7B,EAAkCM,KAAlC,EAAyCC,OAAzC,EAAkD;AACvD,MAAIC,CAAJ,EAAOC,CAAP;;AACA,MAAIf,QAAQ,CAACY,KAAD,CAAR,IAAmB,CAACb,OAAO,CAACa,KAAD,CAA/B,EAAwC;AACtCG,IAAAA,CAAC,GAAGf,QAAQ,CAACW,MAAM,CAACL,GAAD,CAAP,CAAR,GAAwBK,MAAM,CAACL,GAAD,CAA9B,GAAuCK,MAAM,CAACL,GAAD,CAAN,GAAc,EAAzD;;AACA,SAAKQ,CAAL,IAAUF,KAAV,EAAiB;AACf,UAAIC,OAAO,KAAKA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,CAACC,CAAD,CAAhC,CAAX,EAAiD;AAC/CJ,QAAAA,WAAW,CAACK,CAAD,EAAID,CAAJ,EAAOF,KAAK,CAACE,CAAD,CAAZ,CAAX;AACD,OAFD,MAEO;AACLC,QAAAA,CAAC,CAACD,CAAD,CAAD,GAAOF,KAAK,CAACE,CAAD,CAAZ;AACD;AACF;AACF,GATD,MASO;AACLH,IAAAA,MAAM,CAACL,GAAD,CAAN,GAAcM,KAAd;AACD;AACF;;AAED,SAASJ,UAAT,CAAoBQ,CAApB,EAAuBC,CAAvB,EAA0B;AACxB,MAAID,CAAC,IAAI,IAAT,EAAe,OAAOC,CAAP;AAEf,QAAMC,GAAG,GAAG,EAAZ;AAAA,QAAgBd,GAAG,GAAG,EAAtB;;AAEA,WAASe,GAAT,CAAaC,CAAb,EAAgB;AACd,QAAI,CAACF,GAAG,CAACE,CAAC,CAACC,IAAH,CAAR,EAAkB;AAChBH,MAAAA,GAAG,CAACE,CAAC,CAACC,IAAH,CAAH,GAAc,CAAd;AACAjB,MAAAA,GAAG,CAACkB,IAAJ,CAASF,CAAT;AACD;AACF;;AAEDH,EAAAA,CAAC,CAACM,OAAF,CAAUJ,GAAV;AACAH,EAAAA,CAAC,CAACO,OAAF,CAAUJ,GAAV;AACA,SAAOf,GAAP;AACD","sourcesContent":["import isArray from './isArray';\nimport isObject from './isObject';\n\nexport function mergeConfig(...configs) {\n  return configs.reduce((out, source) => {\n    for (var key in source) {\n      if (key === 'signals') {\n        // for signals, we merge the signals arrays\n        // source signals take precedence over\n        // existing signals with the same name\n        out.signals = mergeNamed(out.signals, source.signals);\n      } else {\n        // otherwise, merge objects subject to recursion constraints\n        // for legend block, recurse for the layout entry only\n        // for style block, recurse for all properties\n        // otherwise, no recursion: objects overwrite, no merging\n        var r = key === 'legend' ? {'layout': 1}\n          : key === 'style' ? true\n          : null;\n        writeConfig(out, key, source[key], r);\n      }\n    }\n    return out;\n  }, {});\n}\n\nexport function writeConfig(output, key, value, recurse) {\n  var k, o;\n  if (isObject(value) && !isArray(value)) {\n    o = isObject(output[key]) ? output[key] : (output[key] = {});\n    for (k in value) {\n      if (recurse && (recurse === true || recurse[k])) {\n        writeConfig(o, k, value[k]);\n      } else {\n        o[k] = value[k];\n      }\n    }\n  } else {\n    output[key] = value;\n  }\n}\n\nfunction mergeNamed(a, b) {\n  if (a == null) return b;\n\n  const map = {}, out = [];\n\n  function add(_) {\n    if (!map[_.name]) {\n      map[_.name] = 1;\n      out.push(_);\n    }\n  }\n\n  b.forEach(add);\n  a.forEach(add);\n  return out;\n}\n"]},"metadata":{},"sourceType":"module"}