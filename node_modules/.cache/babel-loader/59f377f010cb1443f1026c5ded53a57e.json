{"ast":null,"code":"import { Feature, FeatureCollection } from './constants';\nimport { Transform } from 'vega-dataflow';\nimport { projection, projectionProperties } from 'vega-projection';\nimport { array, error, inherits, isFunction } from 'vega-util';\n/**\n * Maintains a cartographic projection.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nexport default function Projection(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\nvar prototype = inherits(Projection, Transform);\n\nprototype.transform = function (_, pulse) {\n  var proj = this.value;\n\n  if (!proj || _.modified('type')) {\n    this.value = proj = create(_.type);\n    projectionProperties.forEach(function (prop) {\n      if (_[prop] != null) set(proj, prop, _[prop]);\n    });\n  } else {\n    projectionProperties.forEach(function (prop) {\n      if (_.modified(prop)) set(proj, prop, _[prop]);\n    });\n  }\n\n  if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\n  if (_.fit) fit(proj, _);\n  return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n};\n\nfunction fit(proj, _) {\n  var data = collectGeoJSON(_.fit);\n  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;\n}\n\nfunction create(type) {\n  var constructor = projection((type || 'mercator').toLowerCase());\n  if (!constructor) error('Unrecognized projection type: ' + type);\n  return constructor();\n}\n\nfunction set(proj, key, value) {\n  if (isFunction(proj[key])) proj[key](value);\n}\n\nexport function collectGeoJSON(data) {\n  data = array(data);\n  return data.length === 1 ? data[0] : {\n    type: FeatureCollection,\n    features: data.reduce((a, f) => a.concat(featurize(f)), [])\n  };\n}\n\nfunction featurize(f) {\n  return f.type === FeatureCollection ? f.features : array(f).filter(d => d != null).map(d => d.type === Feature ? d : {\n    type: Feature,\n    geometry: d\n  });\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-geo/src/Projection.js"],"names":["Feature","FeatureCollection","Transform","projection","projectionProperties","array","error","inherits","isFunction","Projection","params","call","modified","prototype","transform","_","pulse","proj","value","create","type","forEach","prop","set","pointRadius","path","fit","fork","NO_SOURCE","NO_FIELDS","data","collectGeoJSON","extent","fitExtent","size","fitSize","constructor","toLowerCase","key","length","features","reduce","a","f","concat","featurize","filter","d","map","geometry"],"mappings":"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","sourcesContent":["import {Feature, FeatureCollection} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {projection, projectionProperties} from 'vega-projection';\nimport {array, error, inherits, isFunction} from 'vega-util';\n\n/**\n * Maintains a cartographic projection.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nexport default function Projection(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\nvar prototype = inherits(Projection, Transform);\n\nprototype.transform = function(_, pulse) {\n  var proj = this.value;\n\n  if (!proj || _.modified('type')) {\n    this.value = (proj = create(_.type));\n    projectionProperties.forEach(function(prop) {\n      if (_[prop] != null) set(proj, prop, _[prop]);\n    });\n  } else {\n    projectionProperties.forEach(function(prop) {\n      if (_.modified(prop)) set(proj, prop, _[prop]);\n    });\n  }\n\n  if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\n  if (_.fit) fit(proj, _);\n\n  return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n};\n\nfunction fit(proj, _) {\n  var data = collectGeoJSON(_.fit);\n  _.extent ? proj.fitExtent(_.extent, data)\n    : _.size ? proj.fitSize(_.size, data) : 0;\n}\n\nfunction create(type) {\n  var constructor = projection((type || 'mercator').toLowerCase());\n  if (!constructor) error('Unrecognized projection type: ' + type);\n  return constructor();\n}\n\nfunction set(proj, key, value) {\n   if (isFunction(proj[key])) proj[key](value);\n}\n\nexport function collectGeoJSON(data) {\n  data = array(data);\n  return data.length === 1 ? data[0]\n    : {\n        type: FeatureCollection,\n        features: data.reduce((a, f) => a.concat(featurize(f)), [])\n      };\n}\n\nfunction featurize(f) {\n  return f.type === FeatureCollection\n    ? f.features\n    : array(f).filter(d => d != null).map(\n        d => d.type === Feature ? d : {type: Feature, geometry: d}\n      );\n}\n"]},"metadata":{},"sourceType":"module"}