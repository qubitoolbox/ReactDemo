{"ast":null,"code":"import Operator from '../Operator';\nimport { isChangeSet } from '../ChangeSet';\nimport { constant, extend, isFunction } from 'vega-util';\nvar SKIP = {\n  skip: true\n};\n/**\n * Perform operator updates in response to events. Applies an\n * update function to compute a new operator value. If the update function\n * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\n * changes. Otherwise, the operator value will be updated to the return value.\n * @param {EventStream|Operator} source - The event source to react to.\n *   This argument can be either an EventStream or an Operator.\n * @param {Operator|function(object):Operator} target - The operator to update.\n *   This argument can either be an Operator instance or (if the source\n *   argument is an EventStream), a function that accepts an event object as\n *   input and returns an Operator to target.\n * @param {function(Parameters,Event): *} [update] - Optional update function\n *   to compute the new operator value, or a literal value to set. Update\n *   functions expect to receive a parameter object and event as arguments.\n *   This function can either return a new operator value or (if the source\n *   argument is an EventStream) a {@link ChangeSet} instance to pulse\n *   the target operator with tuple changes.\n * @param {object} [params] - The update function parameters.\n * @param {object} [options] - Additional options hash. If not overridden,\n *   updated operators will be skipped by default.\n * @param {boolean} [options.skip] - If true, the operator will\n *  be skipped: it will not be evaluated, but its dependents will be.\n * @param {boolean} [options.force] - If true, the operator will\n *   be re-evaluated even if its value has not changed.\n * @return {Dataflow}\n */\n\nexport default function (source, target, update, params, options) {\n  var fn = source instanceof Operator ? onOperator : onStream;\n  fn(this, source, target, update, params, options);\n  return this;\n}\n\nfunction onStream(df, stream, target, update, params, options) {\n  var opt = extend({}, options, SKIP),\n      func,\n      op;\n  if (!isFunction(target)) target = constant(target);\n\n  if (update === undefined) {\n    func = e => df.touch(target(e));\n  } else if (isFunction(update)) {\n    op = new Operator(null, update, params, false);\n\n    func = e => {\n      op.evaluate(e);\n      const t = target(e),\n            v = op.value;\n      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\n    };\n  } else {\n    func = e => df.update(target(e), update, opt);\n  }\n\n  stream.apply(func);\n}\n\nfunction onOperator(df, source, target, update, params, options) {\n  if (update === undefined) {\n    source.targets().add(target);\n  } else {\n    const opt = options || {},\n          op = new Operator(null, updater(target, update), params, false);\n    op.modified(opt.force);\n    op.rank = source.rank; // immediately follow source\n\n    source.targets().add(op); // add dependency\n\n    if (target) {\n      op.skip(true); // skip first invocation\n\n      op.value = target.value; // initialize value\n\n      op.targets().add(target); // chain dependencies\n\n      df.connect(target, [op]); // rerank as needed, #1672\n    }\n  }\n}\n\nfunction updater(target, update) {\n  update = isFunction(update) ? update : constant(update);\n  return target ? function (_, pulse) {\n    const value = update(_, pulse);\n\n    if (!target.skip()) {\n      target.skip(value !== this.value).value = value;\n    }\n\n    return value;\n  } : update;\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-dataflow/src/dataflow/on.js"],"names":["Operator","isChangeSet","constant","extend","isFunction","SKIP","skip","source","target","update","params","options","fn","onOperator","onStream","df","stream","opt","func","op","undefined","e","touch","evaluate","t","v","value","pulse","apply","targets","add","updater","modified","force","rank","connect","_"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,aAArB;AACA,SAAQC,WAAR,QAA0B,cAA1B;AACA,SAAQC,QAAR,EAAkBC,MAAlB,EAA0BC,UAA1B,QAA2C,WAA3C;AAEA,IAAIC,IAAI,GAAG;AAACC,EAAAA,IAAI,EAAE;AAAP,CAAX;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,eAAe,UAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,EAAiCC,MAAjC,EAAyCC,OAAzC,EAAkD;AAC/D,MAAIC,EAAE,GAAGL,MAAM,YAAYP,QAAlB,GAA6Ba,UAA7B,GAA0CC,QAAnD;AACAF,EAAAA,EAAE,CAAC,IAAD,EAAOL,MAAP,EAAeC,MAAf,EAAuBC,MAAvB,EAA+BC,MAA/B,EAAuCC,OAAvC,CAAF;AACA,SAAO,IAAP;AACD;;AAED,SAASG,QAAT,CAAkBC,EAAlB,EAAsBC,MAAtB,EAA8BR,MAA9B,EAAsCC,MAAtC,EAA8CC,MAA9C,EAAsDC,OAAtD,EAA+D;AAC7D,MAAIM,GAAG,GAAGd,MAAM,CAAC,EAAD,EAAKQ,OAAL,EAAcN,IAAd,CAAhB;AAAA,MAAqCa,IAArC;AAAA,MAA2CC,EAA3C;AAEA,MAAI,CAACf,UAAU,CAACI,MAAD,CAAf,EAAyBA,MAAM,GAAGN,QAAQ,CAACM,MAAD,CAAjB;;AAEzB,MAAIC,MAAM,KAAKW,SAAf,EAA0B;AACxBF,IAAAA,IAAI,GAAGG,CAAC,IAAIN,EAAE,CAACO,KAAH,CAASd,MAAM,CAACa,CAAD,CAAf,CAAZ;AACD,GAFD,MAEO,IAAIjB,UAAU,CAACK,MAAD,CAAd,EAAwB;AAC7BU,IAAAA,EAAE,GAAG,IAAInB,QAAJ,CAAa,IAAb,EAAmBS,MAAnB,EAA2BC,MAA3B,EAAmC,KAAnC,CAAL;;AACAQ,IAAAA,IAAI,GAAGG,CAAC,IAAI;AACVF,MAAAA,EAAE,CAACI,QAAH,CAAYF,CAAZ;AACA,YAAMG,CAAC,GAAGhB,MAAM,CAACa,CAAD,CAAhB;AAAA,YAAqBI,CAAC,GAAGN,EAAE,CAACO,KAA5B;AACAzB,MAAAA,WAAW,CAACwB,CAAD,CAAX,GAAiBV,EAAE,CAACY,KAAH,CAASH,CAAT,EAAYC,CAAZ,EAAed,OAAf,CAAjB,GAA2CI,EAAE,CAACN,MAAH,CAAUe,CAAV,EAAaC,CAAb,EAAgBR,GAAhB,CAA3C;AACD,KAJD;AAKD,GAPM,MAOA;AACLC,IAAAA,IAAI,GAAGG,CAAC,IAAIN,EAAE,CAACN,MAAH,CAAUD,MAAM,CAACa,CAAD,CAAhB,EAAqBZ,MAArB,EAA6BQ,GAA7B,CAAZ;AACD;;AAEDD,EAAAA,MAAM,CAACY,KAAP,CAAaV,IAAb;AACD;;AAED,SAASL,UAAT,CAAoBE,EAApB,EAAwBR,MAAxB,EAAgCC,MAAhC,EAAwCC,MAAxC,EAAgDC,MAAhD,EAAwDC,OAAxD,EAAiE;AAC/D,MAAIF,MAAM,KAAKW,SAAf,EAA0B;AACxBb,IAAAA,MAAM,CAACsB,OAAP,GAAiBC,GAAjB,CAAqBtB,MAArB;AACD,GAFD,MAEO;AACL,UAAMS,GAAG,GAAGN,OAAO,IAAI,EAAvB;AAAA,UACMQ,EAAE,GAAG,IAAInB,QAAJ,CAAa,IAAb,EAAmB+B,OAAO,CAACvB,MAAD,EAASC,MAAT,CAA1B,EAA4CC,MAA5C,EAAoD,KAApD,CADX;AAEAS,IAAAA,EAAE,CAACa,QAAH,CAAYf,GAAG,CAACgB,KAAhB;AACAd,IAAAA,EAAE,CAACe,IAAH,GAAU3B,MAAM,CAAC2B,IAAjB,CAJK,CAIwB;;AAC7B3B,IAAAA,MAAM,CAACsB,OAAP,GAAiBC,GAAjB,CAAqBX,EAArB,EALK,CAKwB;;AAE7B,QAAIX,MAAJ,EAAY;AACVW,MAAAA,EAAE,CAACb,IAAH,CAAQ,IAAR,EADU,CACiB;;AAC3Ba,MAAAA,EAAE,CAACO,KAAH,GAAWlB,MAAM,CAACkB,KAAlB,CAFU,CAEiB;;AAC3BP,MAAAA,EAAE,CAACU,OAAH,GAAaC,GAAb,CAAiBtB,MAAjB,EAHU,CAGiB;;AAC3BO,MAAAA,EAAE,CAACoB,OAAH,CAAW3B,MAAX,EAAmB,CAACW,EAAD,CAAnB,EAJU,CAIiB;AAC5B;AACF;AACF;;AAED,SAASY,OAAT,CAAiBvB,MAAjB,EAAyBC,MAAzB,EAAiC;AAC/BA,EAAAA,MAAM,GAAGL,UAAU,CAACK,MAAD,CAAV,GAAqBA,MAArB,GAA8BP,QAAQ,CAACO,MAAD,CAA/C;AACA,SAAOD,MAAM,GACT,UAAS4B,CAAT,EAAYT,KAAZ,EAAmB;AACjB,UAAMD,KAAK,GAAGjB,MAAM,CAAC2B,CAAD,EAAIT,KAAJ,CAApB;;AACA,QAAI,CAACnB,MAAM,CAACF,IAAP,EAAL,EAAoB;AAClBE,MAAAA,MAAM,CAACF,IAAP,CAAYoB,KAAK,KAAK,KAAKA,KAA3B,EAAkCA,KAAlC,GAA0CA,KAA1C;AACD;;AACD,WAAOA,KAAP;AACD,GAPQ,GAQTjB,MARJ;AASD","sourcesContent":["import Operator from '../Operator';\nimport {isChangeSet} from '../ChangeSet';\nimport {constant, extend, isFunction} from 'vega-util';\n\nvar SKIP = {skip: true};\n\n/**\n * Perform operator updates in response to events. Applies an\n * update function to compute a new operator value. If the update function\n * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\n * changes. Otherwise, the operator value will be updated to the return value.\n * @param {EventStream|Operator} source - The event source to react to.\n *   This argument can be either an EventStream or an Operator.\n * @param {Operator|function(object):Operator} target - The operator to update.\n *   This argument can either be an Operator instance or (if the source\n *   argument is an EventStream), a function that accepts an event object as\n *   input and returns an Operator to target.\n * @param {function(Parameters,Event): *} [update] - Optional update function\n *   to compute the new operator value, or a literal value to set. Update\n *   functions expect to receive a parameter object and event as arguments.\n *   This function can either return a new operator value or (if the source\n *   argument is an EventStream) a {@link ChangeSet} instance to pulse\n *   the target operator with tuple changes.\n * @param {object} [params] - The update function parameters.\n * @param {object} [options] - Additional options hash. If not overridden,\n *   updated operators will be skipped by default.\n * @param {boolean} [options.skip] - If true, the operator will\n *  be skipped: it will not be evaluated, but its dependents will be.\n * @param {boolean} [options.force] - If true, the operator will\n *   be re-evaluated even if its value has not changed.\n * @return {Dataflow}\n */\nexport default function(source, target, update, params, options) {\n  var fn = source instanceof Operator ? onOperator : onStream;\n  fn(this, source, target, update, params, options);\n  return this;\n}\n\nfunction onStream(df, stream, target, update, params, options) {\n  var opt = extend({}, options, SKIP), func, op;\n\n  if (!isFunction(target)) target = constant(target);\n\n  if (update === undefined) {\n    func = e => df.touch(target(e));\n  } else if (isFunction(update)) {\n    op = new Operator(null, update, params, false);\n    func = e => {\n      op.evaluate(e);\n      const t = target(e), v = op.value;\n      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\n    };\n  } else {\n    func = e => df.update(target(e), update, opt);\n  }\n\n  stream.apply(func);\n}\n\nfunction onOperator(df, source, target, update, params, options) {\n  if (update === undefined) {\n    source.targets().add(target);\n  } else {\n    const opt = options || {},\n          op = new Operator(null, updater(target, update), params, false);\n    op.modified(opt.force);\n    op.rank = source.rank;       // immediately follow source\n    source.targets().add(op);    // add dependency\n\n    if (target) {\n      op.skip(true);             // skip first invocation\n      op.value = target.value;   // initialize value\n      op.targets().add(target);  // chain dependencies\n      df.connect(target, [op]);  // rerank as needed, #1672\n    }\n  }\n}\n\nfunction updater(target, update) {\n  update = isFunction(update) ? update : constant(update);\n  return target\n    ? function(_, pulse) {\n        const value = update(_, pulse);\n        if (!target.skip()) {\n          target.skip(value !== this.value).value = value;\n        }\n        return value;\n      }\n    : update;\n}\n"]},"metadata":{},"sourceType":"module"}