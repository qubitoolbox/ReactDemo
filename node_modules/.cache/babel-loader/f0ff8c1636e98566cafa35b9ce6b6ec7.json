{"ast":null,"code":"import parseExpression from './expression';\nimport parseStream from './stream';\nimport { Scope, View } from '../util';\nimport { selector } from 'vega-event-selector';\nimport { array, error, extend, isString, stringValue } from 'vega-util';\nvar preamble = 'var datum=event.item&&event.item.datum;';\nexport default function (spec, scope, target) {\n  var events = spec.events,\n      update = spec.update,\n      encode = spec.encode,\n      sources = [],\n      entry = {\n    target: target\n  };\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  } // interpret as an event selector string\n\n\n  if (isString(events)) {\n    events = selector(events, scope.isSubscope() ? Scope : View);\n  } // separate event streams from signal updates\n\n\n  events = array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners\n\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  } // merge event streams, include as source\n\n\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  } // resolve update value\n\n\n  entry.update = isString(update) ? parseExpression(update, scope, preamble) : update.expr != null ? parseExpression(update.expr, scope, preamble) : update.value != null ? update.value : update.signal != null ? {\n    $expr: '_.value',\n    $params: {\n      value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n\n  sources.forEach(function (source) {\n    scope.addUpdate(extend(streamSource(source, scope), entry));\n  });\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n  };\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/update.js"],"names":["parseExpression","parseStream","Scope","View","selector","array","error","extend","isString","stringValue","preamble","spec","scope","target","events","update","encode","sources","entry","isSubscope","filter","s","signal","scale","push","length","mergeSources","merge","expr","value","$expr","$params","signalRef","force","options","forEach","source","addUpdate","streamSource","stream","scaleRef","map"],"mappings":"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","sourcesContent":["import parseExpression from './expression';\nimport parseStream from './stream';\nimport {Scope, View} from '../util';\nimport {selector} from 'vega-event-selector';\nimport {array, error, extend, isString, stringValue} from 'vega-util';\n\nvar preamble = 'var datum=event.item&&event.item.datum;';\n\nexport default function(spec, scope, target) {\n  var events = spec.events,\n      update = spec.update,\n      encode = spec.encode,\n      sources = [],\n      entry = {target: target};\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  }\n\n  // interpret as an event selector string\n  if (isString(events)) {\n    events = selector(events, scope.isSubscope() ? Scope : View);\n  }\n\n  // separate event streams from signal updates\n  events = array(events)\n    .filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1);\n\n  // merge internal operator listeners\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  }\n\n  // merge event streams, include as source\n  if (events.length) {\n    sources.push(events.length > 1 ? {merge: events} : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  }\n\n  // resolve update value\n  entry.update = isString(update) ? parseExpression(update, scope, preamble)\n    : update.expr != null ? parseExpression(update.expr, scope, preamble)\n    : update.value != null ? update.value\n    : update.signal != null ? {\n        $expr:   '_.value',\n        $params: {value: scope.signalRef(update.signal)}\n      }\n    : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {force: true};\n  }\n\n  sources.forEach(function(source) {\n    scope.addUpdate(extend(streamSource(source, scope), entry));\n  });\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal)\n          : stream.scale ? scope.scaleRef(stream.scale)\n          : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '['\n      + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal)\n      + ']'\n  };\n}\n"]},"metadata":{},"sourceType":"module"}