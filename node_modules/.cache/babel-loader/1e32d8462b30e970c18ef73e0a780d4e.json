{"ast":null,"code":"import { ingest, tupleid } from './Tuple';\nimport { array, constant, isFunction } from 'vega-util';\nexport function isChangeSet(v) {\n  return v && v.constructor === changeset;\n}\nexport default function changeset() {\n  var add = [],\n      // insert tuples\n  rem = [],\n      // remove tuples\n  mod = [],\n      // modify tuples\n  remp = [],\n      // remove by predicate\n  modp = [],\n      // modify by predicate\n  reflow = false;\n  return {\n    constructor: changeset,\n    insert: function (t) {\n      var d = array(t),\n          i = 0,\n          n = d.length;\n\n      for (; i < n; ++i) add.push(d[i]);\n\n      return this;\n    },\n    remove: function (t) {\n      var a = isFunction(t) ? remp : rem,\n          d = array(t),\n          i = 0,\n          n = d.length;\n\n      for (; i < n; ++i) a.push(d[i]);\n\n      return this;\n    },\n    modify: function (t, field, value) {\n      var m = {\n        field: field,\n        value: constant(value)\n      };\n\n      if (isFunction(t)) {\n        m.filter = t;\n        modp.push(m);\n      } else {\n        m.tuple = t;\n        mod.push(m);\n      }\n\n      return this;\n    },\n    encode: function (t, set) {\n      if (isFunction(t)) modp.push({\n        filter: t,\n        field: set\n      });else mod.push({\n        tuple: t,\n        field: set\n      });\n      return this;\n    },\n    reflow: function () {\n      reflow = true;\n      return this;\n    },\n    pulse: function (pulse, tuples) {\n      var cur = {},\n          out = {},\n          i,\n          n,\n          m,\n          f,\n          t,\n          id; // build lookup table of current tuples\n\n      for (i = 0, n = tuples.length; i < n; ++i) {\n        cur[tupleid(tuples[i])] = 1;\n      } // process individual tuples to remove\n\n\n      for (i = 0, n = rem.length; i < n; ++i) {\n        t = rem[i];\n        cur[tupleid(t)] = -1;\n      } // process predicate-based removals\n\n\n      for (i = 0, n = remp.length; i < n; ++i) {\n        f = remp[i];\n        tuples.forEach(function (t) {\n          if (f(t)) cur[tupleid(t)] = -1;\n        });\n      } // process all add tuples\n\n\n      for (i = 0, n = add.length; i < n; ++i) {\n        t = add[i];\n        id = tupleid(t);\n\n        if (cur[id]) {\n          // tuple already resides in dataset\n          // if flagged for both add and remove, cancel\n          cur[id] = 1;\n        } else {\n          // tuple does not reside in dataset, add\n          pulse.add.push(ingest(add[i]));\n        }\n      } // populate pulse rem list\n\n\n      for (i = 0, n = tuples.length; i < n; ++i) {\n        t = tuples[i];\n        if (cur[tupleid(t)] < 0) pulse.rem.push(t);\n      } // modify helper method\n\n\n      function modify(t, f, v) {\n        if (v) {\n          t[f] = v(t);\n        } else {\n          pulse.encode = f;\n        }\n\n        if (!reflow) out[tupleid(t)] = t;\n      } // process individual tuples to modify\n\n\n      for (i = 0, n = mod.length; i < n; ++i) {\n        m = mod[i];\n        t = m.tuple;\n        f = m.field;\n        id = cur[tupleid(t)];\n\n        if (id > 0) {\n          modify(t, f, m.value);\n          pulse.modifies(f);\n        }\n      } // process predicate-based modifications\n\n\n      for (i = 0, n = modp.length; i < n; ++i) {\n        m = modp[i];\n        f = m.filter;\n        tuples.forEach(function (t) {\n          if (f(t) && cur[tupleid(t)] > 0) {\n            modify(t, m.field, m.value);\n          }\n        });\n        pulse.modifies(m.field);\n      } // upon reflow request, populate mod with all non-removed tuples\n      // otherwise, populate mod with modified tuples only\n\n\n      if (reflow) {\n        pulse.mod = rem.length || remp.length ? tuples.filter(function (t) {\n          return cur[tupleid(t)] > 0;\n        }) : tuples.slice();\n      } else {\n        for (id in out) pulse.mod.push(out[id]);\n      }\n\n      return pulse;\n    }\n  };\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-dataflow/src/ChangeSet.js"],"names":["ingest","tupleid","array","constant","isFunction","isChangeSet","v","constructor","changeset","add","rem","mod","remp","modp","reflow","insert","t","d","i","n","length","push","remove","a","modify","field","value","m","filter","tuple","encode","set","pulse","tuples","cur","out","f","id","forEach","modifies","slice"],"mappings":"AAAA,SAAQA,MAAR,EAAgBC,OAAhB,QAA8B,SAA9B;AACA,SAAQC,KAAR,EAAeC,QAAf,EAAyBC,UAAzB,QAA0C,WAA1C;AAEA,OAAO,SAASC,WAAT,CAAqBC,CAArB,EAAwB;AAC7B,SAAOA,CAAC,IAAIA,CAAC,CAACC,WAAF,KAAkBC,SAA9B;AACD;AAED,eAAe,SAASA,SAAT,GAAqB;AAClC,MAAIC,GAAG,GAAG,EAAV;AAAA,MAAe;AACXC,EAAAA,GAAG,GAAG,EADV;AAAA,MACe;AACXC,EAAAA,GAAG,GAAG,EAFV;AAAA,MAEe;AACXC,EAAAA,IAAI,GAAG,EAHX;AAAA,MAGe;AACXC,EAAAA,IAAI,GAAG,EAJX;AAAA,MAIe;AACXC,EAAAA,MAAM,GAAG,KALb;AAOA,SAAO;AACLP,IAAAA,WAAW,EAAEC,SADR;AAELO,IAAAA,MAAM,EAAE,UAASC,CAAT,EAAY;AAClB,UAAIC,CAAC,GAAGf,KAAK,CAACc,CAAD,CAAb;AAAA,UAAkBE,CAAC,GAAG,CAAtB;AAAA,UAAyBC,CAAC,GAAGF,CAAC,CAACG,MAA/B;;AACA,aAAOF,CAAC,GAACC,CAAT,EAAY,EAAED,CAAd,EAAiBT,GAAG,CAACY,IAAJ,CAASJ,CAAC,CAACC,CAAD,CAAV;;AACjB,aAAO,IAAP;AACD,KANI;AAOLI,IAAAA,MAAM,EAAE,UAASN,CAAT,EAAY;AAClB,UAAIO,CAAC,GAAGnB,UAAU,CAACY,CAAD,CAAV,GAAgBJ,IAAhB,GAAuBF,GAA/B;AAAA,UACIO,CAAC,GAAGf,KAAK,CAACc,CAAD,CADb;AAAA,UACkBE,CAAC,GAAG,CADtB;AAAA,UACyBC,CAAC,GAAGF,CAAC,CAACG,MAD/B;;AAEA,aAAOF,CAAC,GAACC,CAAT,EAAY,EAAED,CAAd,EAAiBK,CAAC,CAACF,IAAF,CAAOJ,CAAC,CAACC,CAAD,CAAR;;AACjB,aAAO,IAAP;AACD,KAZI;AAaLM,IAAAA,MAAM,EAAE,UAASR,CAAT,EAAYS,KAAZ,EAAmBC,KAAnB,EAA0B;AAChC,UAAIC,CAAC,GAAG;AAACF,QAAAA,KAAK,EAAEA,KAAR;AAAeC,QAAAA,KAAK,EAAEvB,QAAQ,CAACuB,KAAD;AAA9B,OAAR;;AACA,UAAItB,UAAU,CAACY,CAAD,CAAd,EAAmB;AACjBW,QAAAA,CAAC,CAACC,MAAF,GAAWZ,CAAX;AACAH,QAAAA,IAAI,CAACQ,IAAL,CAAUM,CAAV;AACD,OAHD,MAGO;AACLA,QAAAA,CAAC,CAACE,KAAF,GAAUb,CAAV;AACAL,QAAAA,GAAG,CAACU,IAAJ,CAASM,CAAT;AACD;;AACD,aAAO,IAAP;AACD,KAvBI;AAwBLG,IAAAA,MAAM,EAAE,UAASd,CAAT,EAAYe,GAAZ,EAAiB;AACvB,UAAI3B,UAAU,CAACY,CAAD,CAAd,EAAmBH,IAAI,CAACQ,IAAL,CAAU;AAACO,QAAAA,MAAM,EAAEZ,CAAT;AAAYS,QAAAA,KAAK,EAAEM;AAAnB,OAAV,EAAnB,KACKpB,GAAG,CAACU,IAAJ,CAAS;AAACQ,QAAAA,KAAK,EAAEb,CAAR;AAAWS,QAAAA,KAAK,EAAEM;AAAlB,OAAT;AACL,aAAO,IAAP;AACD,KA5BI;AA6BLjB,IAAAA,MAAM,EAAE,YAAW;AACjBA,MAAAA,MAAM,GAAG,IAAT;AACA,aAAO,IAAP;AACD,KAhCI;AAiCLkB,IAAAA,KAAK,EAAE,UAASA,KAAT,EAAgBC,MAAhB,EAAwB;AAC7B,UAAIC,GAAG,GAAG,EAAV;AAAA,UAAcC,GAAG,GAAG,EAApB;AAAA,UAAwBjB,CAAxB;AAAA,UAA2BC,CAA3B;AAAA,UAA8BQ,CAA9B;AAAA,UAAiCS,CAAjC;AAAA,UAAoCpB,CAApC;AAAA,UAAuCqB,EAAvC,CAD6B,CAG7B;;AACA,WAAKnB,CAAC,GAAC,CAAF,EAAKC,CAAC,GAACc,MAAM,CAACb,MAAnB,EAA2BF,CAAC,GAACC,CAA7B,EAAgC,EAAED,CAAlC,EAAqC;AACnCgB,QAAAA,GAAG,CAACjC,OAAO,CAACgC,MAAM,CAACf,CAAD,CAAP,CAAR,CAAH,GAA0B,CAA1B;AACD,OAN4B,CAQ7B;;;AACA,WAAKA,CAAC,GAAC,CAAF,EAAKC,CAAC,GAACT,GAAG,CAACU,MAAhB,EAAwBF,CAAC,GAACC,CAA1B,EAA6B,EAAED,CAA/B,EAAkC;AAChCF,QAAAA,CAAC,GAAGN,GAAG,CAACQ,CAAD,CAAP;AACAgB,QAAAA,GAAG,CAACjC,OAAO,CAACe,CAAD,CAAR,CAAH,GAAkB,CAAC,CAAnB;AACD,OAZ4B,CAc7B;;;AACA,WAAKE,CAAC,GAAC,CAAF,EAAKC,CAAC,GAACP,IAAI,CAACQ,MAAjB,EAAyBF,CAAC,GAACC,CAA3B,EAA8B,EAAED,CAAhC,EAAmC;AACjCkB,QAAAA,CAAC,GAAGxB,IAAI,CAACM,CAAD,CAAR;AACAe,QAAAA,MAAM,CAACK,OAAP,CAAe,UAAStB,CAAT,EAAY;AACzB,cAAIoB,CAAC,CAACpB,CAAD,CAAL,EAAUkB,GAAG,CAACjC,OAAO,CAACe,CAAD,CAAR,CAAH,GAAkB,CAAC,CAAnB;AACX,SAFD;AAGD,OApB4B,CAsB7B;;;AACA,WAAKE,CAAC,GAAC,CAAF,EAAKC,CAAC,GAACV,GAAG,CAACW,MAAhB,EAAwBF,CAAC,GAACC,CAA1B,EAA6B,EAAED,CAA/B,EAAkC;AAChCF,QAAAA,CAAC,GAAGP,GAAG,CAACS,CAAD,CAAP;AACAmB,QAAAA,EAAE,GAAGpC,OAAO,CAACe,CAAD,CAAZ;;AACA,YAAIkB,GAAG,CAACG,EAAD,CAAP,EAAa;AACX;AACA;AACAH,UAAAA,GAAG,CAACG,EAAD,CAAH,GAAU,CAAV;AACD,SAJD,MAIO;AACL;AACAL,UAAAA,KAAK,CAACvB,GAAN,CAAUY,IAAV,CAAerB,MAAM,CAACS,GAAG,CAACS,CAAD,CAAJ,CAArB;AACD;AACF,OAlC4B,CAoC7B;;;AACA,WAAKA,CAAC,GAAC,CAAF,EAAKC,CAAC,GAACc,MAAM,CAACb,MAAnB,EAA2BF,CAAC,GAACC,CAA7B,EAAgC,EAAED,CAAlC,EAAqC;AACnCF,QAAAA,CAAC,GAAGiB,MAAM,CAACf,CAAD,CAAV;AACA,YAAIgB,GAAG,CAACjC,OAAO,CAACe,CAAD,CAAR,CAAH,GAAkB,CAAtB,EAAyBgB,KAAK,CAACtB,GAAN,CAAUW,IAAV,CAAeL,CAAf;AAC1B,OAxC4B,CA0C7B;;;AACA,eAASQ,MAAT,CAAgBR,CAAhB,EAAmBoB,CAAnB,EAAsB9B,CAAtB,EAAyB;AACvB,YAAIA,CAAJ,EAAO;AACLU,UAAAA,CAAC,CAACoB,CAAD,CAAD,GAAO9B,CAAC,CAACU,CAAD,CAAR;AACD,SAFD,MAEO;AACLgB,UAAAA,KAAK,CAACF,MAAN,GAAeM,CAAf;AACD;;AACD,YAAI,CAACtB,MAAL,EAAaqB,GAAG,CAAClC,OAAO,CAACe,CAAD,CAAR,CAAH,GAAkBA,CAAlB;AACd,OAlD4B,CAoD7B;;;AACA,WAAKE,CAAC,GAAC,CAAF,EAAKC,CAAC,GAACR,GAAG,CAACS,MAAhB,EAAwBF,CAAC,GAACC,CAA1B,EAA6B,EAAED,CAA/B,EAAkC;AAChCS,QAAAA,CAAC,GAAGhB,GAAG,CAACO,CAAD,CAAP;AACAF,QAAAA,CAAC,GAAGW,CAAC,CAACE,KAAN;AACAO,QAAAA,CAAC,GAAGT,CAAC,CAACF,KAAN;AACAY,QAAAA,EAAE,GAAGH,GAAG,CAACjC,OAAO,CAACe,CAAD,CAAR,CAAR;;AACA,YAAIqB,EAAE,GAAG,CAAT,EAAY;AACVb,UAAAA,MAAM,CAACR,CAAD,EAAIoB,CAAJ,EAAOT,CAAC,CAACD,KAAT,CAAN;AACAM,UAAAA,KAAK,CAACO,QAAN,CAAeH,CAAf;AACD;AACF,OA9D4B,CAgE7B;;;AACA,WAAKlB,CAAC,GAAC,CAAF,EAAKC,CAAC,GAACN,IAAI,CAACO,MAAjB,EAAyBF,CAAC,GAACC,CAA3B,EAA8B,EAAED,CAAhC,EAAmC;AACjCS,QAAAA,CAAC,GAAGd,IAAI,CAACK,CAAD,CAAR;AACAkB,QAAAA,CAAC,GAAGT,CAAC,CAACC,MAAN;AACAK,QAAAA,MAAM,CAACK,OAAP,CAAe,UAAStB,CAAT,EAAY;AACzB,cAAIoB,CAAC,CAACpB,CAAD,CAAD,IAAQkB,GAAG,CAACjC,OAAO,CAACe,CAAD,CAAR,CAAH,GAAkB,CAA9B,EAAiC;AAC/BQ,YAAAA,MAAM,CAACR,CAAD,EAAIW,CAAC,CAACF,KAAN,EAAaE,CAAC,CAACD,KAAf,CAAN;AACD;AACF,SAJD;AAKAM,QAAAA,KAAK,CAACO,QAAN,CAAeZ,CAAC,CAACF,KAAjB;AACD,OA1E4B,CA4E7B;AACA;;;AACA,UAAIX,MAAJ,EAAY;AACVkB,QAAAA,KAAK,CAACrB,GAAN,GAAYD,GAAG,CAACU,MAAJ,IAAcR,IAAI,CAACQ,MAAnB,GACRa,MAAM,CAACL,MAAP,CAAc,UAASZ,CAAT,EAAY;AAAE,iBAAOkB,GAAG,CAACjC,OAAO,CAACe,CAAD,CAAR,CAAH,GAAkB,CAAzB;AAA6B,SAAzD,CADQ,GAERiB,MAAM,CAACO,KAAP,EAFJ;AAGD,OAJD,MAIO;AACL,aAAKH,EAAL,IAAWF,GAAX,EAAgBH,KAAK,CAACrB,GAAN,CAAUU,IAAV,CAAec,GAAG,CAACE,EAAD,CAAlB;AACjB;;AAED,aAAOL,KAAP;AACD;AAxHI,GAAP;AA0HD","sourcesContent":["import {ingest, tupleid} from './Tuple';\nimport {array, constant, isFunction} from 'vega-util';\n\nexport function isChangeSet(v) {\n  return v && v.constructor === changeset;\n}\n\nexport default function changeset() {\n  var add = [],  // insert tuples\n      rem = [],  // remove tuples\n      mod = [],  // modify tuples\n      remp = [], // remove by predicate\n      modp = [], // modify by predicate\n      reflow = false;\n\n  return {\n    constructor: changeset,\n    insert: function(t) {\n      var d = array(t), i = 0, n = d.length;\n      for (; i<n; ++i) add.push(d[i]);\n      return this;\n    },\n    remove: function(t) {\n      var a = isFunction(t) ? remp : rem,\n          d = array(t), i = 0, n = d.length;\n      for (; i<n; ++i) a.push(d[i]);\n      return this;\n    },\n    modify: function(t, field, value) {\n      var m = {field: field, value: constant(value)};\n      if (isFunction(t)) {\n        m.filter = t;\n        modp.push(m);\n      } else {\n        m.tuple = t;\n        mod.push(m);\n      }\n      return this;\n    },\n    encode: function(t, set) {\n      if (isFunction(t)) modp.push({filter: t, field: set});\n      else mod.push({tuple: t, field: set});\n      return this;\n    },\n    reflow: function() {\n      reflow = true;\n      return this;\n    },\n    pulse: function(pulse, tuples) {\n      var cur = {}, out = {}, i, n, m, f, t, id;\n\n      // build lookup table of current tuples\n      for (i=0, n=tuples.length; i<n; ++i) {\n        cur[tupleid(tuples[i])] = 1;\n      }\n\n      // process individual tuples to remove\n      for (i=0, n=rem.length; i<n; ++i) {\n        t = rem[i];\n        cur[tupleid(t)] = -1;\n      }\n\n      // process predicate-based removals\n      for (i=0, n=remp.length; i<n; ++i) {\n        f = remp[i];\n        tuples.forEach(function(t) {\n          if (f(t)) cur[tupleid(t)] = -1;\n        });\n      }\n\n      // process all add tuples\n      for (i=0, n=add.length; i<n; ++i) {\n        t = add[i];\n        id = tupleid(t);\n        if (cur[id]) {\n          // tuple already resides in dataset\n          // if flagged for both add and remove, cancel\n          cur[id] = 1;\n        } else {\n          // tuple does not reside in dataset, add\n          pulse.add.push(ingest(add[i]));\n        }\n      }\n\n      // populate pulse rem list\n      for (i=0, n=tuples.length; i<n; ++i) {\n        t = tuples[i];\n        if (cur[tupleid(t)] < 0) pulse.rem.push(t);\n      }\n\n      // modify helper method\n      function modify(t, f, v) {\n        if (v) {\n          t[f] = v(t);\n        } else {\n          pulse.encode = f;\n        }\n        if (!reflow) out[tupleid(t)] = t;\n      }\n\n      // process individual tuples to modify\n      for (i=0, n=mod.length; i<n; ++i) {\n        m = mod[i];\n        t = m.tuple;\n        f = m.field;\n        id = cur[tupleid(t)];\n        if (id > 0) {\n          modify(t, f, m.value);\n          pulse.modifies(f);\n        }\n      }\n\n      // process predicate-based modifications\n      for (i=0, n=modp.length; i<n; ++i) {\n        m = modp[i];\n        f = m.filter;\n        tuples.forEach(function(t) {\n          if (f(t) && cur[tupleid(t)] > 0) {\n            modify(t, m.field, m.value);\n          }\n        });\n        pulse.modifies(m.field);\n      }\n\n      // upon reflow request, populate mod with all non-removed tuples\n      // otherwise, populate mod with modified tuples only\n      if (reflow) {\n        pulse.mod = rem.length || remp.length\n          ? tuples.filter(function(t) { return cur[tupleid(t)] > 0; })\n          : tuples.slice();\n      } else {\n        for (id in out) pulse.mod.push(out[id]);\n      }\n\n      return pulse;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}