{"ast":null,"code":"import { isArray, isString } from 'vega-util';\nimport { getTypedFieldDef, isFieldDef, vgField } from '../../channeldef';\nimport { duplicate, getFirstDefined, hash } from '../../util';\nimport { sortParams } from '../common';\nimport { DataFlowNode } from './dataflow';\n\nfunction getStackByFields(model) {\n  return model.stack.stackBy.reduce((fields, by) => {\n    const fieldDef = by.fieldDef;\n\n    const _field = vgField(fieldDef);\n\n    if (_field) {\n      fields.push(_field);\n    }\n\n    return fields;\n  }, []);\n}\n\nfunction isValidAsArray(as) {\n  return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\n\nexport class StackNode extends DataFlowNode {\n  constructor(parent, stack) {\n    super(parent);\n    this._stack = stack;\n  }\n\n  clone() {\n    return new StackNode(null, duplicate(this._stack));\n  }\n\n  static makeFromTransform(parent, stackTransform) {\n    const {\n      stack,\n      groupby,\n      as,\n      offset = 'zero'\n    } = stackTransform;\n    const sortFields = [];\n    const sortOrder = [];\n\n    if (stackTransform.sort !== undefined) {\n      for (const sortField of stackTransform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n      }\n    }\n\n    const sort = {\n      field: sortFields,\n      order: sortOrder\n    };\n    let normalizedAs;\n\n    if (isValidAsArray(as)) {\n      normalizedAs = as;\n    } else if (isString(as)) {\n      normalizedAs = [as, as + '_end'];\n    } else {\n      normalizedAs = [stackTransform.stack + '_start', stackTransform.stack + '_end'];\n    }\n\n    return new StackNode(parent, {\n      stackField: stack,\n      groupby,\n      offset,\n      sort,\n      facetby: [],\n      as: normalizedAs\n    });\n  }\n\n  static makeFromEncoding(parent, model) {\n    const stackProperties = model.stack;\n    const {\n      encoding\n    } = model;\n\n    if (!stackProperties) {\n      return null;\n    }\n\n    let dimensionFieldDef;\n\n    if (stackProperties.groupbyChannel) {\n      const cDef = encoding[stackProperties.groupbyChannel];\n      dimensionFieldDef = getTypedFieldDef(cDef); // Fair to cast as groupByChannel is always either x or y\n    }\n\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n    let sort;\n\n    if (isArray(orderDef) || isFieldDef(orderDef)) {\n      sort = sortParams(orderDef);\n    } else {\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce((s, field) => {\n        s.field.push(field);\n        s.order.push('descending');\n        return s;\n      }, {\n        field: [],\n        order: []\n      });\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDef,\n      stackField: model.vgField(stackProperties.fieldChannel),\n      facetby: [],\n      stackby,\n      sort,\n      offset: stackProperties.offset,\n      impute: stackProperties.impute,\n      as: [model.vgField(stackProperties.fieldChannel, {\n        suffix: 'start',\n        forAs: true\n      }), model.vgField(stackProperties.fieldChannel, {\n        suffix: 'end',\n        forAs: true\n      })]\n    });\n  }\n\n  get stack() {\n    return this._stack;\n  }\n\n  addDimensions(fields) {\n    this._stack.facetby.push(...fields);\n  }\n\n  dependentFields() {\n    const out = new Set();\n    out.add(this._stack.stackField);\n    this.getGroupbyFields().forEach(f => out.add(f));\n\n    this._stack.facetby.forEach(f => out.add(f));\n\n    this._stack.sort.field.forEach(f => out.add(f));\n\n    return out;\n  }\n\n  producedFields() {\n    return new Set(this._stack.as);\n  }\n\n  hash() {\n    return `Stack ${hash(this._stack)}`;\n  }\n\n  getGroupbyFields() {\n    const {\n      dimensionFieldDef,\n      impute,\n      groupby\n    } = this._stack;\n\n    if (dimensionFieldDef) {\n      if (dimensionFieldDef.bin) {\n        if (impute) {\n          // For binned group by field with impute, we calculate bin_mid\n          // as we cannot impute two fields simultaneously\n          return [vgField(dimensionFieldDef, {\n            binSuffix: 'mid'\n          })];\n        }\n\n        return [// For binned group by field without impute, we need both bin (start) and bin_end\n        vgField(dimensionFieldDef, {}), vgField(dimensionFieldDef, {\n          binSuffix: 'end'\n        })];\n      }\n\n      return [vgField(dimensionFieldDef)];\n    }\n\n    return groupby !== null && groupby !== void 0 ? groupby : [];\n  }\n\n  assemble() {\n    const transform = [];\n    const {\n      facetby,\n      dimensionFieldDef,\n      stackField: field,\n      stackby,\n      sort,\n      offset,\n      impute,\n      as\n    } = this._stack; // Impute\n\n    if (impute && dimensionFieldDef) {\n      const {\n        band = 0.5,\n        bin\n      } = dimensionFieldDef;\n\n      if (bin) {\n        // As we can only impute one field at a time, we need to calculate\n        // mid point for a binned field\n        transform.push({\n          type: 'formula',\n          expr: `${band}*` + vgField(dimensionFieldDef, {\n            expr: 'datum'\n          }) + `+${1 - band}*` + vgField(dimensionFieldDef, {\n            expr: 'datum',\n            binSuffix: 'end'\n          }),\n          as: vgField(dimensionFieldDef, {\n            binSuffix: 'mid',\n            forAs: true\n          })\n        });\n      }\n\n      transform.push({\n        type: 'impute',\n        field,\n        groupby: [...stackby, ...facetby],\n        key: vgField(dimensionFieldDef, {\n          binSuffix: 'mid'\n        }),\n        method: 'value',\n        value: 0\n      });\n    } // Stack\n\n\n    transform.push({\n      type: 'stack',\n      groupby: [...this.getGroupbyFields(), ...facetby],\n      field,\n      sort,\n      as,\n      offset\n    });\n    return transform;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/stack.ts"],"names":[],"mappings":"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","sourcesContent":["import {Transforms as VgTransform} from 'vega';\nimport {isArray, isString} from 'vega-util';\nimport {FieldName, getTypedFieldDef, isFieldDef, PositionFieldDef, vgField} from '../../channeldef';\nimport {SortFields, SortOrder} from '../../sort';\nimport {StackOffset} from '../../stack';\nimport {StackTransform} from '../../transform';\nimport {duplicate, getFirstDefined, hash} from '../../util';\nimport {sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nfunction getStackByFields(model: UnitModel): string[] {\n  return model.stack.stackBy.reduce((fields, by) => {\n    const fieldDef = by.fieldDef;\n\n    const _field = vgField(fieldDef);\n    if (_field) {\n      fields.push(_field);\n    }\n    return fields;\n  }, [] as string[]);\n}\n\nexport interface StackComponent {\n  /**\n   * Faceted field.\n   */\n  facetby: string[];\n\n  dimensionFieldDef?: PositionFieldDef<string>;\n\n  /**\n   * Stack measure's field. Used in makeFromEncoding.\n   */\n  stackField: string;\n\n  /**\n   * Level of detail fields for each level in the stacked charts such as color or detail.\n   * Used in makeFromEncoding.\n   */\n  stackby?: string[];\n\n  /**\n   * Field that determines order of levels in the stacked charts.\n   * Used in both but optional in transform.\n   */\n  sort: SortFields;\n\n  /** Mode for stacking marks.\n   */\n  offset: StackOffset;\n\n  /**\n   * Whether to impute the data before stacking. Used only in makeFromEncoding.\n   */\n  impute?: boolean;\n\n  /**\n   * The data fields to group by.\n   */\n  groupby?: FieldName[];\n  /**\n   * Output field names of each stack field.\n   */\n  as: [FieldName, FieldName];\n}\n\nfunction isValidAsArray(as: string[] | string): as is string[] {\n  return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\n\nexport class StackNode extends DataFlowNode {\n  private _stack: StackComponent;\n\n  public clone() {\n    return new StackNode(null, duplicate(this._stack));\n  }\n\n  constructor(parent: DataFlowNode, stack: StackComponent) {\n    super(parent);\n\n    this._stack = stack;\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, stackTransform: StackTransform) {\n    const {stack, groupby, as, offset = 'zero'} = stackTransform;\n\n    const sortFields: string[] = [];\n    const sortOrder: SortOrder[] = [];\n    if (stackTransform.sort !== undefined) {\n      for (const sortField of stackTransform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n      }\n    }\n    const sort: SortFields = {\n      field: sortFields,\n      order: sortOrder\n    };\n    let normalizedAs: [string, string];\n    if (isValidAsArray(as)) {\n      normalizedAs = as;\n    } else if (isString(as)) {\n      normalizedAs = [as, as + '_end'];\n    } else {\n      normalizedAs = [stackTransform.stack + '_start', stackTransform.stack + '_end'];\n    }\n\n    return new StackNode(parent, {\n      stackField: stack,\n      groupby,\n      offset,\n      sort,\n      facetby: [],\n      as: normalizedAs\n    });\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel) {\n    const stackProperties = model.stack;\n    const {encoding} = model;\n\n    if (!stackProperties) {\n      return null;\n    }\n\n    let dimensionFieldDef: PositionFieldDef<string>;\n    if (stackProperties.groupbyChannel) {\n      const cDef = encoding[stackProperties.groupbyChannel];\n      dimensionFieldDef = getTypedFieldDef(cDef) as PositionFieldDef<string>; // Fair to cast as groupByChannel is always either x or y\n    }\n\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n\n    let sort: SortFields;\n    if (isArray(orderDef) || isFieldDef(orderDef)) {\n      sort = sortParams(orderDef);\n    } else {\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce(\n        (s, field) => {\n          s.field.push(field);\n          s.order.push('descending');\n          return s;\n        },\n        {field: [], order: []}\n      );\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDef,\n      stackField: model.vgField(stackProperties.fieldChannel),\n      facetby: [],\n      stackby,\n      sort,\n      offset: stackProperties.offset,\n      impute: stackProperties.impute,\n      as: [\n        model.vgField(stackProperties.fieldChannel, {suffix: 'start', forAs: true}),\n        model.vgField(stackProperties.fieldChannel, {suffix: 'end', forAs: true})\n      ]\n    });\n  }\n\n  get stack(): StackComponent {\n    return this._stack;\n  }\n\n  public addDimensions(fields: string[]) {\n    this._stack.facetby.push(...fields);\n  }\n\n  public dependentFields() {\n    const out = new Set<string>();\n\n    out.add(this._stack.stackField);\n\n    this.getGroupbyFields().forEach(f => out.add(f));\n    this._stack.facetby.forEach(f => out.add(f));\n    this._stack.sort.field.forEach(f => out.add(f));\n\n    return out;\n  }\n\n  public producedFields() {\n    return new Set(this._stack.as);\n  }\n\n  public hash() {\n    return `Stack ${hash(this._stack)}`;\n  }\n\n  private getGroupbyFields() {\n    const {dimensionFieldDef, impute, groupby} = this._stack;\n    if (dimensionFieldDef) {\n      if (dimensionFieldDef.bin) {\n        if (impute) {\n          // For binned group by field with impute, we calculate bin_mid\n          // as we cannot impute two fields simultaneously\n          return [vgField(dimensionFieldDef, {binSuffix: 'mid'})];\n        }\n        return [\n          // For binned group by field without impute, we need both bin (start) and bin_end\n          vgField(dimensionFieldDef, {}),\n          vgField(dimensionFieldDef, {binSuffix: 'end'})\n        ];\n      }\n      return [vgField(dimensionFieldDef)];\n    }\n    return groupby ?? [];\n  }\n\n  public assemble(): VgTransform[] {\n    const transform: VgTransform[] = [];\n    const {facetby, dimensionFieldDef, stackField: field, stackby, sort, offset, impute, as} = this._stack;\n\n    // Impute\n    if (impute && dimensionFieldDef) {\n      const {band = 0.5, bin} = dimensionFieldDef;\n      if (bin) {\n        // As we can only impute one field at a time, we need to calculate\n        // mid point for a binned field\n        transform.push({\n          type: 'formula',\n          expr:\n            `${band}*` +\n            vgField(dimensionFieldDef, {expr: 'datum'}) +\n            `+${1 - band}*` +\n            vgField(dimensionFieldDef, {expr: 'datum', binSuffix: 'end'}),\n          as: vgField(dimensionFieldDef, {binSuffix: 'mid', forAs: true})\n        });\n      }\n\n      transform.push({\n        type: 'impute',\n        field,\n        groupby: [...stackby, ...facetby],\n        key: vgField(dimensionFieldDef, {binSuffix: 'mid'}),\n        method: 'value',\n        value: 0\n      });\n    }\n\n    // Stack\n    transform.push({\n      type: 'stack',\n      groupby: [...this.getGroupbyFields(), ...facetby],\n      field,\n      sort,\n      as,\n      offset\n    });\n\n    return transform;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}