{"ast":null,"code":"import { Platform } from '@unimodules/core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport URL from 'url-parse';\nimport AssetSourceResolver from './AssetSourceResolver';\nimport { manifestBaseUrl, getManifest } from './PlatformUtils'; // Fast lookup check if asset map has any overrides in the manifest\n\nconst assetMapOverride = getManifest().assetMapOverride;\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\n\nexport function selectAssetSource(meta) {\n  // Override with the asset map in manifest if available\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = { ...meta,\n      ...assetMapOverride[meta.hash]\n    };\n  } // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n\n\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex(s => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash; // Allow asset processors to directly provide the URL to load\n\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n\n  if (uri) {\n    return {\n      uri: resolveUri(uri),\n      hash\n    };\n  } // Check if the assetUrl was overridden in the manifest\n\n\n  const assetUrlOverride = getManifest().assetUrlOverride;\n\n  if (assetUrlOverride) {\n    const uri = path.join(assetUrlOverride, hash);\n    return {\n      uri: resolveUri(uri),\n      hash\n    };\n  }\n\n  const fileScale = scale === 1 ? '' : `@${scale}x`;\n  const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n  const suffix = `/${encodeURIComponent(meta.name)}${fileScale}${fileExtension}?platform=${encodeURIComponent(Platform.OS)}&hash=${encodeURIComponent(meta.hash)}`; // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix;\n    return {\n      uri,\n      hash\n    };\n  } // For assets during development, we use the development server's URL origin\n\n\n  if (getManifest().developer) {\n    const baseUrl = new URL(getManifest().bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return {\n      uri: baseUrl.href,\n      hash\n    };\n  } // Production CDN URIs are based on each asset file hash\n\n\n  return {\n    uri: `https://d1wp6m56sqw74a.cloudfront.net/~assets/${encodeURIComponent(hash)}`,\n    hash\n  };\n}\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\n\nexport function resolveUri(uri) {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n\n  const {\n    protocol\n  } = new URL(uri);\n\n  if (protocol !== '') {\n    return uri;\n  }\n\n  const baseUrl = new URL(manifestBaseUrl);\n  const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}","map":{"version":3,"sources":["../src/AssetSources.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform } from '@unimodules/core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport URL from 'url-parse';\nimport AssetSourceResolver from './AssetSourceResolver';\n\nimport { manifestBaseUrl, getManifest } from './PlatformUtils';\n\nexport type AssetMetadata = {\n  hash: string;\n  name: string;\n  type: string;\n  width?: number;\n  height?: number;\n  scales: number[];\n  httpServerLocation: string;\n  uri?: string;\n  fileHashes?: string[];\n  fileUris?: string[];\n};\n\nexport type AssetSource = {\n  uri: string;\n  hash: string;\n};\n\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = getManifest().assetMapOverride;\n\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nexport function selectAssetSource(meta: AssetMetadata): AssetSource {\n  // Override with the asset map in manifest if available\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = { ...meta, ...assetMapOverride[meta.hash] };\n  }\n\n  // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex(s => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n\n  // Allow asset processors to directly provide the URL to load\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  if (uri) {\n    return { uri: resolveUri(uri), hash };\n  }\n\n  // Check if the assetUrl was overridden in the manifest\n  const assetUrlOverride = getManifest().assetUrlOverride;\n  if (assetUrlOverride) {\n    const uri = path.join(assetUrlOverride, hash);\n    return { uri: resolveUri(uri), hash };\n  }\n\n  const fileScale = scale === 1 ? '' : `@${scale}x`;\n  const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n  const suffix = `/${encodeURIComponent(\n    meta.name\n  )}${fileScale}${fileExtension}?platform=${encodeURIComponent(\n    Platform.OS\n  )}&hash=${encodeURIComponent(meta.hash)}`;\n\n  // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix;\n    return { uri, hash };\n  }\n\n  // For assets during development, we use the development server's URL origin\n  if (getManifest().developer) {\n    const baseUrl = new URL(getManifest().bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return { uri: baseUrl.href, hash };\n  }\n\n  // Production CDN URIs are based on each asset file hash\n  return {\n    uri: `https://d1wp6m56sqw74a.cloudfront.net/~assets/${encodeURIComponent(hash)}`,\n    hash,\n  };\n}\n\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nexport function resolveUri(uri: string): string {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n\n  const { protocol } = new URL(uri);\n  if (protocol !== '') {\n    return uri;\n  }\n\n  const baseUrl = new URL(manifestBaseUrl);\n  const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}