{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isArray } from 'vega-util';\nimport { isArgmaxDef, isArgminDef } from './aggregate';\nimport { isBinned, isBinning } from './bin';\nimport { CHANNELS, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, supportMark } from './channel';\nimport { binRequiresRange, getFieldDef, getGuide, getTypedFieldDef, hasConditionalFieldDef, isConditionalDef, isFieldDef, isTypedFieldDef, isValueDef, normalize, normalizeFieldDef, title, vgField } from './channeldef';\nimport * as log from './log';\nimport { TEMPORAL } from './type';\nimport { keys, some } from './util';\nexport function channelHasField(encoding, channel) {\n  const channelDef = encoding && encoding[channel];\n\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n    }\n  }\n\n  return false;\n}\nexport function isAggregate(encoding) {\n  return some(CHANNELS, channel => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n\n      if (isArray(channelDef)) {\n        return some(channelDef, fieldDef => !!fieldDef.aggregate);\n      } else {\n        const fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n\n    return false;\n  });\n}\nexport function extractTransformsFromEncoding(oldEncoding, config) {\n  const groupby = [];\n  const bins = [];\n  const timeUnits = [];\n  const aggregate = [];\n  const encoding = {};\n  forEach(oldEncoding, (channelDef, channel) => {\n    // Extract potential embedded transformations along with remaining properties\n    if (isFieldDef(channelDef)) {\n      const {\n        field,\n        aggregate: aggOp,\n        timeUnit,\n        bin\n      } = channelDef,\n            remaining = __rest(channelDef, [\"field\", \"aggregate\", \"timeUnit\", \"bin\"]);\n\n      if (aggOp || timeUnit || bin) {\n        const guide = getGuide(channelDef);\n        const isTitleDefined = guide && guide.title;\n        let newField = vgField(channelDef, {\n          forAs: true\n        });\n        const newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : {\n          title: title(channelDef, config, {\n            allowDisabling: true\n          })\n        }), remaining), {\n          // Always overwrite field\n          field: newField\n        });\n        const isPositionChannel = channel === 'x' || channel === 'y';\n\n        if (aggOp) {\n          let op;\n\n          if (isArgmaxDef(aggOp)) {\n            op = 'argmax';\n            newField = vgField({\n              op: 'argmax',\n              field: aggOp.argmax\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (isArgminDef(aggOp)) {\n            op = 'argmin';\n            newField = vgField({\n              op: 'argmin',\n              field: aggOp.argmin\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n            op = aggOp;\n          }\n\n          if (op) {\n            const aggregateEntry = {\n              op,\n              as: newField\n            };\n\n            if (field) {\n              aggregateEntry.field = field;\n            }\n\n            aggregate.push(aggregateEntry);\n          }\n        } else {\n          groupby.push(newField);\n\n          if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n            bins.push({\n              bin,\n              field,\n              as: newField\n            }); // Add additional groupbys for range and end of bins\n\n            groupby.push(vgField(channelDef, {\n              binSuffix: 'end'\n            }));\n\n            if (binRequiresRange(channelDef, channel)) {\n              groupby.push(vgField(channelDef, {\n                binSuffix: 'range'\n              }));\n            } // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n\n\n            if (isPositionChannel) {\n              const secondaryChannel = {\n                field: newField + '_end'\n              };\n              encoding[channel + '2'] = secondaryChannel;\n            }\n\n            newFieldDef.bin = 'binned';\n\n            if (!isSecondaryRangeChannel(channel)) {\n              newFieldDef['type'] = 'quantitative';\n            }\n          } else if (timeUnit) {\n            timeUnits.push({\n              timeUnit,\n              field,\n              as: newField\n            }); // define the format type for later compilation\n\n            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n\n            if (formatType) {\n              if (channel === 'text' || channel === 'tooltip') {\n                newFieldDef['formatType'] = formatType;\n              } else if (isNonPositionScaleChannel(channel)) {\n                newFieldDef['legend'] = Object.assign({\n                  formatType\n                }, newFieldDef['legend']);\n              } else if (isPositionChannel) {\n                newFieldDef['axis'] = Object.assign({\n                  formatType\n                }, newFieldDef['axis']);\n              }\n            }\n          }\n        } // now the field should refer to post-transformed field instead\n\n\n        encoding[channel] = newFieldDef;\n      } else {\n        groupby.push(field);\n        encoding[channel] = oldEncoding[channel];\n      }\n    } else {\n      // For value def, just copy\n      encoding[channel] = oldEncoding[channel];\n    }\n  });\n  return {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding\n  };\n}\nexport function markChannelCompatible(encoding, channel, mark) {\n  const markSupported = supportMark(channel, mark);\n\n  if (!markSupported) {\n    return false;\n  } else if (markSupported === 'binned') {\n    const primaryFieldDef = encoding[channel === 'x2' ? 'x' : 'y']; // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function normalizeEncoding(encoding, markDef) {\n  const mark = markDef.type;\n  return keys(encoding).reduce((normalizedEncoding, channel) => {\n    var _a;\n\n    if (!isChannel(channel)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(channel));\n      return normalizedEncoding;\n    }\n\n    if (!markChannelCompatible(encoding, channel, mark)) {\n      // Drop unsupported channel\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      return normalizedEncoding;\n    } // Drop line's size if the field is aggregated.\n\n\n    if (channel === 'size' && mark === 'line') {\n      const fieldDef = getTypedFieldDef(encoding[channel]);\n\n      if ((_a = fieldDef) === null || _a === void 0 ? void 0 : _a.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        return normalizedEncoding;\n      }\n    } // Drop color if either fill or stroke is specified\n\n\n    if (channel === 'color' && (markDef.filled ? 'fill' in encoding : 'stroke' in encoding)) {\n      log.warn(log.message.droppingColor('encoding', {\n        fill: 'fill' in encoding,\n        stroke: 'stroke' in encoding\n      }));\n      return normalizedEncoding;\n    }\n\n    const channelDef = encoding[channel];\n\n    if (channel === 'detail' || channel === 'order' && !isArray(channelDef) && !isValueDef(channelDef) || channel === 'tooltip' && isArray(channelDef)) {\n      if (channelDef) {\n        // Array of fieldDefs for detail channel (or production rule)\n        normalizedEncoding[channel] = (isArray(channelDef) ? channelDef : [channelDef]).reduce((defs, fieldDef) => {\n          if (!isFieldDef(fieldDef)) {\n            log.warn(log.message.emptyFieldDef(fieldDef, channel));\n          } else {\n            defs.push(normalizeFieldDef(fieldDef, channel));\n          }\n\n          return defs;\n        }, []);\n      }\n    } else {\n      if (channel === 'tooltip' && channelDef === null) {\n        // Preserve null so we can use it to disable tooltip\n        normalizedEncoding[channel] = null;\n      } else if (!isFieldDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef)) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        return normalizedEncoding;\n      }\n\n      normalizedEncoding[channel] = normalize(channelDef, channel);\n    }\n\n    return normalizedEncoding;\n  }, {});\n}\nexport function fieldDefs(encoding) {\n  const arr = [];\n\n  for (const channel of keys(encoding)) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      const channelDefArray = isArray(channelDef) ? channelDef : [channelDef];\n\n      for (const def of channelDefArray) {\n        if (isFieldDef(def)) {\n          arr.push(def);\n        } else if (hasConditionalFieldDef(def)) {\n          arr.push(def.condition);\n        }\n      }\n    }\n  }\n\n  return arr;\n}\nexport function forEach(mapping, f, thisArg) {\n  if (!mapping) {\n    return;\n  }\n\n  for (const channel of keys(mapping)) {\n    const el = mapping[channel];\n\n    if (isArray(el)) {\n      el.forEach(channelDef => {\n        f.call(thisArg, channelDef, channel);\n      });\n    } else {\n      f.call(thisArg, el, channel);\n    }\n  }\n}\nexport function reduce(mapping, f, init, thisArg) {\n  if (!mapping) {\n    return init;\n  }\n\n  return keys(mapping).reduce((r, channel) => {\n    const map = mapping[channel];\n\n    if (isArray(map)) {\n      return map.reduce((r1, channelDef) => {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n/**\n * Returns list of path grouping fields for the given encoding\n */\n\nexport function pathGroupingFields(mark, encoding) {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group\n      case 'x':\n      case 'y':\n      case 'href':\n      case 'url':\n      case 'x2':\n      case 'y2': // falls through\n\n      case 'latitude':\n      case 'longitude':\n      case 'latitude2':\n      case 'longitude2': // TODO: case 'cursor':\n      // text, shape, shouldn't be a part of line/trail/area [falls through]\n\n      case 'text':\n      case 'shape': // falls through\n      // tooltip fields should not be added to group by [falls through]\n\n      case 'tooltip':\n        return details;\n\n      case 'order':\n        // order should not group line / trail\n        if (mark === 'line' || mark === 'trail') {\n          return details;\n        }\n\n      // but order should group area for stacking (falls through)\n\n      case 'detail':\n      case 'key':\n        {\n          const channelDef = encoding[channel];\n\n          if (isArray(channelDef) || isFieldDef(channelDef)) {\n            (isArray(channelDef) ? channelDef : [channelDef]).forEach(fieldDef => {\n              if (!fieldDef.aggregate) {\n                details.push(vgField(fieldDef, {}));\n              }\n            });\n          }\n\n          return details;\n        }\n\n      case 'size':\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n\n      // For line, size should group lines.\n      // falls through\n\n      case 'color':\n      case 'fill':\n      case 'stroke':\n      case 'opacity':\n      case 'fillOpacity':\n      case 'strokeOpacity':\n      case 'strokeWidth':\n        {\n          // TODO strokeDashOffset:\n          // falls through\n          const fieldDef = getTypedFieldDef(encoding[channel]);\n\n          if (fieldDef && !fieldDef.aggregate) {\n            details.push(vgField(fieldDef, {}));\n          }\n\n          return details;\n        }\n    }\n  }, []);\n}","map":{"version":3,"sources":["../../src/encoding.ts"],"names":[],"mappings":"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","sourcesContent":["import {AggregateOp} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isArgmaxDef, isArgminDef} from './aggregate';\nimport {isBinned, isBinning} from './bin';\nimport {Channel, CHANNELS, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, supportMark} from './channel';\nimport {\n  binRequiresRange,\n  ChannelDef,\n  ColorGradientFieldDefWithCondition,\n  ColorGradientValueDefWithCondition,\n  Field,\n  FieldDef,\n  FieldDefWithoutScale,\n  getFieldDef,\n  getGuide,\n  getTypedFieldDef,\n  hasConditionalFieldDef,\n  isConditionalDef,\n  isFieldDef,\n  isTypedFieldDef,\n  isValueDef,\n  LatLongFieldDef,\n  normalize,\n  normalizeFieldDef,\n  NumericFieldDefWithCondition,\n  NumericValueDefWithCondition,\n  OrderFieldDef,\n  PositionFieldDef,\n  SecondaryFieldDef,\n  ShapeFieldDefWithCondition,\n  ShapeValueDefWithCondition,\n  StringFieldDef,\n  StringFieldDefWithCondition,\n  StringValueDefWithCondition,\n  TextFieldDefWithCondition,\n  TextValueDefWithCondition,\n  title,\n  TypedFieldDef,\n  ValueDef,\n  ValueOrGradientOrText,\n  vgField\n} from './channeldef';\nimport {Config} from './config';\nimport * as log from './log';\nimport {Mark, MarkDef} from './mark';\nimport {EncodingFacetMapping} from './spec/facet';\nimport {AggregatedFieldDef, BinTransform, TimeUnitTransform} from './transform';\nimport {TEMPORAL} from './type';\nimport {keys, some} from './util';\n\nexport interface Encoding<F extends Field> {\n  /**\n   * X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n   *\n   * The `value` of this channel can be a number or a string `\"width\"` for the width of the plot.\n   */\n  x?: PositionFieldDef<F> | ValueDef<number | 'width'>;\n\n  /**\n   * Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n   *\n   * The `value` of this channel can be a number or a string `\"height\"` for the height of the plot.\n   */\n  y?: PositionFieldDef<F> | ValueDef<number | 'height'>;\n\n  /**\n   * X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   *\n   * The `value` of this channel can be a number or a string `\"width\"` for the width of the plot.\n   */\n  // TODO: Ham need to add default behavior\n  // `x2` cannot have type as it should have the same type as `x`\n  x2?: SecondaryFieldDef<F> | ValueDef<number | 'width'>;\n\n  /**\n   * Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   *\n   * The `value` of this channel can be a number or a string `\"height\"` for the height of the plot.\n   */\n  // TODO: Ham need to add default behavior\n  // `y2` cannot have type as it should have the same type as `y`\n  y2?: SecondaryFieldDef<F> | ValueDef<number | 'height'>;\n\n  /**\n   * Longitude position of geographically projected marks.\n   */\n  longitude?: LatLongFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Latitude position of geographically projected marks.\n   */\n  latitude?: LatLongFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Longitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  // `longitude2` cannot have type as it should have the same type as `longitude`\n  longitude2?: SecondaryFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Latitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  // `latitude2` cannot have type as it should have the same type as `latitude`\n  latitude2?: SecondaryFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Color of the marks – either fill or stroke color based on  the `filled` property of mark definition.\n   * By default, `color` represents fill color for `\"area\"`, `\"bar\"`, `\"tick\"`,\n   * `\"text\"`, `\"trail\"`, `\"circle\"`, and `\"square\"` / stroke color for `\"line\"` and `\"point\"`.\n   *\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_\n   * 1) For fine-grained control over both fill and stroke colors of the marks, please use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified.\n   * 2) See the scale documentation for more information about customizing [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).\n   */\n  color?: ColorGradientFieldDefWithCondition<F> | ColorGradientValueDefWithCondition<F>;\n\n  /**\n   * Fill color of the marks.\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_ The `fill` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified.\n   */\n  fill?: ColorGradientFieldDefWithCondition<F> | ColorGradientValueDefWithCondition<F>;\n\n  /**\n   * Stroke color of the marks.\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified.\n   */\n\n  stroke?: ColorGradientFieldDefWithCondition<F> | ColorGradientValueDefWithCondition<F>;\n\n  /**\n   * Opacity of the marks.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `opacity` property.\n   */\n  opacity?: NumericFieldDefWithCondition<F> | NumericValueDefWithCondition<F>;\n\n  /**\n   * Fill opacity of the marks.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `fillOpacity` property.\n   */\n  fillOpacity?: NumericFieldDefWithCondition<F> | NumericValueDefWithCondition<F>;\n\n  /**\n   * Stroke opacity of the marks.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `strokeOpacity` property.\n   */\n  strokeOpacity?: NumericFieldDefWithCondition<F> | NumericValueDefWithCondition<F>;\n\n  /**\n   * Stroke width of the marks.\n   *\n   * __Default value:__ If undefined, the default stroke width depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `strokeWidth` property.\n   */\n  strokeWidth?: NumericFieldDefWithCondition<F> | NumericValueDefWithCondition<F>;\n\n  /**\n   * Size of the mark.\n   * - For `\"point\"`, `\"square\"` and `\"circle\"`, – the symbol size, or pixel area of the mark.\n   * - For `\"bar\"` and `\"tick\"` – the bar and tick's size.\n   * - For `\"text\"` – the text's font size.\n   * - Size is unsupported for `\"line\"`, `\"area\"`, and `\"rect\"`. (Use `\"trail\"` instead of line with varying size)\n   */\n  size?: NumericFieldDefWithCondition<F> | NumericValueDefWithCondition<F>;\n\n  /**\n   * Shape of the mark.\n   *\n   * 1. For `point` marks the supported values include:\n   *   - plotting shapes: `\"circle\"`, `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, `\"triangle-down\"`, `\"triangle-right\"`, or `\"triangle-left\"`.\n   *   - the line symbol `\"stroke\"`\n   *   - centered directional shapes `\"arrow\"`, `\"wedge\"`, or `\"triangle\"`\n   *   - a custom [SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct sizing, custom shape paths should be defined within a square bounding box with coordinates ranging from -1 to 1 along both the x and y dimensions.)\n   *\n   * 2. For `geoshape` marks it should be a field definition of the geojson data\n   *\n   * __Default value:__ If undefined, the default shape depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape` property. (`\"circle\"` if unset.)\n   */\n  shape?: ShapeFieldDefWithCondition<F> | ShapeValueDefWithCondition<F>;\n  /**\n   * Additional levels of detail for grouping data in aggregate views and\n   * in line, trail, and area marks without mapping data to a specific visual channel.\n   */\n  detail?: FieldDefWithoutScale<F> | FieldDefWithoutScale<F>[];\n\n  /**\n   * A data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key channel to enable object constancy for transitions over dynamic data.\n   */\n  key?: FieldDefWithoutScale<F>;\n\n  /**\n   * Text of the `text` mark.\n   */\n  text?: TextFieldDefWithCondition<F> | TextValueDefWithCondition<F>;\n\n  /**\n   * The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).\n   *\n   * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite.\n   */\n  tooltip?: StringFieldDefWithCondition<F> | StringValueDefWithCondition<F> | StringFieldDef<F>[] | null;\n\n  /**\n   * A URL to load upon mouse click.\n   */\n  href?: StringFieldDefWithCondition<F> | StringValueDefWithCondition<F>;\n\n  /**\n   * The URL of an image mark.\n   */\n  url?: StringFieldDefWithCondition<F> | StringValueDefWithCondition<F>;\n\n  /**\n   * Order of the marks.\n   * - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).\n   * - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{\"value\": null}` makes the line marks use the original order in the data sources.\n   * - Otherwise, this `order` channel encodes layer order of the marks.\n   *\n   * __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.\n   */\n  order?: OrderFieldDef<F> | OrderFieldDef<F>[] | ValueDef<number>;\n}\n\nexport interface EncodingWithFacet<F extends Field> extends Encoding<F>, EncodingFacetMapping<F> {}\n\nexport function channelHasField<F extends Field>(encoding: EncodingWithFacet<F>, channel: Channel): boolean {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef<Field, ValueOrGradientOrText>(channelDef);\n    }\n  }\n  return false;\n}\n\nexport function isAggregate(encoding: EncodingWithFacet<Field>) {\n  return some(CHANNELS, channel => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      if (isArray(channelDef)) {\n        return some(channelDef, fieldDef => !!fieldDef.aggregate);\n      } else {\n        const fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n    return false;\n  });\n}\n\nexport function extractTransformsFromEncoding(oldEncoding: Encoding<Field>, config: Config) {\n  const groupby: string[] = [];\n  const bins: BinTransform[] = [];\n  const timeUnits: TimeUnitTransform[] = [];\n  const aggregate: AggregatedFieldDef[] = [];\n  const encoding: Encoding<string> = {};\n\n  forEach(oldEncoding, (channelDef, channel) => {\n    // Extract potential embedded transformations along with remaining properties\n    if (isFieldDef(channelDef)) {\n      const {field, aggregate: aggOp, timeUnit, bin, ...remaining} = channelDef;\n      if (aggOp || timeUnit || bin) {\n        const guide = getGuide(channelDef);\n        const isTitleDefined = guide && guide.title;\n        let newField = vgField(channelDef, {forAs: true});\n        const newFieldDef: FieldDef<string> = {\n          // Only add title if it doesn't exist\n          ...(isTitleDefined ? [] : {title: title(channelDef, config, {allowDisabling: true})}),\n          ...remaining,\n          // Always overwrite field\n          field: newField\n        };\n        const isPositionChannel: boolean = channel === 'x' || channel === 'y';\n\n        if (aggOp) {\n          let op: AggregateOp;\n\n          if (isArgmaxDef(aggOp)) {\n            op = 'argmax';\n            newField = vgField({op: 'argmax', field: aggOp.argmax}, {forAs: true});\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (isArgminDef(aggOp)) {\n            op = 'argmin';\n            newField = vgField({op: 'argmin', field: aggOp.argmin}, {forAs: true});\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n            op = aggOp;\n          }\n\n          if (op) {\n            const aggregateEntry: AggregatedFieldDef = {\n              op,\n              as: newField\n            };\n            if (field) {\n              aggregateEntry.field = field;\n            }\n            aggregate.push(aggregateEntry);\n          }\n        } else {\n          groupby.push(newField);\n          if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n            bins.push({bin, field, as: newField});\n            // Add additional groupbys for range and end of bins\n            groupby.push(vgField(channelDef, {binSuffix: 'end'}));\n            if (binRequiresRange(channelDef, channel)) {\n              groupby.push(vgField(channelDef, {binSuffix: 'range'}));\n            }\n            // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n            if (isPositionChannel) {\n              const secondaryChannel: SecondaryFieldDef<string> = {\n                field: newField + '_end'\n              };\n              encoding[channel + '2'] = secondaryChannel;\n            }\n            newFieldDef.bin = 'binned';\n            if (!isSecondaryRangeChannel(channel)) {\n              newFieldDef['type'] = 'quantitative';\n            }\n          } else if (timeUnit) {\n            timeUnits.push({timeUnit, field, as: newField});\n\n            // define the format type for later compilation\n            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n            if (formatType) {\n              if (channel === 'text' || channel === 'tooltip') {\n                newFieldDef['formatType'] = formatType;\n              } else if (isNonPositionScaleChannel(channel)) {\n                newFieldDef['legend'] = {\n                  formatType,\n                  ...newFieldDef['legend']\n                };\n              } else if (isPositionChannel) {\n                newFieldDef['axis'] = {\n                  formatType,\n                  ...newFieldDef['axis']\n                };\n              }\n            }\n          }\n        }\n        // now the field should refer to post-transformed field instead\n        encoding[channel] = newFieldDef;\n      } else {\n        groupby.push(field);\n        encoding[channel] = oldEncoding[channel];\n      }\n    } else {\n      // For value def, just copy\n      encoding[channel] = oldEncoding[channel];\n    }\n  });\n\n  return {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding\n  };\n}\n\nexport function markChannelCompatible(encoding: Encoding<string>, channel: Channel, mark: Mark) {\n  const markSupported = supportMark(channel, mark);\n  if (!markSupported) {\n    return false;\n  } else if (markSupported === 'binned') {\n    const primaryFieldDef = encoding[channel === 'x2' ? 'x' : 'y'];\n\n    // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function normalizeEncoding(encoding: Encoding<string>, markDef: MarkDef): Encoding<string> {\n  const mark = markDef.type;\n\n  return keys(encoding).reduce((normalizedEncoding: Encoding<string>, channel: Channel | string) => {\n    if (!isChannel(channel)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(channel));\n      return normalizedEncoding;\n    }\n\n    if (!markChannelCompatible(encoding, channel, mark)) {\n      // Drop unsupported channel\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      return normalizedEncoding;\n    }\n\n    // Drop line's size if the field is aggregated.\n    if (channel === 'size' && mark === 'line') {\n      const fieldDef = getTypedFieldDef(encoding[channel]);\n      if (fieldDef?.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        return normalizedEncoding;\n      }\n    }\n\n    // Drop color if either fill or stroke is specified\n\n    if (channel === 'color' && (markDef.filled ? 'fill' in encoding : 'stroke' in encoding)) {\n      log.warn(log.message.droppingColor('encoding', {fill: 'fill' in encoding, stroke: 'stroke' in encoding}));\n      return normalizedEncoding;\n    }\n\n    const channelDef = encoding[channel];\n    if (\n      channel === 'detail' ||\n      (channel === 'order' && !isArray(channelDef) && !isValueDef(channelDef)) ||\n      (channel === 'tooltip' && isArray(channelDef))\n    ) {\n      if (channelDef) {\n        // Array of fieldDefs for detail channel (or production rule)\n        (normalizedEncoding[channel] as any) = (isArray(channelDef) ? channelDef : [channelDef]).reduce(\n          (defs: FieldDef<string>[], fieldDef: FieldDef<string>) => {\n            if (!isFieldDef(fieldDef)) {\n              log.warn(log.message.emptyFieldDef(fieldDef, channel));\n            } else {\n              defs.push(normalizeFieldDef(fieldDef, channel));\n            }\n            return defs;\n          },\n          []\n        );\n      }\n    } else {\n      if (channel === 'tooltip' && channelDef === null) {\n        // Preserve null so we can use it to disable tooltip\n        normalizedEncoding[channel] = null;\n      } else if (!isFieldDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef)) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        return normalizedEncoding;\n      }\n      normalizedEncoding[channel] = normalize(channelDef as ChannelDef, channel);\n    }\n    return normalizedEncoding;\n  }, {});\n}\n\nexport function fieldDefs<F extends Field>(encoding: EncodingWithFacet<F>): FieldDef<F>[] {\n  const arr: FieldDef<F>[] = [];\n  for (const channel of keys(encoding)) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      const channelDefArray = isArray(channelDef) ? channelDef : [channelDef];\n      for (const def of channelDefArray) {\n        if (isFieldDef(def)) {\n          arr.push(def);\n        } else if (hasConditionalFieldDef<F, ValueOrGradientOrText>(def)) {\n          arr.push(def.condition);\n        }\n      }\n    }\n  }\n  return arr;\n}\n\nexport function forEach<U extends {[k in Channel]?: any}>(\n  mapping: U,\n  f: (cd: ChannelDef, c: Channel) => void,\n  thisArg?: any\n) {\n  if (!mapping) {\n    return;\n  }\n\n  for (const channel of keys(mapping)) {\n    const el = mapping[channel];\n    if (isArray(el)) {\n      el.forEach((channelDef: ChannelDef) => {\n        f.call(thisArg, channelDef, channel);\n      });\n    } else {\n      f.call(thisArg, el, channel);\n    }\n  }\n}\n\nexport function reduce<T, U extends {[k in Channel]?: any}>(\n  mapping: U,\n  f: (acc: any, fd: TypedFieldDef<string>, c: Channel) => U,\n  init: T,\n  thisArg?: any\n) {\n  if (!mapping) {\n    return init;\n  }\n\n  return keys(mapping).reduce((r, channel) => {\n    const map = mapping[channel];\n    if (isArray(map)) {\n      return map.reduce((r1: T, channelDef: ChannelDef) => {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n\n/**\n * Returns list of path grouping fields for the given encoding\n */\nexport function pathGroupingFields(mark: Mark, encoding: Encoding<string>): string[] {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group\n      case 'x':\n      case 'y':\n      case 'href':\n      case 'url':\n      case 'x2':\n      case 'y2':\n      // falls through\n\n      case 'latitude':\n      case 'longitude':\n      case 'latitude2':\n      case 'longitude2':\n      // TODO: case 'cursor':\n\n      // text, shape, shouldn't be a part of line/trail/area [falls through]\n      case 'text':\n      case 'shape':\n      // falls through\n\n      // tooltip fields should not be added to group by [falls through]\n      case 'tooltip':\n        return details;\n\n      case 'order':\n        // order should not group line / trail\n        if (mark === 'line' || mark === 'trail') {\n          return details;\n        }\n      // but order should group area for stacking (falls through)\n\n      case 'detail':\n      case 'key': {\n        const channelDef = encoding[channel];\n        if (isArray(channelDef) || isFieldDef(channelDef)) {\n          (isArray(channelDef) ? channelDef : [channelDef]).forEach(fieldDef => {\n            if (!fieldDef.aggregate) {\n              details.push(vgField(fieldDef, {}));\n            }\n          });\n        }\n        return details;\n      }\n\n      case 'size':\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n      // For line, size should group lines.\n\n      // falls through\n      case 'color':\n      case 'fill':\n      case 'stroke':\n      case 'opacity':\n      case 'fillOpacity':\n      case 'strokeOpacity':\n      case 'strokeWidth': {\n        // TODO strokeDashOffset:\n        // falls through\n\n        const fieldDef = getTypedFieldDef<string>(encoding[channel]);\n        if (fieldDef && !fieldDef.aggregate) {\n          details.push(vgField(fieldDef, {}));\n        }\n        return details;\n      }\n    }\n  }, []);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}