{"ast":null,"code":"import { isBinning } from '../../bin';\nimport { isColorChannel, isScaleChannel, rangeType } from '../../channel';\nimport * as log from '../../log';\nimport { channelSupportScaleType, scaleTypeSupportDataType } from '../../scale';\nimport * as util from '../../util';\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\n\nexport function scaleType(specifiedScale, channel, fieldDef, mark) {\n  const defaultScaleType = defaultType(channel, fieldDef, mark);\n  const {\n    type\n  } = specifiedScale;\n\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    } // Check if explicitly specified scale type is supported by the data type\n\n\n    if (!scaleTypeSupportDataType(type, fieldDef.type)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    return type;\n  }\n\n  return defaultScaleType;\n}\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\n\nfunction defaultType(channel, fieldDef, mark) {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n        if (channel === 'shape' && fieldDef.type === 'ordinal') {\n          log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n        }\n\n        return 'ordinal';\n      }\n\n      if (util.contains(['x', 'y'], channel)) {\n        if (util.contains(['rect', 'bar', 'image', 'rule'], mark)) {\n          // The rect/bar mark should fit into a band.\n          // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n          return 'band';\n        }\n      } // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n\n\n      return 'point';\n\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'time';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal')); // TODO: consider using quantize (equivalent to binning) once we have it\n\n        return 'ordinal';\n      }\n\n      return 'time';\n\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n\n        return 'linear';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative')); // TODO: consider using quantize (equivalent to binning) once we have it\n\n        return 'ordinal';\n      }\n\n      return 'linear';\n\n    case 'geojson':\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach this */\n\n\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}","map":{"version":3,"sources":["../../../../src/compile/scale/type.ts"],"names":[],"mappings":"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","sourcesContent":["import {isBinning} from '../../bin';\nimport {Channel, isColorChannel, isScaleChannel, rangeType} from '../../channel';\nimport {TypedFieldDef} from '../../channeldef';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {channelSupportScaleType, Scale, ScaleType, scaleTypeSupportDataType} from '../../scale';\nimport * as util from '../../util';\n\nexport type RangeType = 'continuous' | 'discrete' | 'flexible' | undefined;\n\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport function scaleType(\n  specifiedScale: Scale,\n  channel: Channel,\n  fieldDef: TypedFieldDef<string>,\n  mark: Mark\n): ScaleType {\n  const defaultScaleType = defaultType(channel, fieldDef, mark);\n  const {type} = specifiedScale;\n\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    // Check if explicitly specified scale type is supported by the data type\n    if (!scaleTypeSupportDataType(type, fieldDef.type)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    return type;\n  }\n\n  return defaultScaleType;\n}\n\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(channel: Channel, fieldDef: TypedFieldDef<string>, mark: Mark): ScaleType {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n        if (channel === 'shape' && fieldDef.type === 'ordinal') {\n          log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n        }\n        return 'ordinal';\n      }\n\n      if (util.contains(['x', 'y'], channel)) {\n        if (util.contains(['rect', 'bar', 'image', 'rule'], mark)) {\n          // The rect/bar mark should fit into a band.\n          // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n          return 'band';\n        }\n      }\n      // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n      return 'point';\n\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'time';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n      return 'time';\n\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n\n        return 'linear';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n\n      return 'linear';\n\n    case 'geojson':\n      return undefined;\n  }\n\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}