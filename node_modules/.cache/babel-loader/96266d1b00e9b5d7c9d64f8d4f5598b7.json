{"ast":null,"code":"export function isLogicalOr(op) {\n  return !!op.or;\n}\nexport function isLogicalAnd(op) {\n  return !!op.and;\n}\nexport function isLogicalNot(op) {\n  return !!op.not;\n}\nexport function forEachLeaf(op, fn) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    for (const subop of op.and) {\n      forEachLeaf(subop, fn);\n    }\n  } else if (isLogicalOr(op)) {\n    for (const subop of op.or) {\n      forEachLeaf(subop, fn);\n    }\n  } else {\n    fn(op);\n  }\n}\nexport function normalizeLogicalOperand(op, normalizer) {\n  if (isLogicalNot(op)) {\n    return {\n      not: normalizeLogicalOperand(op.not, normalizer)\n    };\n  } else if (isLogicalAnd(op)) {\n    return {\n      and: op.and.map(o => normalizeLogicalOperand(o, normalizer))\n    };\n  } else if (isLogicalOr(op)) {\n    return {\n      or: op.or.map(o => normalizeLogicalOperand(o, normalizer))\n    };\n  } else {\n    return normalizer(op);\n  }\n}","map":{"version":3,"sources":["../../src/logical.ts"],"names":[],"mappings":"AAcA,OAAM,SAAU,WAAV,CAAsB,EAAtB,EAA6C;AACjD,SAAO,CAAC,CAAC,EAAE,CAAC,EAAZ;AACD;AAED,OAAM,SAAU,YAAV,CAAuB,EAAvB,EAA8C;AAClD,SAAO,CAAC,CAAC,EAAE,CAAC,GAAZ;AACD;AAED,OAAM,SAAU,YAAV,CAAuB,EAAvB,EAA8C;AAClD,SAAO,CAAC,CAAC,EAAE,CAAC,GAAZ;AACD;AAED,OAAM,SAAU,WAAV,CAAyB,EAAzB,EAAgD,EAAhD,EAAmE;AACvE,MAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AACpB,IAAA,WAAW,CAAC,EAAE,CAAC,GAAJ,EAAS,EAAT,CAAX;AACD,GAFD,MAEO,IAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AAC3B,SAAK,MAAM,KAAX,IAAoB,EAAE,CAAC,GAAvB,EAA4B;AAC1B,MAAA,WAAW,CAAC,KAAD,EAAQ,EAAR,CAAX;AACD;AACF,GAJM,MAIA,IAAI,WAAW,CAAC,EAAD,CAAf,EAAqB;AAC1B,SAAK,MAAM,KAAX,IAAoB,EAAE,CAAC,EAAvB,EAA2B;AACzB,MAAA,WAAW,CAAC,KAAD,EAAQ,EAAR,CAAX;AACD;AACF,GAJM,MAIA;AACL,IAAA,EAAE,CAAC,EAAD,CAAF;AACD;AACF;AAED,OAAM,SAAU,uBAAV,CAAqC,EAArC,EAA4D,UAA5D,EAAmF;AACvF,MAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AACpB,WAAO;AAAC,MAAA,GAAG,EAAE,uBAAuB,CAAC,EAAE,CAAC,GAAJ,EAAS,UAAT;AAA7B,KAAP;AACD,GAFD,MAEO,IAAI,YAAY,CAAC,EAAD,CAAhB,EAAsB;AAC3B,WAAO;AAAC,MAAA,GAAG,EAAE,EAAE,CAAC,GAAH,CAAO,GAAP,CAAW,CAAC,IAAI,uBAAuB,CAAC,CAAD,EAAI,UAAJ,CAAvC;AAAN,KAAP;AACD,GAFM,MAEA,IAAI,WAAW,CAAC,EAAD,CAAf,EAAqB;AAC1B,WAAO;AAAC,MAAA,EAAE,EAAE,EAAE,CAAC,EAAH,CAAM,GAAN,CAAU,CAAC,IAAI,uBAAuB,CAAC,CAAD,EAAI,UAAJ,CAAtC;AAAL,KAAP;AACD,GAFM,MAEA;AACL,WAAO,UAAU,CAAC,EAAD,CAAjB;AACD;AACF","sourcesContent":["export type LogicalOperand<T> = LogicalNot<T> | LogicalAnd<T> | LogicalOr<T> | T;\n\nexport interface LogicalOr<T> {\n  or: LogicalOperand<T>[];\n}\n\nexport interface LogicalAnd<T> {\n  and: LogicalOperand<T>[];\n}\n\nexport interface LogicalNot<T> {\n  not: LogicalOperand<T>;\n}\n\nexport function isLogicalOr(op: LogicalOperand<any>): op is LogicalOr<any> {\n  return !!op.or;\n}\n\nexport function isLogicalAnd(op: LogicalOperand<any>): op is LogicalAnd<any> {\n  return !!op.and;\n}\n\nexport function isLogicalNot(op: LogicalOperand<any>): op is LogicalNot<any> {\n  return !!op.not;\n}\n\nexport function forEachLeaf<T>(op: LogicalOperand<T>, fn: (op: T) => void) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    for (const subop of op.and) {\n      forEachLeaf(subop, fn);\n    }\n  } else if (isLogicalOr(op)) {\n    for (const subop of op.or) {\n      forEachLeaf(subop, fn);\n    }\n  } else {\n    fn(op);\n  }\n}\n\nexport function normalizeLogicalOperand<T>(op: LogicalOperand<T>, normalizer: (o: T) => T): LogicalOperand<T> {\n  if (isLogicalNot(op)) {\n    return {not: normalizeLogicalOperand(op.not, normalizer)};\n  } else if (isLogicalAnd(op)) {\n    return {and: op.and.map(o => normalizeLogicalOperand(o, normalizer))};\n  } else if (isLogicalOr(op)) {\n    return {or: op.or.map(o => normalizeLogicalOperand(o, normalizer))};\n  } else {\n    return normalizer(op);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}