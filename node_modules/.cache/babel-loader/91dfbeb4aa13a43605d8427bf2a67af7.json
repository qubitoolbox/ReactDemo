{"ast":null,"code":"import * as encode from './encode';\nexport const rule = {\n  vgMark: 'rule',\n  encodeEntry: model => {\n    const {\n      markDef\n    } = model;\n    const orient = markDef.orient;\n\n    if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {\n      // Show nothing if we have none of x, y, lat, and long.\n      return {};\n    }\n\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, encode.baseEncodeEntry(model, {\n      align: 'ignore',\n      baseline: 'ignore',\n      color: 'include',\n      orient: 'ignore',\n      size: 'ignore'\n    })), encode.pointOrRangePosition('x', model, {\n      defaultPos: orient === 'horizontal' ? 'zeroOrMin' : 'mid',\n      defaultPos2: 'zeroOrMax',\n      range: orient !== 'vertical' // include x2 for horizontal or line segment rule\n\n    })), encode.pointOrRangePosition('y', model, {\n      defaultPos: orient === 'vertical' ? 'zeroOrMin' : 'mid',\n      defaultPos2: 'zeroOrMax',\n      range: orient !== 'horizontal' // include y2 for vertical or line segment rule\n\n    })), encode.nonPosition('size', model, {\n      vgChannel: 'strokeWidth' // VL's rule size is strokeWidth\n\n    }));\n  }\n};","map":{"version":3,"sources":["../../../../src/compile/mark/rule.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,MAAZ,MAAwB,UAAxB;AAEA,OAAO,MAAM,IAAI,GAAiB;AAChC,EAAA,MAAM,EAAE,MADwB;AAEhC,EAAA,WAAW,EAAG,KAAD,IAAqB;AAChC,UAAM;AAAC,MAAA;AAAD,QAAY,KAAlB;AACA,UAAM,MAAM,GAAG,OAAO,CAAC,MAAvB;;AAEA,QAAI,CAAC,KAAK,CAAC,QAAN,CAAe,CAAhB,IAAqB,CAAC,KAAK,CAAC,QAAN,CAAe,CAArC,IAA0C,CAAC,KAAK,CAAC,QAAN,CAAe,QAA1D,IAAsE,CAAC,KAAK,CAAC,QAAN,CAAe,SAA1F,EAAqG;AACnG;AACA,aAAO,EAAP;AACD;;AAED,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,MAAM,CAAC,eAAP,CAAuB,KAAvB,EAA8B;AAC/B,MAAA,KAAK,EAAE,QADwB;AAE/B,MAAA,QAAQ,EAAE,QAFqB;AAG/B,MAAA,KAAK,EAAE,SAHwB;AAI/B,MAAA,MAAM,EAAE,QAJuB;AAK/B,MAAA,IAAI,EAAE;AALyB,KAA9B,CADL,CAAA,EAQK,MAAM,CAAC,oBAAP,CAA4B,GAA5B,EAAiC,KAAjC,EAAwC;AACzC,MAAA,UAAU,EAAE,MAAM,KAAK,YAAX,GAA0B,WAA1B,GAAwC,KADX;AAEzC,MAAA,WAAW,EAAE,WAF4B;AAGzC,MAAA,KAAK,EAAE,MAAM,KAAK,UAHuB,CAGZ;;AAHY,KAAxC,CARL,CAAA,EAaK,MAAM,CAAC,oBAAP,CAA4B,GAA5B,EAAiC,KAAjC,EAAwC;AACzC,MAAA,UAAU,EAAE,MAAM,KAAK,UAAX,GAAwB,WAAxB,GAAsC,KADT;AAEzC,MAAA,WAAW,EAAE,WAF4B;AAGzC,MAAA,KAAK,EAAE,MAAM,KAAK,YAHuB,CAGV;;AAHU,KAAxC,CAbL,CAAA,EAkBK,MAAM,CAAC,WAAP,CAAmB,MAAnB,EAA2B,KAA3B,EAAkC;AACnC,MAAA,SAAS,EAAE,aADwB,CACV;;AADU,KAAlC,CAlBL,CAAA;AAsBD;AAjC+B,CAA3B","sourcesContent":["import {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as encode from './encode';\n\nexport const rule: MarkCompiler = {\n  vgMark: 'rule',\n  encodeEntry: (model: UnitModel) => {\n    const {markDef} = model;\n    const orient = markDef.orient;\n\n    if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {\n      // Show nothing if we have none of x, y, lat, and long.\n      return {};\n    }\n\n    return {\n      ...encode.baseEncodeEntry(model, {\n        align: 'ignore',\n        baseline: 'ignore',\n        color: 'include',\n        orient: 'ignore',\n        size: 'ignore'\n      }),\n      ...encode.pointOrRangePosition('x', model, {\n        defaultPos: orient === 'horizontal' ? 'zeroOrMin' : 'mid',\n        defaultPos2: 'zeroOrMax',\n        range: orient !== 'vertical' // include x2 for horizontal or line segment rule\n      }),\n      ...encode.pointOrRangePosition('y', model, {\n        defaultPos: orient === 'vertical' ? 'zeroOrMin' : 'mid',\n        defaultPos2: 'zeroOrMax',\n        range: orient !== 'horizontal' // include y2 for vertical or line segment rule\n      }),\n      ...encode.nonPosition('size', model, {\n        vgChannel: 'strokeWidth' // VL's rule size is strokeWidth\n      })\n    };\n  }\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}