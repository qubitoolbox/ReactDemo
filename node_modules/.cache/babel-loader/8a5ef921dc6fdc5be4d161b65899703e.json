{"ast":null,"code":"import { DataPrefix, IndexPrefix, ScalePrefix } from './prefix';\nimport { Identifier, Literal } from 'vega-expression';\nimport { error, hasOwnProperty } from 'vega-util';\nexport function dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n\n  const data = args[0].value,\n        dataName = DataPrefix + data;\n\n  if (!hasOwnProperty(dataName, params)) {\n    try {\n      params[dataName] = scope.getData(data).tuplesRef();\n    } catch (err) {// if data set does not exist, there's nothing to track\n    }\n  }\n}\nexport function indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n  const data = args[0].value,\n        field = args[1].value,\n        indexName = IndexPrefix + field;\n\n  if (!hasOwnProperty(indexName, params)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\nexport function scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  } else if (args[0].type === Identifier) {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\n\nfunction addScaleDependency(scope, params, name) {\n  const scaleName = ScalePrefix + name;\n\n  if (!hasOwnProperty(params, scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {// TODO: error handling? warning?\n    }\n  }\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-functions/src/visitors.js"],"names":["DataPrefix","IndexPrefix","ScalePrefix","Identifier","Literal","error","hasOwnProperty","dataVisitor","name","args","scope","params","type","data","value","dataName","getData","tuplesRef","err","indataVisitor","field","indexName","indataRef","scaleVisitor","addScaleDependency","scales","scaleName","scaleRef"],"mappings":"AAAA,SAAQA,UAAR,EAAoBC,WAApB,EAAiCC,WAAjC,QAAmD,UAAnD;AACA,SAAQC,UAAR,EAAoBC,OAApB,QAAkC,iBAAlC;AACA,SAAQC,KAAR,EAAeC,cAAf,QAAoC,WAApC;AAEA,OAAO,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,IAA3B,EAAiCC,KAAjC,EAAwCC,MAAxC,EAAgD;AACrD,MAAIF,IAAI,CAAC,CAAD,CAAJ,CAAQG,IAAR,KAAiBR,OAArB,EAA8B;AAC5BC,IAAAA,KAAK,CAAC,4DAAD,CAAL;AACD;;AAED,QAAMQ,IAAI,GAAGJ,IAAI,CAAC,CAAD,CAAJ,CAAQK,KAArB;AAAA,QACMC,QAAQ,GAAGf,UAAU,GAAGa,IAD9B;;AAGA,MAAI,CAACP,cAAc,CAACS,QAAD,EAAWJ,MAAX,CAAnB,EAAuC;AACrC,QAAI;AACFA,MAAAA,MAAM,CAACI,QAAD,CAAN,GAAmBL,KAAK,CAACM,OAAN,CAAcH,IAAd,EAAoBI,SAApB,EAAnB;AACD,KAFD,CAEE,OAAOC,GAAP,EAAY,CACZ;AACD;AACF;AACF;AAED,OAAO,SAASC,aAAT,CAAuBX,IAAvB,EAA6BC,IAA7B,EAAmCC,KAAnC,EAA0CC,MAA1C,EAAkD;AACvD,MAAIF,IAAI,CAAC,CAAD,CAAJ,CAAQG,IAAR,KAAiBR,OAArB,EAA8BC,KAAK,CAAC,oDAAD,CAAL;AAC9B,MAAII,IAAI,CAAC,CAAD,CAAJ,CAAQG,IAAR,KAAiBR,OAArB,EAA8BC,KAAK,CAAC,qDAAD,CAAL;AAE9B,QAAMQ,IAAI,GAAGJ,IAAI,CAAC,CAAD,CAAJ,CAAQK,KAArB;AAAA,QACMM,KAAK,GAAGX,IAAI,CAAC,CAAD,CAAJ,CAAQK,KADtB;AAAA,QAEMO,SAAS,GAAGpB,WAAW,GAAGmB,KAFhC;;AAIA,MAAI,CAACd,cAAc,CAACe,SAAD,EAAYV,MAAZ,CAAnB,EAAwC;AACtCA,IAAAA,MAAM,CAACU,SAAD,CAAN,GAAoBX,KAAK,CAACM,OAAN,CAAcH,IAAd,EAAoBS,SAApB,CAA8BZ,KAA9B,EAAqCU,KAArC,CAApB;AACD;AACF;AAED,OAAO,SAASG,YAAT,CAAsBf,IAAtB,EAA4BC,IAA5B,EAAkCC,KAAlC,EAAyCC,MAAzC,EAAiD;AACtD,MAAIF,IAAI,CAAC,CAAD,CAAJ,CAAQG,IAAR,KAAiBR,OAArB,EAA8B;AAC5B;AACAoB,IAAAA,kBAAkB,CAACd,KAAD,EAAQC,MAAR,EAAgBF,IAAI,CAAC,CAAD,CAAJ,CAAQK,KAAxB,CAAlB;AACD,GAHD,MAIK,IAAIL,IAAI,CAAC,CAAD,CAAJ,CAAQG,IAAR,KAAiBT,UAArB,EAAiC;AACpC;AACA,SAAKK,IAAL,IAAaE,KAAK,CAACe,MAAnB,EAA2B;AACzBD,MAAAA,kBAAkB,CAACd,KAAD,EAAQC,MAAR,EAAgBH,IAAhB,CAAlB;AACD;AACF;AACF;;AAED,SAASgB,kBAAT,CAA4Bd,KAA5B,EAAmCC,MAAnC,EAA2CH,IAA3C,EAAiD;AAC/C,QAAMkB,SAAS,GAAGxB,WAAW,GAAGM,IAAhC;;AACA,MAAI,CAACF,cAAc,CAACK,MAAD,EAASe,SAAT,CAAnB,EAAwC;AACtC,QAAI;AACFf,MAAAA,MAAM,CAACe,SAAD,CAAN,GAAoBhB,KAAK,CAACiB,QAAN,CAAenB,IAAf,CAApB;AACD,KAFD,CAEE,OAAOU,GAAP,EAAY,CACZ;AACD;AACF;AACF","sourcesContent":["import {DataPrefix, IndexPrefix, ScalePrefix} from './prefix';\nimport {Identifier, Literal} from 'vega-expression';\nimport {error, hasOwnProperty} from 'vega-util';\n\nexport function dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n\n  const data = args[0].value,\n        dataName = DataPrefix + data;\n\n  if (!hasOwnProperty(dataName, params)) {\n    try {\n      params[dataName] = scope.getData(data).tuplesRef();\n    } catch (err) {\n      // if data set does not exist, there's nothing to track\n    }\n  }\n}\n\nexport function indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n\n  const data = args[0].value,\n        field = args[1].value,\n        indexName = IndexPrefix + field;\n\n  if (!hasOwnProperty(indexName, params)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\n\nexport function scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  }\n  else if (args[0].type === Identifier) {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\n\nfunction addScaleDependency(scope, params, name) {\n  const scaleName = ScalePrefix + name;\n  if (!hasOwnProperty(params, scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {\n      // TODO: error handling? warning?\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}