{"ast":null,"code":"import { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\n\nexport default function ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\nResolveFilter.Definition = {\n  \"type\": \"ResolveFilter\",\n  \"metadata\": {},\n  \"params\": [{\n    \"name\": \"ignore\",\n    \"type\": \"number\",\n    \"required\": true,\n    \"description\": \"A bit mask indicating which filters to ignore.\"\n  }, {\n    \"name\": \"filter\",\n    \"type\": \"object\",\n    \"required\": true,\n    \"description\": \"Per-tuple filter bitmaps from a CrossFilter transform.\"\n  }]\n};\nvar prototype = inherits(ResolveFilter, Transform);\n\nprototype.transform = function (_, pulse) {\n  var ignore = ~(_.ignore || 0),\n      // bit mask where zeros -> dims to ignore\n  bitmap = _.filter,\n      mask = bitmap.mask; // exit early if no relevant filter changes\n\n  if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n  var output = pulse.fork(pulse.ALL),\n      data = bitmap.data(),\n      curr = bitmap.curr(),\n      prev = bitmap.prev(),\n      pass = function (k) {\n    return !(curr[k] & ignore) ? data[k] : null;\n  }; // propagate all mod tuples that pass the filter\n\n\n  output.filter(output.MOD, pass); // determine add & rem tuples via filter functions\n  // for efficiency, we do *not* populate new arrays,\n  // instead we add filter functions applied downstream\n\n  if (!(mask & mask - 1)) {\n    // only one filter changed\n    output.filter(output.ADD, pass);\n    output.filter(output.REM, function (k) {\n      return (curr[k] & ignore) === mask ? data[k] : null;\n    });\n  } else {\n    // multiple filters changed\n    output.filter(output.ADD, function (k) {\n      var c = curr[k] & ignore,\n          f = !c && c ^ prev[k] & ignore;\n      return f ? data[k] : null;\n    });\n    output.filter(output.REM, function (k) {\n      var c = curr[k] & ignore,\n          f = c && !(c ^ (c ^ prev[k] & ignore));\n      return f ? data[k] : null;\n    });\n  } // add filter to source data in case of reflow...\n\n\n  return output.filter(output.SOURCE, function (t) {\n    return pass(t._index);\n  });\n};","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-crossfilter/src/ResolveFilter.js"],"names":["Transform","inherits","ResolveFilter","params","call","Definition","prototype","transform","_","pulse","ignore","bitmap","filter","mask","StopPropagation","output","fork","ALL","data","curr","prev","pass","k","MOD","ADD","REM","c","f","SOURCE","t","_index"],"mappings":"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","sourcesContent":["import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\nexport default function ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\n\nResolveFilter.Definition = {\n  \"type\": \"ResolveFilter\",\n  \"metadata\": {},\n  \"params\": [\n    { \"name\": \"ignore\", \"type\": \"number\", \"required\": true,\n      \"description\": \"A bit mask indicating which filters to ignore.\" },\n    { \"name\": \"filter\", \"type\": \"object\", \"required\": true,\n      \"description\": \"Per-tuple filter bitmaps from a CrossFilter transform.\" }\n  ]\n};\n\nvar prototype = inherits(ResolveFilter, Transform);\n\nprototype.transform = function(_, pulse) {\n  var ignore = ~(_.ignore || 0), // bit mask where zeros -> dims to ignore\n      bitmap = _.filter,\n      mask = bitmap.mask;\n\n  // exit early if no relevant filter changes\n  if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n  var output = pulse.fork(pulse.ALL),\n      data = bitmap.data(),\n      curr = bitmap.curr(),\n      prev = bitmap.prev(),\n      pass = function(k) {\n        return !(curr[k] & ignore) ? data[k] : null;\n      };\n\n  // propagate all mod tuples that pass the filter\n  output.filter(output.MOD, pass);\n\n  // determine add & rem tuples via filter functions\n  // for efficiency, we do *not* populate new arrays,\n  // instead we add filter functions applied downstream\n\n  if (!(mask & (mask-1))) { // only one filter changed\n    output.filter(output.ADD, pass);\n    output.filter(output.REM, function(k) {\n      return (curr[k] & ignore) === mask ? data[k] : null;\n    });\n\n  } else { // multiple filters changed\n    output.filter(output.ADD, function(k) {\n      var c = curr[k] & ignore,\n          f = !c && (c ^ (prev[k] & ignore));\n      return f ? data[k] : null;\n    });\n    output.filter(output.REM, function(k) {\n      var c = curr[k] & ignore,\n          f = c && !(c ^ (c ^ (prev[k] & ignore)));\n      return f ? data[k] : null;\n    });\n  }\n\n  // add filter to source data in case of reflow...\n  return output.filter(output.SOURCE, function(t) { return pass(t._index); });\n};\n"]},"metadata":{},"sourceType":"module"}