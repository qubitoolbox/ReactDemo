{"ast":null,"code":"import { tupleid } from './Tuple';\nimport { isArray, visitArray } from 'vega-util';\n/**\n * Sentinel value indicating pulse propagation should stop.\n */\n\nexport var StopPropagation = {}; // Pulse visit type flags\n\nvar ADD = 1 << 0,\n    REM = 1 << 1,\n    MOD = 1 << 2,\n    ADD_REM = ADD | REM,\n    ADD_MOD = ADD | MOD,\n    ALL = ADD | REM | MOD,\n    REFLOW = 1 << 3,\n    SOURCE = 1 << 4,\n    NO_SOURCE = 1 << 5,\n    NO_FIELDS = 1 << 6;\n/**\n * A Pulse enables inter-operator communication during a run of the\n * dataflow graph. In addition to the current timestamp, a pulse may also\n * contain a change-set of added, removed or modified data tuples, as well as\n * a pointer to a full backing data source. Tuple change sets may not\n * be fully materialized; for example, to prevent needless array creation\n * a change set may include larger arrays and corresponding filter functions.\n * The pulse provides a {@link visit} method to enable proper and efficient\n * iteration over requested data tuples.\n *\n * In addition, each pulse can track modification flags for data tuple fields.\n * Responsible transform operators should call the {@link modifies} method to\n * indicate changes to data fields. The {@link modified} method enables\n * querying of this modification state.\n *\n * @constructor\n * @param {Dataflow} dataflow - The backing dataflow instance.\n * @param {number} stamp - The current propagation timestamp.\n * @param {string} [encode] - An optional encoding set name, which is then\n *   accessible as Pulse.encode. Operators can respond to (or ignore) this\n *   setting as appropriate. This parameter can be used in conjunction with\n *   the Encode transform in the vega-encode module.\n */\n\nexport default function Pulse(dataflow, stamp, encode) {\n  this.dataflow = dataflow;\n  this.stamp = stamp == null ? -1 : stamp;\n  this.add = [];\n  this.rem = [];\n  this.mod = [];\n  this.fields = null;\n  this.encode = encode || null;\n}\nvar prototype = Pulse.prototype;\n/**\n * Sentinel value indicating pulse propagation should stop.\n */\n\nprototype.StopPropagation = StopPropagation;\n/**\n * Boolean flag indicating ADD (added) tuples.\n */\n\nprototype.ADD = ADD;\n/**\n * Boolean flag indicating REM (removed) tuples.\n */\n\nprototype.REM = REM;\n/**\n * Boolean flag indicating MOD (modified) tuples.\n */\n\nprototype.MOD = MOD;\n/**\n * Boolean flag indicating ADD (added) and REM (removed) tuples.\n */\n\nprototype.ADD_REM = ADD_REM;\n/**\n * Boolean flag indicating ADD (added) and MOD (modified) tuples.\n */\n\nprototype.ADD_MOD = ADD_MOD;\n/**\n * Boolean flag indicating ADD, REM and MOD tuples.\n */\n\nprototype.ALL = ALL;\n/**\n * Boolean flag indicating all tuples in a data source\n * except for the ADD, REM and MOD tuples.\n */\n\nprototype.REFLOW = REFLOW;\n/**\n * Boolean flag indicating a 'pass-through' to a\n * backing data source, ignoring ADD, REM and MOD tuples.\n */\n\nprototype.SOURCE = SOURCE;\n/**\n * Boolean flag indicating that source data should be\n * suppressed when creating a forked pulse.\n */\n\nprototype.NO_SOURCE = NO_SOURCE;\n/**\n * Boolean flag indicating that field modifications should be\n * suppressed when creating a forked pulse.\n */\n\nprototype.NO_FIELDS = NO_FIELDS;\n/**\n * Creates a new pulse based on the values of this pulse.\n * The dataflow, time stamp and field modification values are copied over.\n * By default, new empty ADD, REM and MOD arrays are created.\n * @param {number} flags - Integer of boolean flags indicating which (if any)\n *   tuple arrays should be copied to the new pulse. The supported flag values\n *   are ADD, REM and MOD. Array references are copied directly: new array\n *   instances are not created.\n * @return {Pulse} - The forked pulse instance.\n * @see init\n */\n\nprototype.fork = function (flags) {\n  return new Pulse(this.dataflow).init(this, flags);\n};\n/**\n * Creates a copy of this pulse with new materialized array\n * instances for the ADD, REM, MOD, and SOURCE arrays.\n * The dataflow, time stamp and field modification values are copied over.\n * @return {Pulse} - The cloned pulse instance.\n * @see init\n */\n\n\nprototype.clone = function () {\n  var p = this.fork(ALL);\n  p.add = p.add.slice();\n  p.rem = p.rem.slice();\n  p.mod = p.mod.slice();\n  if (p.source) p.source = p.source.slice();\n  return p.materialize(ALL | SOURCE);\n};\n/**\n * Returns a pulse that adds all tuples from a backing source. This is\n * useful for cases where operators are added to a dataflow after an\n * upstream data pipeline has already been processed, ensuring that\n * new operators can observe all tuples within a stream.\n * @return {Pulse} - A pulse instance with all source tuples included\n *   in the add array. If the current pulse already has all source\n *   tuples in its add array, it is returned directly. If the current\n *   pulse does not have a backing source, it is returned directly.\n */\n\n\nprototype.addAll = function () {\n  var p = this;\n\n  if (!this.source || this.source.length === this.add.length) {\n    return p;\n  } else {\n    p = new Pulse(this.dataflow).init(this);\n    p.add = p.source;\n    return p;\n  }\n};\n/**\n * Initialize this pulse based on the values of another pulse. This method\n * is used internally by {@link fork} to initialize a new forked tuple.\n * The dataflow, time stamp and field modification values are copied over.\n * By default, new empty ADD, REM and MOD arrays are created.\n * @param {Pulse} src - The source pulse to copy from.\n * @param {number} flags - Integer of boolean flags indicating which (if any)\n *   tuple arrays should be copied to the new pulse. The supported flag values\n *   are ADD, REM and MOD. Array references are copied directly: new array\n *   instances are not created. By default, source data arrays are copied\n *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\n * @return {Pulse} - Returns this Pulse instance.\n */\n\n\nprototype.init = function (src, flags) {\n  var p = this;\n  p.stamp = src.stamp;\n  p.encode = src.encode;\n\n  if (src.fields && !(flags & NO_FIELDS)) {\n    p.fields = src.fields;\n  }\n\n  if (flags & ADD) {\n    p.addF = src.addF;\n    p.add = src.add;\n  } else {\n    p.addF = null;\n    p.add = [];\n  }\n\n  if (flags & REM) {\n    p.remF = src.remF;\n    p.rem = src.rem;\n  } else {\n    p.remF = null;\n    p.rem = [];\n  }\n\n  if (flags & MOD) {\n    p.modF = src.modF;\n    p.mod = src.mod;\n  } else {\n    p.modF = null;\n    p.mod = [];\n  }\n\n  if (flags & NO_SOURCE) {\n    p.srcF = null;\n    p.source = null;\n  } else {\n    p.srcF = src.srcF;\n    p.source = src.source;\n  }\n\n  return p;\n};\n/**\n * Schedules a function to run after pulse propagation completes.\n * @param {function} func - The function to run.\n */\n\n\nprototype.runAfter = function (func) {\n  this.dataflow.runAfter(func);\n};\n/**\n * Indicates if tuples have been added, removed or modified.\n * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\n *   Defaults to ALL, returning true if any tuple type has changed.\n * @return {boolean} - Returns true if one or more queried tuple types have\n *   changed, false otherwise.\n */\n\n\nprototype.changed = function (flags) {\n  var f = flags || ALL;\n  return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;\n};\n/**\n * Forces a \"reflow\" of tuple values, such that all tuples in the backing\n * source are added to the MOD set, unless already present in the ADD set.\n * @param {boolean} [fork=false] - If true, returns a forked copy of this\n *   pulse, and invokes reflow on that derived pulse.\n * @return {Pulse} - The reflowed pulse instance.\n */\n\n\nprototype.reflow = function (fork) {\n  if (fork) return this.fork(ALL).reflow();\n  var len = this.add.length,\n      src = this.source && this.source.length;\n\n  if (src && src !== len) {\n    this.mod = this.source;\n    if (len) this.filter(MOD, filter(this, ADD));\n  }\n\n  return this;\n};\n/**\n * Marks one or more data field names as modified to assist dependency\n * tracking and incremental processing by transform operators.\n * @param {string|Array<string>} _ - The field(s) to mark as modified.\n * @return {Pulse} - This pulse instance.\n */\n\n\nprototype.modifies = function (_) {\n  var hash = this.fields || (this.fields = {});\n\n  if (isArray(_)) {\n    _.forEach(f => hash[f] = true);\n  } else {\n    hash[_] = true;\n  }\n\n  return this;\n};\n/**\n * Checks if one or more data fields have been modified during this pulse\n * propagation timestamp.\n * @param {string|Array<string>} _ - The field(s) to check for modified.\n * @param {boolean} nomod - If true, will check the modified flag even if\n *   no mod tuples exist. If false (default), mod tuples must be present.\n * @return {boolean} - Returns true if any of the provided fields has been\n *   marked as modified, false otherwise.\n */\n\n\nprototype.modified = function (_, nomod) {\n  var fields = this.fields;\n  return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray(_) ? _.some(function (f) {\n    return fields[f];\n  }) : fields[_];\n};\n/**\n * Adds a filter function to one more tuple sets. Filters are applied to\n * backing tuple arrays, to determine the actual set of tuples considered\n * added, removed or modified. They can be used to delay materialization of\n * a tuple set in order to avoid expensive array copies. In addition, the\n * filter functions can serve as value transformers: unlike standard predicate\n * function (which return boolean values), Pulse filters should return the\n * actual tuple value to process. If a tuple set is already filtered, the\n * new filter function will be appended into a conjuntive ('and') query.\n * @param {number} flags - Flags indicating the tuple set(s) to filter.\n * @param {function(*):object} filter - Filter function that will be applied\n *   to the tuple set array, and should return a data tuple if the value\n *   should be included in the tuple set, and falsy (or null) otherwise.\n * @return {Pulse} - Returns this pulse instance.\n */\n\n\nprototype.filter = function (flags, filter) {\n  var p = this;\n  if (flags & ADD) p.addF = addFilter(p.addF, filter);\n  if (flags & REM) p.remF = addFilter(p.remF, filter);\n  if (flags & MOD) p.modF = addFilter(p.modF, filter);\n  if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\n  return p;\n};\n\nfunction addFilter(a, b) {\n  return a ? function (t, i) {\n    return a(t, i) && b(t, i);\n  } : b;\n}\n/**\n * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\n * a registered filter function, it will be applied and the tuple set(s) will\n * be replaced with materialized tuple arrays.\n * @param {number} flags - Flags indicating the tuple set(s) to materialize.\n * @return {Pulse} - Returns this pulse instance.\n */\n\n\nprototype.materialize = function (flags) {\n  flags = flags || ALL;\n  var p = this;\n\n  if (flags & ADD && p.addF) {\n    p.add = materialize(p.add, p.addF);\n    p.addF = null;\n  }\n\n  if (flags & REM && p.remF) {\n    p.rem = materialize(p.rem, p.remF);\n    p.remF = null;\n  }\n\n  if (flags & MOD && p.modF) {\n    p.mod = materialize(p.mod, p.modF);\n    p.modF = null;\n  }\n\n  if (flags & SOURCE && p.srcF) {\n    p.source = p.source.filter(p.srcF);\n    p.srcF = null;\n  }\n\n  return p;\n};\n\nfunction materialize(data, filter) {\n  var out = [];\n  visitArray(data, filter, function (_) {\n    out.push(_);\n  });\n  return out;\n}\n\nfunction filter(pulse, flags) {\n  var map = {};\n  pulse.visit(flags, function (t) {\n    map[tupleid(t)] = 1;\n  });\n  return function (t) {\n    return map[tupleid(t)] ? null : t;\n  };\n}\n/**\n * Visit one or more tuple sets in this pulse.\n * @param {number} flags - Flags indicating the tuple set(s) to visit.\n *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\n *   has been set).\n * @param {function(object):*} - Visitor function invoked per-tuple.\n * @return {Pulse} - Returns this pulse instance.\n */\n\n\nprototype.visit = function (flags, visitor) {\n  var p = this,\n      v = visitor,\n      src,\n      sum;\n\n  if (flags & SOURCE) {\n    visitArray(p.source, p.srcF, v);\n    return p;\n  }\n\n  if (flags & ADD) visitArray(p.add, p.addF, v);\n  if (flags & REM) visitArray(p.rem, p.remF, v);\n  if (flags & MOD) visitArray(p.mod, p.modF, v);\n\n  if (flags & REFLOW && (src = p.source)) {\n    sum = p.add.length + p.mod.length;\n\n    if (sum === src.length) {// do nothing\n    } else if (sum) {\n      visitArray(src, filter(p, ADD_MOD), v);\n    } else {\n      // if no add/rem/mod tuples, visit source\n      visitArray(src, p.srcF, v);\n    }\n  }\n\n  return p;\n};","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-dataflow/src/Pulse.js"],"names":["tupleid","isArray","visitArray","StopPropagation","ADD","REM","MOD","ADD_REM","ADD_MOD","ALL","REFLOW","SOURCE","NO_SOURCE","NO_FIELDS","Pulse","dataflow","stamp","encode","add","rem","mod","fields","prototype","fork","flags","init","clone","p","slice","source","materialize","addAll","length","src","addF","remF","modF","srcF","runAfter","func","changed","f","reflow","len","filter","modifies","_","hash","forEach","modified","nomod","arguments","some","addFilter","a","b","t","i","data","out","push","pulse","map","visit","visitor","v","sum"],"mappings":"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","sourcesContent":["import {tupleid} from './Tuple';\nimport {isArray, visitArray} from 'vega-util';\n\n/**\n * Sentinel value indicating pulse propagation should stop.\n */\nexport var StopPropagation = {};\n\n// Pulse visit type flags\nvar ADD       = (1 << 0),\n    REM       = (1 << 1),\n    MOD       = (1 << 2),\n    ADD_REM   = ADD | REM,\n    ADD_MOD   = ADD | MOD,\n    ALL       = ADD | REM | MOD,\n    REFLOW    = (1 << 3),\n    SOURCE    = (1 << 4),\n    NO_SOURCE = (1 << 5),\n    NO_FIELDS = (1 << 6);\n\n/**\n * A Pulse enables inter-operator communication during a run of the\n * dataflow graph. In addition to the current timestamp, a pulse may also\n * contain a change-set of added, removed or modified data tuples, as well as\n * a pointer to a full backing data source. Tuple change sets may not\n * be fully materialized; for example, to prevent needless array creation\n * a change set may include larger arrays and corresponding filter functions.\n * The pulse provides a {@link visit} method to enable proper and efficient\n * iteration over requested data tuples.\n *\n * In addition, each pulse can track modification flags for data tuple fields.\n * Responsible transform operators should call the {@link modifies} method to\n * indicate changes to data fields. The {@link modified} method enables\n * querying of this modification state.\n *\n * @constructor\n * @param {Dataflow} dataflow - The backing dataflow instance.\n * @param {number} stamp - The current propagation timestamp.\n * @param {string} [encode] - An optional encoding set name, which is then\n *   accessible as Pulse.encode. Operators can respond to (or ignore) this\n *   setting as appropriate. This parameter can be used in conjunction with\n *   the Encode transform in the vega-encode module.\n */\nexport default function Pulse(dataflow, stamp, encode) {\n  this.dataflow = dataflow;\n  this.stamp = stamp == null ? -1 : stamp;\n  this.add = [];\n  this.rem = [];\n  this.mod = [];\n  this.fields = null;\n  this.encode = encode || null;\n}\n\nvar prototype = Pulse.prototype;\n\n/**\n * Sentinel value indicating pulse propagation should stop.\n */\nprototype.StopPropagation = StopPropagation;\n\n/**\n * Boolean flag indicating ADD (added) tuples.\n */\nprototype.ADD = ADD;\n\n/**\n * Boolean flag indicating REM (removed) tuples.\n */\nprototype.REM = REM;\n\n/**\n * Boolean flag indicating MOD (modified) tuples.\n */\nprototype.MOD = MOD;\n\n/**\n * Boolean flag indicating ADD (added) and REM (removed) tuples.\n */\nprototype.ADD_REM = ADD_REM;\n\n/**\n * Boolean flag indicating ADD (added) and MOD (modified) tuples.\n */\nprototype.ADD_MOD = ADD_MOD;\n\n/**\n * Boolean flag indicating ADD, REM and MOD tuples.\n */\nprototype.ALL = ALL;\n\n/**\n * Boolean flag indicating all tuples in a data source\n * except for the ADD, REM and MOD tuples.\n */\nprototype.REFLOW = REFLOW;\n\n/**\n * Boolean flag indicating a 'pass-through' to a\n * backing data source, ignoring ADD, REM and MOD tuples.\n */\nprototype.SOURCE = SOURCE;\n\n/**\n * Boolean flag indicating that source data should be\n * suppressed when creating a forked pulse.\n */\nprototype.NO_SOURCE = NO_SOURCE;\n\n/**\n * Boolean flag indicating that field modifications should be\n * suppressed when creating a forked pulse.\n */\nprototype.NO_FIELDS = NO_FIELDS;\n\n/**\n * Creates a new pulse based on the values of this pulse.\n * The dataflow, time stamp and field modification values are copied over.\n * By default, new empty ADD, REM and MOD arrays are created.\n * @param {number} flags - Integer of boolean flags indicating which (if any)\n *   tuple arrays should be copied to the new pulse. The supported flag values\n *   are ADD, REM and MOD. Array references are copied directly: new array\n *   instances are not created.\n * @return {Pulse} - The forked pulse instance.\n * @see init\n */\nprototype.fork = function(flags) {\n  return new Pulse(this.dataflow).init(this, flags);\n};\n\n/**\n * Creates a copy of this pulse with new materialized array\n * instances for the ADD, REM, MOD, and SOURCE arrays.\n * The dataflow, time stamp and field modification values are copied over.\n * @return {Pulse} - The cloned pulse instance.\n * @see init\n */\nprototype.clone = function() {\n  var p = this.fork(ALL);\n  p.add = p.add.slice();\n  p.rem = p.rem.slice();\n  p.mod = p.mod.slice();\n  if (p.source) p.source = p.source.slice();\n  return p.materialize(ALL | SOURCE);\n};\n\n/**\n * Returns a pulse that adds all tuples from a backing source. This is\n * useful for cases where operators are added to a dataflow after an\n * upstream data pipeline has already been processed, ensuring that\n * new operators can observe all tuples within a stream.\n * @return {Pulse} - A pulse instance with all source tuples included\n *   in the add array. If the current pulse already has all source\n *   tuples in its add array, it is returned directly. If the current\n *   pulse does not have a backing source, it is returned directly.\n */\nprototype.addAll = function() {\n  var p = this;\n  if (!this.source || this.source.length === this.add.length) {\n    return p;\n  } else {\n    p = new Pulse(this.dataflow).init(this);\n    p.add = p.source;\n    return p;\n  }\n};\n\n/**\n * Initialize this pulse based on the values of another pulse. This method\n * is used internally by {@link fork} to initialize a new forked tuple.\n * The dataflow, time stamp and field modification values are copied over.\n * By default, new empty ADD, REM and MOD arrays are created.\n * @param {Pulse} src - The source pulse to copy from.\n * @param {number} flags - Integer of boolean flags indicating which (if any)\n *   tuple arrays should be copied to the new pulse. The supported flag values\n *   are ADD, REM and MOD. Array references are copied directly: new array\n *   instances are not created. By default, source data arrays are copied\n *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\n * @return {Pulse} - Returns this Pulse instance.\n */\nprototype.init = function(src, flags) {\n  var p = this;\n  p.stamp = src.stamp;\n  p.encode = src.encode;\n\n  if (src.fields && !(flags & NO_FIELDS)) {\n    p.fields = src.fields;\n  }\n\n  if (flags & ADD) {\n    p.addF = src.addF;\n    p.add = src.add;\n  } else {\n    p.addF = null;\n    p.add = [];\n  }\n\n  if (flags & REM) {\n    p.remF = src.remF;\n    p.rem = src.rem;\n  } else {\n    p.remF = null;\n    p.rem = [];\n  }\n\n  if (flags & MOD) {\n    p.modF = src.modF;\n    p.mod = src.mod;\n  } else {\n    p.modF = null;\n    p.mod = [];\n  }\n\n  if (flags & NO_SOURCE) {\n    p.srcF = null;\n    p.source = null;\n  } else {\n    p.srcF = src.srcF;\n    p.source = src.source;\n  }\n\n  return p;\n};\n\n/**\n * Schedules a function to run after pulse propagation completes.\n * @param {function} func - The function to run.\n */\nprototype.runAfter = function(func) {\n  this.dataflow.runAfter(func);\n};\n\n/**\n * Indicates if tuples have been added, removed or modified.\n * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\n *   Defaults to ALL, returning true if any tuple type has changed.\n * @return {boolean} - Returns true if one or more queried tuple types have\n *   changed, false otherwise.\n */\nprototype.changed = function(flags) {\n  var f = flags || ALL;\n  return ((f & ADD) && this.add.length)\n      || ((f & REM) && this.rem.length)\n      || ((f & MOD) && this.mod.length);\n};\n\n/**\n * Forces a \"reflow\" of tuple values, such that all tuples in the backing\n * source are added to the MOD set, unless already present in the ADD set.\n * @param {boolean} [fork=false] - If true, returns a forked copy of this\n *   pulse, and invokes reflow on that derived pulse.\n * @return {Pulse} - The reflowed pulse instance.\n */\nprototype.reflow = function(fork) {\n  if (fork) return this.fork(ALL).reflow();\n\n  var len = this.add.length,\n      src = this.source && this.source.length;\n  if (src && src !== len) {\n    this.mod = this.source;\n    if (len) this.filter(MOD, filter(this, ADD));\n  }\n  return this;\n};\n\n/**\n * Marks one or more data field names as modified to assist dependency\n * tracking and incremental processing by transform operators.\n * @param {string|Array<string>} _ - The field(s) to mark as modified.\n * @return {Pulse} - This pulse instance.\n */\nprototype.modifies = function(_) {\n  var hash = this.fields || (this.fields = {});\n  if (isArray(_)) {\n    _.forEach(f => hash[f] = true);\n  } else {\n    hash[_] = true;\n  }\n  return this;\n};\n\n/**\n * Checks if one or more data fields have been modified during this pulse\n * propagation timestamp.\n * @param {string|Array<string>} _ - The field(s) to check for modified.\n * @param {boolean} nomod - If true, will check the modified flag even if\n *   no mod tuples exist. If false (default), mod tuples must be present.\n * @return {boolean} - Returns true if any of the provided fields has been\n *   marked as modified, false otherwise.\n */\nprototype.modified = function(_, nomod) {\n  var fields = this.fields;\n  return !((nomod || this.mod.length) && fields) ? false\n    : !arguments.length ? !!fields\n    : isArray(_) ? _.some(function(f) { return fields[f]; })\n    : fields[_];\n};\n\n/**\n * Adds a filter function to one more tuple sets. Filters are applied to\n * backing tuple arrays, to determine the actual set of tuples considered\n * added, removed or modified. They can be used to delay materialization of\n * a tuple set in order to avoid expensive array copies. In addition, the\n * filter functions can serve as value transformers: unlike standard predicate\n * function (which return boolean values), Pulse filters should return the\n * actual tuple value to process. If a tuple set is already filtered, the\n * new filter function will be appended into a conjuntive ('and') query.\n * @param {number} flags - Flags indicating the tuple set(s) to filter.\n * @param {function(*):object} filter - Filter function that will be applied\n *   to the tuple set array, and should return a data tuple if the value\n *   should be included in the tuple set, and falsy (or null) otherwise.\n * @return {Pulse} - Returns this pulse instance.\n */\nprototype.filter = function(flags, filter) {\n  var p = this;\n  if (flags & ADD) p.addF = addFilter(p.addF, filter);\n  if (flags & REM) p.remF = addFilter(p.remF, filter);\n  if (flags & MOD) p.modF = addFilter(p.modF, filter);\n  if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\n  return p;\n};\n\nfunction addFilter(a, b) {\n  return a ? function(t,i) { return a(t,i) && b(t,i); } : b;\n}\n\n/**\n * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\n * a registered filter function, it will be applied and the tuple set(s) will\n * be replaced with materialized tuple arrays.\n * @param {number} flags - Flags indicating the tuple set(s) to materialize.\n * @return {Pulse} - Returns this pulse instance.\n */\nprototype.materialize = function(flags) {\n  flags = flags || ALL;\n  var p = this;\n  if ((flags & ADD) && p.addF) {\n    p.add = materialize(p.add, p.addF);\n    p.addF = null;\n  }\n  if ((flags & REM) && p.remF) {\n    p.rem = materialize(p.rem, p.remF);\n    p.remF = null;\n  }\n  if ((flags & MOD) && p.modF) {\n    p.mod = materialize(p.mod, p.modF);\n    p.modF = null;\n  }\n  if ((flags & SOURCE) && p.srcF) {\n    p.source = p.source.filter(p.srcF);\n    p.srcF = null;\n  }\n  return p;\n};\n\nfunction materialize(data, filter) {\n  var out = [];\n  visitArray(data, filter, function(_) { out.push(_); });\n  return out;\n}\n\nfunction filter(pulse, flags) {\n  var map = {};\n  pulse.visit(flags, function(t) { map[tupleid(t)] = 1; });\n  return function(t) { return map[tupleid(t)] ? null : t; };\n}\n\n/**\n * Visit one or more tuple sets in this pulse.\n * @param {number} flags - Flags indicating the tuple set(s) to visit.\n *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\n *   has been set).\n * @param {function(object):*} - Visitor function invoked per-tuple.\n * @return {Pulse} - Returns this pulse instance.\n */\nprototype.visit = function(flags, visitor) {\n  var p = this, v = visitor, src, sum;\n\n  if (flags & SOURCE) {\n    visitArray(p.source, p.srcF, v);\n    return p;\n  }\n\n  if (flags & ADD) visitArray(p.add, p.addF, v);\n  if (flags & REM) visitArray(p.rem, p.remF, v);\n  if (flags & MOD) visitArray(p.mod, p.modF, v);\n\n  if ((flags & REFLOW) && (src = p.source)) {\n    sum = p.add.length + p.mod.length;\n    if (sum === src.length) {\n      // do nothing\n    } else if (sum) {\n      visitArray(src, filter(p, ADD_MOD), v);\n    } else {\n      // if no add/rem/mod tuples, visit source\n      visitArray(src, p.srcF, v);\n    }\n  }\n\n  return p;\n};\n"]},"metadata":{},"sourceType":"module"}