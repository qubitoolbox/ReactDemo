{"ast":null,"code":"import { isBinned, isBinning } from '../../bin';\nimport { isContinuous, isFieldDef } from '../../channeldef';\nimport { isAggregate } from '../../encoding';\nimport * as log from '../../log';\nimport { AREA, BAR, CIRCLE, IMAGE, isMarkDef, LINE, POINT, RECT, RULE, SQUARE, TEXT, TICK } from '../../mark';\nimport { QUANTITATIVE, TEMPORAL } from '../../type';\nimport { contains, getFirstDefined } from '../../util';\nimport { getMarkConfig } from '../common';\nexport function normalizeMarkDef(mark, encoding, config, {\n  graticule\n}) {\n  var _a, _b;\n\n  const markDef = isMarkDef(mark) ? Object.assign({}, mark) : {\n    type: mark\n  }; // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n\n  const specifiedOrient = (_a = markDef.orient, _a !== null && _a !== void 0 ? _a : getMarkConfig('orient', markDef, config));\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n  } // set opacity and filled if not specified in mark config\n\n\n  const specifiedOpacity = getFirstDefined(markDef.opacity, getMarkConfig('opacity', markDef, config));\n\n  if (specifiedOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  }\n\n  const specifiedFilled = markDef.filled;\n\n  if (specifiedFilled === undefined) {\n    markDef.filled = graticule ? false : filled(markDef, config);\n  } // set cursor, which should be pointer if href channel is present unless otherwise specified\n\n\n  const specifiedCursor = (_b = markDef.cursor, _b !== null && _b !== void 0 ? _b : getMarkConfig('cursor', markDef, config));\n\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n\n  return markDef;\n}\n\nfunction cursor(markDef, encoding, config) {\n  if (encoding.href || markDef.href || getMarkConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n\n  return markDef.cursor;\n}\n\nfunction opacity(mark, encoding) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n\n  return undefined;\n}\n\nfunction filled(markDef, config) {\n  const filledConfig = getMarkConfig('filled', markDef, config);\n  const mark = markDef.type;\n  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\n\nfunction orient(mark, encoding, specifiedOrient) {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n    case IMAGE:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = encoding;\n\n  switch (mark) {\n    case BAR:\n      if (isFieldDef(x) && (isBinned(x.bin) || isFieldDef(y) && y.aggregate && !x.aggregate)) {\n        return 'vertical';\n      }\n\n      if (isFieldDef(y) && (isBinned(y.bin) || isFieldDef(x) && x.aggregate && !y.aggregate)) {\n        return 'horizontal';\n      }\n\n      if (y2 || x2) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        } // If y is range and x is non-range, non-bin Q, y is likely a prebinned field\n\n\n        if (!x2 && isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin)) {\n          return 'horizontal';\n        } // If x is range and y is non-range, non-bin Q, x is likely a prebinned field\n\n\n        if (!y2 && isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin)) {\n          return 'vertical';\n        }\n      }\n\n    // falls through\n\n    case RULE:\n      // return undefined for line segment rule and bar with both axis ranged\n      if (x2 && y2) {\n        return undefined;\n      }\n\n    // falls through\n\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (y2) {\n        if (isFieldDef(y) && isBinned(y.bin)) {\n          return 'horizontal';\n        } else {\n          return 'vertical';\n        }\n      } else if (x2) {\n        if (isFieldDef(x) && isBinned(x.bin)) {\n          return 'vertical';\n        } else {\n          return 'horizontal';\n        }\n      } else if (mark === RULE) {\n        if (x && !y) {\n          return 'vertical';\n        } else if (y && !x) {\n          return 'horizontal';\n        }\n      }\n\n    // falls through\n\n    case LINE:\n    case TICK:\n      {\n        // Tick is opposite to bar, line, area and never have ranged mark.\n        const xIsContinuous = isFieldDef(x) && isContinuous(x);\n        const yIsContinuous = isFieldDef(y) && isContinuous(y);\n\n        if (xIsContinuous && !yIsContinuous) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        } else if (!xIsContinuous && yIsContinuous) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (xIsContinuous && yIsContinuous) {\n          const xDef = x; // we can cast here since they are surely fieldDef\n\n          const yDef = y;\n          const xIsTemporal = xDef.type === TEMPORAL;\n          const yIsTemporal = yDef.type === TEMPORAL; // temporal without timeUnit is considered continuous, but better serves as dimension\n\n          if (xIsTemporal && !yIsTemporal) {\n            return mark !== 'tick' ? 'vertical' : 'horizontal';\n          } else if (!xIsTemporal && yIsTemporal) {\n            return mark !== 'tick' ? 'horizontal' : 'vertical';\n          }\n\n          if (!xDef.aggregate && yDef.aggregate) {\n            return mark !== 'tick' ? 'vertical' : 'horizontal';\n          } else if (xDef.aggregate && !yDef.aggregate) {\n            return mark !== 'tick' ? 'horizontal' : 'vertical';\n          }\n\n          if (specifiedOrient) {\n            // When ambiguous, use user specified one.\n            return specifiedOrient;\n          }\n\n          return 'vertical';\n        } else {\n          // Discrete x Discrete case\n          if (specifiedOrient) {\n            // When ambiguous, use user specified one.\n            return specifiedOrient;\n          }\n\n          return undefined;\n        }\n      }\n  }\n\n  return 'vertical';\n}","map":{"version":3,"sources":["../../../../src/compile/mark/init.ts"],"names":[],"mappings":"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","sourcesContent":["import {Orientation} from 'vega';\nimport {isBinned, isBinning} from '../../bin';\nimport {isContinuous, isFieldDef, TypedFieldDef} from '../../channeldef';\nimport {Config} from '../../config';\nimport {Encoding, isAggregate} from '../../encoding';\nimport * as log from '../../log';\nimport {\n  AREA,\n  BAR,\n  CIRCLE,\n  IMAGE,\n  isMarkDef,\n  LINE,\n  Mark,\n  MarkDef,\n  POINT,\n  RECT,\n  RULE,\n  SQUARE,\n  TEXT,\n  TICK\n} from '../../mark';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {contains, getFirstDefined} from '../../util';\nimport {getMarkConfig} from '../common';\n\nexport function normalizeMarkDef(\n  mark: Mark | MarkDef,\n  encoding: Encoding<string>,\n  config: Config,\n  {graticule}: {graticule: boolean}\n) {\n  const markDef: MarkDef = isMarkDef(mark) ? {...mark} : {type: mark};\n\n  // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n  const specifiedOrient = markDef.orient ?? getMarkConfig('orient', markDef, config);\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n  }\n\n  // set opacity and filled if not specified in mark config\n  const specifiedOpacity = getFirstDefined(markDef.opacity, getMarkConfig('opacity', markDef, config));\n  if (specifiedOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  }\n\n  const specifiedFilled = markDef.filled;\n  if (specifiedFilled === undefined) {\n    markDef.filled = graticule ? false : filled(markDef, config);\n  }\n\n  // set cursor, which should be pointer if href channel is present unless otherwise specified\n  const specifiedCursor = markDef.cursor ?? getMarkConfig('cursor', markDef, config);\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n\n  return markDef;\n}\n\nfunction cursor(markDef: MarkDef, encoding: Encoding<string>, config: Config) {\n  if (encoding.href || markDef.href || getMarkConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n  return markDef.cursor;\n}\n\nfunction opacity(mark: Mark, encoding: Encoding<string>) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n  return undefined;\n}\n\nfunction filled(markDef: MarkDef, config: Config) {\n  const filledConfig = getMarkConfig('filled', markDef, config);\n  const mark = markDef.type;\n  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\n\nfunction orient(mark: Mark, encoding: Encoding<string>, specifiedOrient: Orientation): Orientation {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n    case IMAGE:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const {x, y, x2, y2} = encoding;\n\n  switch (mark) {\n    case BAR:\n      if (isFieldDef(x) && (isBinned(x.bin) || (isFieldDef(y) && y.aggregate && !x.aggregate))) {\n        return 'vertical';\n      }\n      if (isFieldDef(y) && (isBinned(y.bin) || (isFieldDef(x) && x.aggregate && !y.aggregate))) {\n        return 'horizontal';\n      }\n      if (y2 || x2) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        }\n\n        // If y is range and x is non-range, non-bin Q, y is likely a prebinned field\n        if (!x2 && isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin)) {\n          return 'horizontal';\n        }\n\n        // If x is range and y is non-range, non-bin Q, x is likely a prebinned field\n        if (!y2 && isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin)) {\n          return 'vertical';\n        }\n      }\n\n    // falls through\n    case RULE:\n      // return undefined for line segment rule and bar with both axis ranged\n      if (x2 && y2) {\n        return undefined;\n      }\n\n    // falls through\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (y2) {\n        if (isFieldDef(y) && isBinned(y.bin)) {\n          return 'horizontal';\n        } else {\n          return 'vertical';\n        }\n      } else if (x2) {\n        if (isFieldDef(x) && isBinned(x.bin)) {\n          return 'vertical';\n        } else {\n          return 'horizontal';\n        }\n      } else if (mark === RULE) {\n        if (x && !y) {\n          return 'vertical';\n        } else if (y && !x) {\n          return 'horizontal';\n        }\n      }\n\n    // falls through\n    case LINE:\n    case TICK: {\n      // Tick is opposite to bar, line, area and never have ranged mark.\n      const xIsContinuous = isFieldDef(x) && isContinuous(x);\n      const yIsContinuous = isFieldDef(y) && isContinuous(y);\n      if (xIsContinuous && !yIsContinuous) {\n        return mark !== 'tick' ? 'horizontal' : 'vertical';\n      } else if (!xIsContinuous && yIsContinuous) {\n        return mark !== 'tick' ? 'vertical' : 'horizontal';\n      } else if (xIsContinuous && yIsContinuous) {\n        const xDef = x as TypedFieldDef<string>; // we can cast here since they are surely fieldDef\n        const yDef = y as TypedFieldDef<string>;\n\n        const xIsTemporal = xDef.type === TEMPORAL;\n        const yIsTemporal = yDef.type === TEMPORAL;\n\n        // temporal without timeUnit is considered continuous, but better serves as dimension\n        if (xIsTemporal && !yIsTemporal) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (!xIsTemporal && yIsTemporal) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        }\n\n        if (!xDef.aggregate && yDef.aggregate) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (xDef.aggregate && !yDef.aggregate) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        }\n\n        if (specifiedOrient) {\n          // When ambiguous, use user specified one.\n          return specifiedOrient;\n        }\n\n        return 'vertical';\n      } else {\n        // Discrete x Discrete case\n        if (specifiedOrient) {\n          // When ambiguous, use user specified one.\n          return specifiedOrient;\n        }\n\n        return undefined;\n      }\n    }\n  }\n  return 'vertical';\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}