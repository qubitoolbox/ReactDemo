{"ast":null,"code":"import { labelFormat, labelFraction, labelValues } from './labels';\nimport { Symbols, Gradient } from './legend-types';\nimport { tickCount } from './ticks';\nimport { Transform, ingest } from 'vega-dataflow';\nimport { scaleFraction } from 'vega-scale';\nimport { constant, inherits, isFunction, peek } from 'vega-util';\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nexport default function LegendEntries(params) {\n  Transform.call(this, [], params);\n}\nvar prototype = inherits(LegendEntries, Transform);\n\nprototype.transform = function (_, pulse) {\n  if (this.value != null && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      items = this.value,\n      type = _.type || Symbols,\n      scale = _.scale,\n      limit = +_.limit,\n      count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n      lskip = !!_.values || type === Symbols,\n      format = _.format || labelFormat(scale, count, type, _.formatSpecifier, _.formatType, lskip),\n      values = _.values || labelValues(scale, count, type),\n      domain,\n      fraction,\n      size,\n      offset,\n      ellipsis;\n  if (items) out.rem = items;\n\n  if (type === Symbols) {\n    if (limit && values.length > limit) {\n      pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n      items = values.slice(0, limit - 1);\n      ellipsis = true;\n    } else {\n      items = values;\n    }\n\n    if (isFunction(size = _.size)) {\n      // if first value maps to size zero, remove from list (vega#717)\n      if (!_.values && scale(items[0]) === 0) {\n        items = items.slice(1);\n      } // compute size offset for legend entries\n\n\n      offset = items.reduce(function (max, value) {\n        return Math.max(max, size(value, _));\n      }, 0);\n    } else {\n      size = constant(offset = size || 8);\n    }\n\n    items = items.map(function (value, index) {\n      return ingest({\n        index: index,\n        label: format(value, index, items),\n        value: value,\n        offset: offset,\n        size: size(value, _)\n      });\n    });\n\n    if (ellipsis) {\n      ellipsis = values[items.length];\n      items.push(ingest({\n        index: items.length,\n        label: `\\u2026${values.length - items.length} entries`,\n        value: ellipsis,\n        offset: offset,\n        size: size(ellipsis, _)\n      }));\n    }\n  } else if (type === Gradient) {\n    domain = scale.domain(), fraction = scaleFraction(scale, domain[0], peek(domain)); // if automatic label generation produces 2 or fewer values,\n    // use the domain end points instead (fixes vega/vega#1364)\n\n    if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n      values = [domain[0], peek(domain)];\n    }\n\n    items = values.map(function (value, index) {\n      return ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: fraction(value)\n      });\n    });\n  } else {\n    size = values.length - 1;\n    fraction = labelFraction(scale);\n    items = values.map(function (value, index) {\n      return ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: index ? fraction(value) : 0,\n        perc2: index === size ? 1 : fraction(values[index + 1])\n      });\n    });\n  }\n\n  out.source = items;\n  out.add = items;\n  this.value = items;\n  return out;\n};","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-encode/src/LegendEntries.js"],"names":["labelFormat","labelFraction","labelValues","Symbols","Gradient","tickCount","Transform","ingest","scaleFraction","constant","inherits","isFunction","peek","LegendEntries","params","call","prototype","transform","_","pulse","value","modified","StopPropagation","out","fork","NO_SOURCE","NO_FIELDS","items","type","scale","limit","count","minstep","lskip","values","format","formatSpecifier","formatType","domain","fraction","size","offset","ellipsis","rem","length","dataflow","warn","slice","reduce","max","Math","map","index","label","push","perc","perc2","source","add"],"mappings":"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","sourcesContent":["import {labelFormat, labelFraction, labelValues} from './labels';\nimport {Symbols, Gradient} from './legend-types';\nimport {tickCount} from './ticks';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {scaleFraction} from 'vega-scale';\nimport {constant, inherits, isFunction, peek} from 'vega-util';\n\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\nexport default function LegendEntries(params) {\n  Transform.call(this, [], params);\n}\n\nvar prototype = inherits(LegendEntries, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (this.value != null && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      items = this.value,\n      type  = _.type || Symbols,\n      scale = _.scale,\n      limit = +_.limit,\n      count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n      lskip = !!_.values || type === Symbols,\n      format = _.format || labelFormat(scale, count, type, _.formatSpecifier, _.formatType, lskip),\n      values = _.values || labelValues(scale, count, type),\n      domain, fraction, size, offset, ellipsis;\n\n  if (items) out.rem = items;\n\n  if (type === Symbols) {\n    if (limit && values.length > limit) {\n      pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n      items = values.slice(0, limit - 1);\n      ellipsis = true;\n    } else {\n      items = values;\n    }\n\n    if (isFunction(size = _.size)) {\n      // if first value maps to size zero, remove from list (vega#717)\n      if (!_.values && scale(items[0]) === 0) {\n        items = items.slice(1);\n      }\n      // compute size offset for legend entries\n      offset = items.reduce(function(max, value) {\n        return Math.max(max, size(value, _));\n      }, 0);\n    } else {\n      size = constant(offset = size || 8);\n    }\n\n    items = items.map(function(value, index) {\n      return ingest({\n        index:  index,\n        label:  format(value, index, items),\n        value:  value,\n        offset: offset,\n        size:   size(value, _)\n      });\n    });\n\n    if (ellipsis) {\n      ellipsis = values[items.length];\n      items.push(ingest({\n        index:    items.length,\n        label:    `\\u2026${values.length-items.length} entries`,\n        value:    ellipsis,\n        offset:   offset,\n        size:     size(ellipsis, _)\n      }));\n    }\n  }\n\n  else if (type === Gradient) {\n    domain = scale.domain(),\n    fraction = scaleFraction(scale, domain[0], peek(domain));\n\n    // if automatic label generation produces 2 or fewer values,\n    // use the domain end points instead (fixes vega/vega#1364)\n    if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n      values = [domain[0], peek(domain)];\n    }\n\n    items = values.map(function(value, index) {\n      return ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc:  fraction(value)\n      });\n    });\n  }\n\n  else {\n    size = values.length - 1;\n    fraction = labelFraction(scale);\n\n    items = values.map(function(value, index) {\n      return ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc:  index ? fraction(value) : 0,\n        perc2: index === size ? 1 : fraction(values[index+1])\n      });\n    });\n  }\n\n  out.source = items;\n  out.add = items;\n  this.value = items;\n\n  return out;\n};\n"]},"metadata":{},"sourceType":"module"}