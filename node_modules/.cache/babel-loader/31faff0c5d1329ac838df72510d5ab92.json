{"ast":null,"code":"import { getFirstDefined } from '../../../util';\nimport { getMarkConfig } from '../../common';\nimport { wrapCondition } from './conditional';\nimport * as ref from './valueref';\n/**\n * Return encodoing encode for non-positional channels with scales. (Text doesn't have scale.)\n */\n\nexport function nonPosition(channel, model, opt = {}) {\n  const {\n    markDef,\n    encoding,\n    config\n  } = model;\n  const {\n    vgChannel = channel\n  } = opt;\n  let {\n    defaultRef,\n    defaultValue\n  } = opt;\n\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : vgChannel === channel ? // When vl channel is the same as Vega's, no need to read from config as Vega will apply them correctly\n    markDef[channel] : // However, when they are different (e.g, vl's text size is vg fontSize), need to read \"size\" from configs\n    getFirstDefined(markDef[channel], markDef[vgChannel], getMarkConfig(channel, markDef, config, {\n      vgChannel\n    }));\n    defaultRef = defaultValue ? {\n      value: defaultValue\n    } : undefined;\n  }\n\n  const channelDef = encoding[channel];\n  return wrapCondition(model, channelDef, vgChannel, cDef => {\n    return ref.midPoint({\n      channel,\n      channelDef: cDef,\n      markDef,\n      config,\n      scaleName: model.scaleName(channel),\n      scale: model.getScaleComponent(channel),\n      stack: null,\n      defaultRef\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/nonposition.ts"],"names":[],"mappings":"AAEA,SAAQ,eAAR,QAA8B,eAA9B;AAEA,SAAQ,aAAR,QAA4B,cAA5B;AAEA,SAAQ,aAAR,QAA4B,eAA5B;AACA,OAAO,KAAK,GAAZ,MAAqB,YAArB;AAEA;;;;AAGA,OAAM,SAAU,WAAV,CACJ,OADI,EAEJ,KAFI,EAGJ,GAAA,GAII,EAPA,EAOE;AAEN,QAAM;AAAC,IAAA,OAAD;AAAU,IAAA,QAAV;AAAoB,IAAA;AAApB,MAA8B,KAApC;AACA,QAAM;AAAC,IAAA,SAAS,GAAG;AAAb,MAAwB,GAA9B;AACA,MAAI;AAAC,IAAA,UAAD;AAAa,IAAA;AAAb,MAA6B,GAAjC;;AAEA,MAAI,UAAU,KAAK,SAAnB,EAA8B;AAC5B;AACA,IAAA,YAAY,GAAG,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAA,YAAA,GACZ,SAAS,KAAK,OAAd,GACG;AACF,IAAA,OAAO,CAAC,OAAD,CAFR,GAGG;AACF,IAAA,eAAe,CAAC,OAAO,CAAC,OAAD,CAAR,EAAmB,OAAO,CAAC,SAAD,CAA1B,EAAuC,aAAa,CAAC,OAAD,EAAU,OAAV,EAAmB,MAAnB,EAA2B;AAAC,MAAA;AAAD,KAA3B,CAApD,CALnB;AAOA,IAAA,UAAU,GAAG,YAAY,GAAG;AAAC,MAAA,KAAK,EAAE;AAAR,KAAH,GAA2B,SAApD;AACD;;AAED,QAAM,UAAU,GAAG,QAAQ,CAAC,OAAD,CAA3B;AAEA,SAAO,aAAa,CAAoC,KAApC,EAA2C,UAA3C,EAAuD,SAAvD,EAAkE,IAAI,IAAG;AAC3F,WAAO,GAAG,CAAC,QAAJ,CAAa;AAClB,MAAA,OADkB;AAElB,MAAA,UAAU,EAAE,IAFM;AAGlB,MAAA,OAHkB;AAIlB,MAAA,MAJkB;AAKlB,MAAA,SAAS,EAAE,KAAK,CAAC,SAAN,CAAgB,OAAhB,CALO;AAMlB,MAAA,KAAK,EAAE,KAAK,CAAC,iBAAN,CAAwB,OAAxB,CANW;AAOlB,MAAA,KAAK,EAAE,IAPW;AAQlB,MAAA;AARkB,KAAb,CAAP;AAUD,GAXmB,CAApB;AAYD","sourcesContent":["import {NonPositionScaleChannel} from '../../../channel';\nimport {FieldDef, ValueOrGradient} from '../../../channeldef';\nimport {getFirstDefined} from '../../../util';\nimport {VgEncodeChannel, VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getMarkConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {wrapCondition} from './conditional';\nimport * as ref from './valueref';\n\n/**\n * Return encodoing encode for non-positional channels with scales. (Text doesn't have scale.)\n */\nexport function nonPosition(\n  channel: NonPositionScaleChannel,\n  model: UnitModel,\n  opt: {\n    defaultValue?: ValueOrGradient;\n    vgChannel?: VgEncodeChannel;\n    defaultRef?: VgValueRef;\n  } = {}\n): VgEncodeEntry {\n  const {markDef, encoding, config} = model;\n  const {vgChannel = channel} = opt;\n  let {defaultRef, defaultValue} = opt;\n\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue = defaultValue ??\n      (vgChannel === channel\n        ? // When vl channel is the same as Vega's, no need to read from config as Vega will apply them correctly\n        markDef[channel]\n        : // However, when they are different (e.g, vl's text size is vg fontSize), need to read \"size\" from configs\n        getFirstDefined(markDef[channel], markDef[vgChannel], getMarkConfig(channel, markDef, config, {vgChannel})));\n\n    defaultRef = defaultValue ? {value: defaultValue} : undefined;\n  }\n\n  const channelDef = encoding[channel];\n\n  return wrapCondition<FieldDef<string>, ValueOrGradient>(model, channelDef, vgChannel, cDef => {\n    return ref.midPoint({\n      channel,\n      channelDef: cDef,\n      markDef,\n      config,\n      scaleName: model.scaleName(channel),\n      scale: model.getScaleComponent(channel),\n      stack: null, // No need to provide stack for non-position as it does not affect mid point\n      defaultRef\n    });\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}