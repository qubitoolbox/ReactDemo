{"ast":null,"code":"import Parameters from './Parameters';\nimport UniqueList from './util/UniqueList';\nimport { array, error, id, isArray } from 'vega-util';\nvar OP_ID = 0;\nvar PULSE = 'pulse';\nvar NO_PARAMS = new Parameters(); // Boolean Flags\n\nvar SKIP = 1,\n    MODIFIED = 2;\n/**\n * An Operator is a processing node in a dataflow graph.\n * Each operator stores a value and an optional value update function.\n * Operators can accept a hash of named parameters. Parameter values can\n * either be direct (JavaScript literals, arrays, objects) or indirect\n * (other operators whose values will be pulled dynamically). Operators\n * included as parameters will have this operator added as a dependency.\n * @constructor\n * @param {*} [init] - The initial value for this operator.\n * @param {function(object, Pulse)} [update] - An update function. Upon\n *   evaluation of this operator, the update function will be invoked and the\n *   return value will be used as the new value of this operator.\n * @param {object} [params] - The parameters for this operator.\n * @param {boolean} [react=true] - Flag indicating if this operator should\n *   listen for changes to upstream operators included as parameters.\n * @see parameters\n */\n\nexport default function Operator(init, update, params, react) {\n  this.id = ++OP_ID;\n  this.value = init;\n  this.stamp = -1;\n  this.rank = -1;\n  this.qrank = -1;\n  this.flags = 0;\n\n  if (update) {\n    this._update = update;\n  }\n\n  if (params) this.parameters(params, react);\n}\nvar prototype = Operator.prototype;\n/**\n * Returns a list of target operators dependent on this operator.\n * If this list does not exist, it is created and then returned.\n * @return {UniqueList}\n */\n\nprototype.targets = function () {\n  return this._targets || (this._targets = UniqueList(id));\n};\n/**\n * Sets the value of this operator.\n * @param {*} value - the value to set.\n * @return {Number} Returns 1 if the operator value has changed\n *   according to strict equality, returns 0 otherwise.\n */\n\n\nprototype.set = function (value) {\n  if (this.value !== value) {\n    this.value = value;\n    return 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction flag(bit) {\n  return function (state) {\n    var f = this.flags;\n    if (arguments.length === 0) return !!(f & bit);\n    this.flags = state ? f | bit : f & ~bit;\n    return this;\n  };\n}\n/**\n * Indicates that operator evaluation should be skipped on the next pulse.\n * This operator will still propagate incoming pulses, but its update function\n * will not be invoked. The skip flag is reset after every pulse, so calling\n * this method will affect processing of the next pulse only.\n */\n\n\nprototype.skip = flag(SKIP);\n/**\n * Indicates that this operator's value has been modified on its most recent\n * pulse. Normally modification is checked via strict equality; however, in\n * some cases it is more efficient to update the internal state of an object.\n * In those cases, the modified flag can be used to trigger propagation. Once\n * set, the modification flag persists across pulses until unset. The flag can\n * be used with the last timestamp to test if a modification is recent.\n */\n\nprototype.modified = flag(MODIFIED);\n/**\n * Sets the parameters for this operator. The parameter values are analyzed for\n * operator instances. If found, this operator will be added as a dependency\n * of the parameterizing operator. Operator values are dynamically marshalled\n * from each operator parameter prior to evaluation. If a parameter value is\n * an array, the array will also be searched for Operator instances. However,\n * the search does not recurse into sub-arrays or object properties.\n * @param {object} params - A hash of operator parameters.\n * @param {boolean} [react=true] - A flag indicating if this operator should\n *   automatically update (react) when parameter values change. In other words,\n *   this flag determines if the operator registers itself as a listener on\n *   any upstream operators included in the parameters.\n * @param {boolean} [initonly=false] - A flag indicating if this operator\n *   should calculate an update only upon its initiatal evaluation, then\n *   deregister dependencies and suppress all future update invocations.\n * @return {Operator[]} - An array of upstream dependencies.\n */\n\nprototype.parameters = function (params, react, initonly) {\n  react = react !== false;\n  var self = this,\n      argval = self._argval = self._argval || new Parameters(),\n      argops = self._argops = self._argops || [],\n      deps = [],\n      name,\n      value,\n      n,\n      i;\n\n  function add(name, index, value) {\n    if (value instanceof Operator) {\n      if (value !== self) {\n        if (react) value.targets().add(self);\n        deps.push(value);\n      }\n\n      argops.push({\n        op: value,\n        name: name,\n        index: index\n      });\n    } else {\n      argval.set(name, index, value);\n    }\n  }\n\n  for (name in params) {\n    value = params[name];\n\n    if (name === PULSE) {\n      array(value).forEach(function (op) {\n        if (!(op instanceof Operator)) {\n          error('Pulse parameters must be operator instances.');\n        } else if (op !== self) {\n          op.targets().add(self);\n          deps.push(op);\n        }\n      });\n      self.source = value;\n    } else if (isArray(value)) {\n      argval.set(name, -1, Array(n = value.length));\n\n      for (i = 0; i < n; ++i) add(name, i, value[i]);\n    } else {\n      add(name, -1, value);\n    }\n  }\n\n  this.marshall().clear(); // initialize values\n\n  if (initonly) argops.initonly = true;\n  return deps;\n};\n/**\n * Internal method for marshalling parameter values.\n * Visits each operator dependency to pull the latest value.\n * @return {Parameters} A Parameters object to pass to the update function.\n */\n\n\nprototype.marshall = function (stamp) {\n  var argval = this._argval || NO_PARAMS,\n      argops = this._argops,\n      item,\n      i,\n      n,\n      op,\n      mod;\n\n  if (argops) {\n    for (i = 0, n = argops.length; i < n; ++i) {\n      item = argops[i];\n      op = item.op;\n      mod = op.modified() && op.stamp === stamp;\n      argval.set(item.name, item.index, op.value, mod);\n    }\n\n    if (argops.initonly) {\n      for (i = 0; i < n; ++i) {\n        item = argops[i];\n        item.op.targets().remove(this);\n      }\n\n      this._argops = null;\n      this._update = null;\n    }\n  }\n\n  return argval;\n};\n/**\n * Delegate method to perform operator processing.\n * Subclasses can override this method to perform custom processing.\n * By default, it marshalls parameters and calls the update function\n * if that function is defined. If the update function does not\n * change the operator value then StopPropagation is returned.\n * If no update function is defined, this method does nothing.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return The output pulse or StopPropagation. A falsy return value\n *   (including undefined) will let the input pulse pass through.\n */\n\n\nprototype.evaluate = function (pulse) {\n  var update = this._update;\n\n  if (update) {\n    var params = this.marshall(pulse.stamp),\n        v = update.call(this, params, pulse);\n    params.clear();\n\n    if (v !== this.value) {\n      this.value = v;\n    } else if (!this.modified()) {\n      return pulse.StopPropagation;\n    }\n  }\n};\n/**\n * Run this operator for the current pulse. If this operator has already\n * been run at (or after) the pulse timestamp, returns StopPropagation.\n * Internally, this method calls {@link evaluate} to perform processing.\n * If {@link evaluate} returns a falsy value, the input pulse is returned.\n * This method should NOT be overridden, instead overrride {@link evaluate}.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return the output pulse for this operator (or StopPropagation)\n */\n\n\nprototype.run = function (pulse) {\n  if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n  var rv;\n\n  if (this.skip()) {\n    this.skip(false);\n    rv = 0;\n  } else {\n    rv = this.evaluate(pulse);\n  }\n\n  return this.pulse = rv || pulse;\n};","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-dataflow/src/Operator.js"],"names":["Parameters","UniqueList","array","error","id","isArray","OP_ID","PULSE","NO_PARAMS","SKIP","MODIFIED","Operator","init","update","params","react","value","stamp","rank","qrank","flags","_update","parameters","prototype","targets","_targets","set","flag","bit","state","f","arguments","length","skip","modified","initonly","self","argval","_argval","argops","_argops","deps","name","n","i","add","index","push","op","forEach","source","Array","marshall","clear","item","mod","remove","evaluate","pulse","v","call","StopPropagation","run","rv"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,cAAvB;AACA,OAAOC,UAAP,MAAuB,mBAAvB;AACA,SAAQC,KAAR,EAAeC,KAAf,EAAsBC,EAAtB,EAA0BC,OAA1B,QAAwC,WAAxC;AAEA,IAAIC,KAAK,GAAG,CAAZ;AACA,IAAIC,KAAK,GAAG,OAAZ;AACA,IAAIC,SAAS,GAAG,IAAIR,UAAJ,EAAhB,C,CAEA;;AACA,IAAIS,IAAI,GAAO,CAAf;AAAA,IACIC,QAAQ,GAAG,CADf;AAGA;;;;;;;;;;;;;;;;;;AAiBA,eAAe,SAASC,QAAT,CAAkBC,IAAlB,EAAwBC,MAAxB,EAAgCC,MAAhC,EAAwCC,KAAxC,EAA+C;AAC5D,OAAKX,EAAL,GAAU,EAAEE,KAAZ;AACA,OAAKU,KAAL,GAAaJ,IAAb;AACA,OAAKK,KAAL,GAAa,CAAC,CAAd;AACA,OAAKC,IAAL,GAAY,CAAC,CAAb;AACA,OAAKC,KAAL,GAAa,CAAC,CAAd;AACA,OAAKC,KAAL,GAAa,CAAb;;AAEA,MAAIP,MAAJ,EAAY;AACV,SAAKQ,OAAL,GAAeR,MAAf;AACD;;AACD,MAAIC,MAAJ,EAAY,KAAKQ,UAAL,CAAgBR,MAAhB,EAAwBC,KAAxB;AACb;AAED,IAAIQ,SAAS,GAAGZ,QAAQ,CAACY,SAAzB;AAEA;;;;;;AAKAA,SAAS,CAACC,OAAV,GAAoB,YAAW;AAC7B,SAAO,KAAKC,QAAL,KAAkB,KAAKA,QAAL,GAAgBxB,UAAU,CAACG,EAAD,CAA5C,CAAP;AACD,CAFD;AAIA;;;;;;;;AAMAmB,SAAS,CAACG,GAAV,GAAgB,UAASV,KAAT,EAAgB;AAC9B,MAAI,KAAKA,KAAL,KAAeA,KAAnB,EAA0B;AACxB,SAAKA,KAAL,GAAaA,KAAb;AACA,WAAO,CAAP;AACD,GAHD,MAGO;AACL,WAAO,CAAP;AACD;AACF,CAPD;;AASA,SAASW,IAAT,CAAcC,GAAd,EAAmB;AACjB,SAAO,UAASC,KAAT,EAAgB;AACrB,QAAIC,CAAC,GAAG,KAAKV,KAAb;AACA,QAAIW,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B,OAAO,CAAC,EAAEF,CAAC,GAAGF,GAAN,CAAR;AAC5B,SAAKR,KAAL,GAAaS,KAAK,GAAIC,CAAC,GAAGF,GAAR,GAAgBE,CAAC,GAAG,CAACF,GAAvC;AACA,WAAO,IAAP;AACD,GALD;AAMD;AAED;;;;;;;;AAMAL,SAAS,CAACU,IAAV,GAAiBN,IAAI,CAAClB,IAAD,CAArB;AAEA;;;;;;;;;AAQAc,SAAS,CAACW,QAAV,GAAqBP,IAAI,CAACjB,QAAD,CAAzB;AAEA;;;;;;;;;;;;;;;;;;AAiBAa,SAAS,CAACD,UAAV,GAAuB,UAASR,MAAT,EAAiBC,KAAjB,EAAwBoB,QAAxB,EAAkC;AACvDpB,EAAAA,KAAK,GAAGA,KAAK,KAAK,KAAlB;AACA,MAAIqB,IAAI,GAAG,IAAX;AAAA,MACIC,MAAM,GAAID,IAAI,CAACE,OAAL,GAAeF,IAAI,CAACE,OAAL,IAAgB,IAAItC,UAAJ,EAD7C;AAAA,MAEIuC,MAAM,GAAIH,IAAI,CAACI,OAAL,GAAeJ,IAAI,CAACI,OAAL,IAAgB,EAF7C;AAAA,MAGIC,IAAI,GAAG,EAHX;AAAA,MAIIC,IAJJ;AAAA,MAIU1B,KAJV;AAAA,MAIiB2B,CAJjB;AAAA,MAIoBC,CAJpB;;AAMA,WAASC,GAAT,CAAaH,IAAb,EAAmBI,KAAnB,EAA0B9B,KAA1B,EAAiC;AAC/B,QAAIA,KAAK,YAAYL,QAArB,EAA+B;AAC7B,UAAIK,KAAK,KAAKoB,IAAd,EAAoB;AAClB,YAAIrB,KAAJ,EAAWC,KAAK,CAACQ,OAAN,GAAgBqB,GAAhB,CAAoBT,IAApB;AACXK,QAAAA,IAAI,CAACM,IAAL,CAAU/B,KAAV;AACD;;AACDuB,MAAAA,MAAM,CAACQ,IAAP,CAAY;AAACC,QAAAA,EAAE,EAAChC,KAAJ;AAAW0B,QAAAA,IAAI,EAACA,IAAhB;AAAsBI,QAAAA,KAAK,EAACA;AAA5B,OAAZ;AACD,KAND,MAMO;AACLT,MAAAA,MAAM,CAACX,GAAP,CAAWgB,IAAX,EAAiBI,KAAjB,EAAwB9B,KAAxB;AACD;AACF;;AAED,OAAK0B,IAAL,IAAa5B,MAAb,EAAqB;AACnBE,IAAAA,KAAK,GAAGF,MAAM,CAAC4B,IAAD,CAAd;;AAEA,QAAIA,IAAI,KAAKnC,KAAb,EAAoB;AAClBL,MAAAA,KAAK,CAACc,KAAD,CAAL,CAAaiC,OAAb,CAAqB,UAASD,EAAT,EAAa;AAChC,YAAI,EAAEA,EAAE,YAAYrC,QAAhB,CAAJ,EAA+B;AAC7BR,UAAAA,KAAK,CAAC,8CAAD,CAAL;AACD,SAFD,MAEO,IAAI6C,EAAE,KAAKZ,IAAX,EAAiB;AACtBY,UAAAA,EAAE,CAACxB,OAAH,GAAaqB,GAAb,CAAiBT,IAAjB;AACAK,UAAAA,IAAI,CAACM,IAAL,CAAUC,EAAV;AACD;AACF,OAPD;AAQAZ,MAAAA,IAAI,CAACc,MAAL,GAAclC,KAAd;AACD,KAVD,MAUO,IAAIX,OAAO,CAACW,KAAD,CAAX,EAAoB;AACzBqB,MAAAA,MAAM,CAACX,GAAP,CAAWgB,IAAX,EAAiB,CAAC,CAAlB,EAAqBS,KAAK,CAACR,CAAC,GAAG3B,KAAK,CAACgB,MAAX,CAA1B;;AACA,WAAKY,CAAC,GAAC,CAAP,EAAUA,CAAC,GAACD,CAAZ,EAAe,EAAEC,CAAjB,EAAoBC,GAAG,CAACH,IAAD,EAAOE,CAAP,EAAU5B,KAAK,CAAC4B,CAAD,CAAf,CAAH;AACrB,KAHM,MAGA;AACLC,MAAAA,GAAG,CAACH,IAAD,EAAO,CAAC,CAAR,EAAW1B,KAAX,CAAH;AACD;AACF;;AAED,OAAKoC,QAAL,GAAgBC,KAAhB,GAzCuD,CAyC9B;;AACzB,MAAIlB,QAAJ,EAAcI,MAAM,CAACJ,QAAP,GAAkB,IAAlB;AAEd,SAAOM,IAAP;AACD,CA7CD;AA+CA;;;;;;;AAKAlB,SAAS,CAAC6B,QAAV,GAAqB,UAASnC,KAAT,EAAgB;AACnC,MAAIoB,MAAM,GAAG,KAAKC,OAAL,IAAgB9B,SAA7B;AAAA,MACI+B,MAAM,GAAG,KAAKC,OADlB;AAAA,MAC2Bc,IAD3B;AAAA,MACiCV,CADjC;AAAA,MACoCD,CADpC;AAAA,MACuCK,EADvC;AAAA,MAC2CO,GAD3C;;AAGA,MAAIhB,MAAJ,EAAY;AACV,SAAKK,CAAC,GAAC,CAAF,EAAKD,CAAC,GAACJ,MAAM,CAACP,MAAnB,EAA2BY,CAAC,GAACD,CAA7B,EAAgC,EAAEC,CAAlC,EAAqC;AACnCU,MAAAA,IAAI,GAAGf,MAAM,CAACK,CAAD,CAAb;AACAI,MAAAA,EAAE,GAAGM,IAAI,CAACN,EAAV;AACAO,MAAAA,GAAG,GAAGP,EAAE,CAACd,QAAH,MAAiBc,EAAE,CAAC/B,KAAH,KAAaA,KAApC;AACAoB,MAAAA,MAAM,CAACX,GAAP,CAAW4B,IAAI,CAACZ,IAAhB,EAAsBY,IAAI,CAACR,KAA3B,EAAkCE,EAAE,CAAChC,KAArC,EAA4CuC,GAA5C;AACD;;AAED,QAAIhB,MAAM,CAACJ,QAAX,EAAqB;AACnB,WAAKS,CAAC,GAAC,CAAP,EAAUA,CAAC,GAACD,CAAZ,EAAe,EAAEC,CAAjB,EAAoB;AAClBU,QAAAA,IAAI,GAAGf,MAAM,CAACK,CAAD,CAAb;AACAU,QAAAA,IAAI,CAACN,EAAL,CAAQxB,OAAR,GAAkBgC,MAAlB,CAAyB,IAAzB;AACD;;AACD,WAAKhB,OAAL,GAAe,IAAf;AACA,WAAKnB,OAAL,GAAe,IAAf;AACD;AACF;;AACD,SAAOgB,MAAP;AACD,CAtBD;AAwBA;;;;;;;;;;;;;AAWAd,SAAS,CAACkC,QAAV,GAAqB,UAASC,KAAT,EAAgB;AACnC,MAAI7C,MAAM,GAAG,KAAKQ,OAAlB;;AACA,MAAIR,MAAJ,EAAY;AACV,QAAIC,MAAM,GAAG,KAAKsC,QAAL,CAAcM,KAAK,CAACzC,KAApB,CAAb;AAAA,QACI0C,CAAC,GAAG9C,MAAM,CAAC+C,IAAP,CAAY,IAAZ,EAAkB9C,MAAlB,EAA0B4C,KAA1B,CADR;AAGA5C,IAAAA,MAAM,CAACuC,KAAP;;AACA,QAAIM,CAAC,KAAK,KAAK3C,KAAf,EAAsB;AACpB,WAAKA,KAAL,GAAa2C,CAAb;AACD,KAFD,MAEO,IAAI,CAAC,KAAKzB,QAAL,EAAL,EAAsB;AAC3B,aAAOwB,KAAK,CAACG,eAAb;AACD;AACF;AACF,CAbD;AAeA;;;;;;;;;;;AASAtC,SAAS,CAACuC,GAAV,GAAgB,UAASJ,KAAT,EAAgB;AAC9B,MAAIA,KAAK,CAACzC,KAAN,GAAc,KAAKA,KAAvB,EAA8B,OAAOyC,KAAK,CAACG,eAAb;AAC9B,MAAIE,EAAJ;;AACA,MAAI,KAAK9B,IAAL,EAAJ,EAAiB;AACf,SAAKA,IAAL,CAAU,KAAV;AACA8B,IAAAA,EAAE,GAAG,CAAL;AACD,GAHD,MAGO;AACLA,IAAAA,EAAE,GAAG,KAAKN,QAAL,CAAcC,KAAd,CAAL;AACD;;AACD,SAAQ,KAAKA,KAAL,GAAaK,EAAE,IAAIL,KAA3B;AACD,CAVD","sourcesContent":["import Parameters from './Parameters';\nimport UniqueList from './util/UniqueList';\nimport {array, error, id, isArray} from 'vega-util';\n\nvar OP_ID = 0;\nvar PULSE = 'pulse';\nvar NO_PARAMS = new Parameters();\n\n// Boolean Flags\nvar SKIP     = 1,\n    MODIFIED = 2;\n\n/**\n * An Operator is a processing node in a dataflow graph.\n * Each operator stores a value and an optional value update function.\n * Operators can accept a hash of named parameters. Parameter values can\n * either be direct (JavaScript literals, arrays, objects) or indirect\n * (other operators whose values will be pulled dynamically). Operators\n * included as parameters will have this operator added as a dependency.\n * @constructor\n * @param {*} [init] - The initial value for this operator.\n * @param {function(object, Pulse)} [update] - An update function. Upon\n *   evaluation of this operator, the update function will be invoked and the\n *   return value will be used as the new value of this operator.\n * @param {object} [params] - The parameters for this operator.\n * @param {boolean} [react=true] - Flag indicating if this operator should\n *   listen for changes to upstream operators included as parameters.\n * @see parameters\n */\nexport default function Operator(init, update, params, react) {\n  this.id = ++OP_ID;\n  this.value = init;\n  this.stamp = -1;\n  this.rank = -1;\n  this.qrank = -1;\n  this.flags = 0;\n\n  if (update) {\n    this._update = update;\n  }\n  if (params) this.parameters(params, react);\n}\n\nvar prototype = Operator.prototype;\n\n/**\n * Returns a list of target operators dependent on this operator.\n * If this list does not exist, it is created and then returned.\n * @return {UniqueList}\n */\nprototype.targets = function() {\n  return this._targets || (this._targets = UniqueList(id));\n};\n\n/**\n * Sets the value of this operator.\n * @param {*} value - the value to set.\n * @return {Number} Returns 1 if the operator value has changed\n *   according to strict equality, returns 0 otherwise.\n */\nprototype.set = function(value) {\n  if (this.value !== value) {\n    this.value = value;\n    return 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction flag(bit) {\n  return function(state) {\n    var f = this.flags;\n    if (arguments.length === 0) return !!(f & bit);\n    this.flags = state ? (f | bit) : (f & ~bit);\n    return this;\n  };\n}\n\n/**\n * Indicates that operator evaluation should be skipped on the next pulse.\n * This operator will still propagate incoming pulses, but its update function\n * will not be invoked. The skip flag is reset after every pulse, so calling\n * this method will affect processing of the next pulse only.\n */\nprototype.skip = flag(SKIP);\n\n/**\n * Indicates that this operator's value has been modified on its most recent\n * pulse. Normally modification is checked via strict equality; however, in\n * some cases it is more efficient to update the internal state of an object.\n * In those cases, the modified flag can be used to trigger propagation. Once\n * set, the modification flag persists across pulses until unset. The flag can\n * be used with the last timestamp to test if a modification is recent.\n */\nprototype.modified = flag(MODIFIED);\n\n/**\n * Sets the parameters for this operator. The parameter values are analyzed for\n * operator instances. If found, this operator will be added as a dependency\n * of the parameterizing operator. Operator values are dynamically marshalled\n * from each operator parameter prior to evaluation. If a parameter value is\n * an array, the array will also be searched for Operator instances. However,\n * the search does not recurse into sub-arrays or object properties.\n * @param {object} params - A hash of operator parameters.\n * @param {boolean} [react=true] - A flag indicating if this operator should\n *   automatically update (react) when parameter values change. In other words,\n *   this flag determines if the operator registers itself as a listener on\n *   any upstream operators included in the parameters.\n * @param {boolean} [initonly=false] - A flag indicating if this operator\n *   should calculate an update only upon its initiatal evaluation, then\n *   deregister dependencies and suppress all future update invocations.\n * @return {Operator[]} - An array of upstream dependencies.\n */\nprototype.parameters = function(params, react, initonly) {\n  react = react !== false;\n  var self = this,\n      argval = (self._argval = self._argval || new Parameters()),\n      argops = (self._argops = self._argops || []),\n      deps = [],\n      name, value, n, i;\n\n  function add(name, index, value) {\n    if (value instanceof Operator) {\n      if (value !== self) {\n        if (react) value.targets().add(self);\n        deps.push(value);\n      }\n      argops.push({op:value, name:name, index:index});\n    } else {\n      argval.set(name, index, value);\n    }\n  }\n\n  for (name in params) {\n    value = params[name];\n\n    if (name === PULSE) {\n      array(value).forEach(function(op) {\n        if (!(op instanceof Operator)) {\n          error('Pulse parameters must be operator instances.');\n        } else if (op !== self) {\n          op.targets().add(self);\n          deps.push(op);\n        }\n      });\n      self.source = value;\n    } else if (isArray(value)) {\n      argval.set(name, -1, Array(n = value.length));\n      for (i=0; i<n; ++i) add(name, i, value[i]);\n    } else {\n      add(name, -1, value);\n    }\n  }\n\n  this.marshall().clear(); // initialize values\n  if (initonly) argops.initonly = true;\n\n  return deps;\n};\n\n/**\n * Internal method for marshalling parameter values.\n * Visits each operator dependency to pull the latest value.\n * @return {Parameters} A Parameters object to pass to the update function.\n */\nprototype.marshall = function(stamp) {\n  var argval = this._argval || NO_PARAMS,\n      argops = this._argops, item, i, n, op, mod;\n\n  if (argops) {\n    for (i=0, n=argops.length; i<n; ++i) {\n      item = argops[i];\n      op = item.op;\n      mod = op.modified() && op.stamp === stamp;\n      argval.set(item.name, item.index, op.value, mod);\n    }\n\n    if (argops.initonly) {\n      for (i=0; i<n; ++i) {\n        item = argops[i];\n        item.op.targets().remove(this);\n      }\n      this._argops = null;\n      this._update = null;\n    }\n  }\n  return argval;\n};\n\n/**\n * Delegate method to perform operator processing.\n * Subclasses can override this method to perform custom processing.\n * By default, it marshalls parameters and calls the update function\n * if that function is defined. If the update function does not\n * change the operator value then StopPropagation is returned.\n * If no update function is defined, this method does nothing.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return The output pulse or StopPropagation. A falsy return value\n *   (including undefined) will let the input pulse pass through.\n */\nprototype.evaluate = function(pulse) {\n  var update = this._update;\n  if (update) {\n    var params = this.marshall(pulse.stamp),\n        v = update.call(this, params, pulse);\n\n    params.clear();\n    if (v !== this.value) {\n      this.value = v;\n    } else if (!this.modified()) {\n      return pulse.StopPropagation;\n    }\n  }\n};\n\n/**\n * Run this operator for the current pulse. If this operator has already\n * been run at (or after) the pulse timestamp, returns StopPropagation.\n * Internally, this method calls {@link evaluate} to perform processing.\n * If {@link evaluate} returns a falsy value, the input pulse is returned.\n * This method should NOT be overridden, instead overrride {@link evaluate}.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return the output pulse for this operator (or StopPropagation)\n */\nprototype.run = function(pulse) {\n  if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n  var rv;\n  if (this.skip()) {\n    this.skip(false);\n    rv = 0;\n  } else {\n    rv = this.evaluate(pulse);\n  }\n  return (this.pulse = rv || pulse);\n};\n"]},"metadata":{},"sourceType":"module"}