{"ast":null,"code":"import { entry, ref, keyFieldRef, aggrField, sortKey } from './util';\nimport { Aggregate, Collect } from './transforms';\nimport { isString } from 'vega-util';\nexport default function DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n\n  this.input = input; // first operator in pipeline (tuple input)\n\n  this.output = output; // last operator in pipeline (tuple output)\n\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n  // last aggregate in transform pipeline\n\n  this.aggregate = aggr; // lookup table of field indices\n\n  this.index = {};\n}\n\nDataScope.fromEntries = function (scope, entries) {\n  var n = entries.length,\n      i = 1,\n      input = entries[0],\n      values = entries[n - 1],\n      output = entries[n - 2],\n      aggr = null;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  } // add operator entries to this scope, wire up pulse chain\n\n\n  scope.add(entries[0]);\n\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nvar prototype = DataScope.prototype;\n\nprototype.countsRef = function (scope, field, sort) {\n  var ds = this,\n      cache = ds.counts || (ds.counts = {}),\n      k = fieldKey(field),\n      v,\n      a,\n      p;\n\n  if (k != null) {\n    scope = ds.scope;\n    v = cache[k];\n  }\n\n  if (!v) {\n    p = {\n      groupby: scope.fieldRef(field, 'key'),\n      pulse: ref(ds.output)\n    };\n    if (sort && sort.field) addSortField(scope, p, sort);\n    a = scope.add(Aggregate(p));\n    v = scope.add(Collect({\n      pulse: ref(a)\n    }));\n    v = {\n      agg: a,\n      ref: ref(v)\n    };\n    if (k != null) cache[k] = v;\n  } else if (sort && sort.field) {\n    addSortField(scope, v.agg.params, sort);\n  }\n\n  return v.ref;\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  var as = aggrField(sort.op, sort.field),\n      s;\n\n  if (p.ops) {\n    for (var i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  var cache = ds[name] || (ds[name] = {}),\n      sort = sortKey(counts),\n      k = fieldKey(field),\n      v,\n      op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    var params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n\n  return v;\n}\n\nprototype.tuplesRef = function () {\n  return ref(this.values);\n};\n\nprototype.extentRef = function (scope, field) {\n  return cache(scope, this, 'extent', 'extent', field, false);\n};\n\nprototype.domainRef = function (scope, field) {\n  return cache(scope, this, 'domain', 'values', field, false);\n};\n\nprototype.valuesRef = function (scope, field, sort) {\n  return cache(scope, this, 'vals', 'values', field, sort || true);\n};\n\nprototype.lookupRef = function (scope, field) {\n  return cache(scope, this, 'lookup', 'tupleindex', field, false);\n};\n\nprototype.indataRef = function (scope, field) {\n  return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n};","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/DataScope.js"],"names":["entry","ref","keyFieldRef","aggrField","sortKey","Aggregate","Collect","isString","DataScope","scope","input","output","values","aggr","aggregate","index","fromEntries","entries","n","length","i","type","add","params","pulse","prototype","countsRef","field","sort","ds","cache","counts","k","fieldKey","v","a","p","groupby","fieldRef","addSortField","agg","as","op","s","ops","fields","push","signal","signalRef","name","optype","sortRef","undefined","tuplesRef","extentRef","domainRef","valuesRef","lookupRef","indataRef"],"mappings":"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","sourcesContent":["import {entry, ref, keyFieldRef, aggrField, sortKey} from './util';\nimport {Aggregate, Collect} from './transforms';\nimport {isString} from 'vega-util';\n\nexport default function DataScope(scope, input, output, values, aggr) {\n  this.scope = scope;   // parent scope object\n  this.input = input;   // first operator in pipeline (tuple input)\n  this.output = output; // last operator in pipeline (tuple output)\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n\n  // last aggregate in transform pipeline\n  this.aggregate = aggr;\n\n  // lookup table of field indices\n  this.index = {};\n}\n\nDataScope.fromEntries = function(scope, entries) {\n  var n = entries.length,\n      i = 1,\n      input  = entries[0],\n      values = entries[n-1],\n      output = entries[n-2],\n      aggr = null;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  }\n\n  // add operator entries to this scope, wire up pulse chain\n  scope.add(entries[0]);\n  for (; i<n; ++i) {\n    entries[i].params.pulse = ref(entries[i-1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nvar prototype = DataScope.prototype;\n\nprototype.countsRef = function(scope, field, sort) {\n  var ds = this,\n      cache = ds.counts || (ds.counts = {}),\n      k = fieldKey(field), v, a, p;\n\n  if (k != null) {\n    scope = ds.scope;\n    v = cache[k];\n  }\n\n  if (!v) {\n    p = {\n      groupby: scope.fieldRef(field, 'key'),\n      pulse: ref(ds.output)\n    };\n    if (sort && sort.field) addSortField(scope, p, sort);\n    a = scope.add(Aggregate(p));\n    v = scope.add(Collect({pulse: ref(a)}));\n    v = {agg: a, ref: ref(v)};\n    if (k != null) cache[k] = v;\n  } else if (sort && sort.field) {\n    addSortField(scope, v.agg.params, sort);\n  }\n\n  return v.ref;\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  var as = aggrField(sort.op, sort.field), s;\n\n  if (p.ops) {\n    for (var i=0, n=p.as.length; i<n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n  if (sort.op) {\n    p.ops.push((s=sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  var cache = ds[name] || (ds[name] = {}),\n      sort = sortKey(counts),\n      k = fieldKey(field), v, op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    var params = counts\n      ? {field: keyFieldRef, pulse: ds.countsRef(scope, field, counts)}\n      : {field: scope.fieldRef(field), pulse: ref(ds.output)};\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n  return v;\n}\n\nprototype.tuplesRef = function() {\n  return ref(this.values);\n};\n\nprototype.extentRef = function(scope, field) {\n  return cache(scope, this, 'extent', 'extent', field, false);\n};\n\nprototype.domainRef = function(scope, field) {\n  return cache(scope, this, 'domain', 'values', field, false);\n};\n\nprototype.valuesRef = function(scope, field, sort) {\n  return cache(scope, this, 'vals', 'values', field, sort || true);\n};\n\nprototype.lookupRef = function(scope, field) {\n  return cache(scope, this, 'lookup', 'tupleindex', field, false);\n};\n\nprototype.indataRef = function(scope, field) {\n  return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n};\n"]},"metadata":{},"sourceType":"module"}