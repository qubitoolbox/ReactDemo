{"ast":null,"code":"import { isLogarithmic, Time, UTC } from 'vega-scale';\nimport { timeFormat, timeInterval, utcFormat, utcInterval } from 'vega-time';\nimport { error, isNumber, isObject, isString, peek, span } from 'vega-util';\nimport { format as numberFormat, formatSpecifier } from 'd3-format';\n/**\n * Determine the tick count or interval function.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} count - The desired tick count or interval specifier.\n * @param {number} minStep - The desired minimum step between tick values.\n * @return {*} - The tick count or interval function.\n */\n\nexport function tickCount(scale, count, minStep) {\n  var step;\n\n  if (isNumber(count)) {\n    if (scale.bins) {\n      count = Math.max(count, scale.bins.length);\n    }\n\n    if (minStep != null) {\n      count = Math.min(count, ~~(span(scale.domain()) / minStep) || 1);\n    }\n  }\n\n  if (isObject(count)) {\n    step = count.step;\n    count = count.interval;\n  }\n\n  if (isString(count)) {\n    count = scale.type === Time ? timeInterval(count) : scale.type == UTC ? utcInterval(count) : error('Only time and utc scales accept interval strings.');\n    if (step) count = count.every(step);\n  }\n\n  return count;\n}\n/**\n * Filter a set of candidate tick values, ensuring that only tick values\n * that lie within the scale range are included.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {Array<*>} ticks - The candidate tick values.\n * @param {*} count - The tick count or interval function.\n * @return {Array<*>} - The filtered tick values.\n */\n\nexport function validTicks(scale, ticks, count) {\n  var range = scale.range(),\n      lo = Math.floor(range[0]),\n      hi = Math.ceil(peek(range));\n\n  if (lo > hi) {\n    range = hi;\n    hi = lo;\n    lo = range;\n  }\n\n  ticks = ticks.filter(function (v) {\n    v = scale(v);\n    return lo <= v && v <= hi;\n  });\n\n  if (count > 0 && ticks.length > 1) {\n    var endpoints = [ticks[0], peek(ticks)];\n\n    while (ticks.length > count && ticks.length >= 3) {\n      ticks = ticks.filter(function (_, i) {\n        return !(i % 2);\n      });\n    }\n\n    if (ticks.length < 3) {\n      ticks = endpoints;\n    }\n  }\n\n  return ticks;\n}\n/**\n * Generate tick values for the given scale and approximate tick count or\n * interval value. If the scale has a 'ticks' method, it will be used to\n * generate the ticks, with the count argument passed as a parameter. If the\n * scale lacks a 'ticks' method, the full scale domain will be returned.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} [count] - The approximate number of desired ticks.\n * @return {Array<*>} - The generated tick values.\n */\n\nexport function tickValues(scale, count) {\n  return scale.bins ? validTicks(scale, scale.bins) : scale.ticks ? scale.ticks(count) : scale.domain();\n}\n/**\n * Generate a label format function for a scale. If the scale has a\n * 'tickFormat' method, it will be used to generate the formatter, with the\n * count and specifier arguments passed as parameters. If the scale lacks a\n * 'tickFormat' method, the returned formatter performs simple string coercion.\n * If the input scale is a logarithmic scale and the format specifier does not\n * indicate a desired decimal precision, a special variable precision formatter\n * that automatically trims trailing zeroes will be generated.\n * @param {Scale} scale - The scale for which to generate the label formatter.\n * @param {*} [count] - The approximate number of desired ticks.\n * @param {string} [specifier] - The format specifier. Must be a legal d3\n *   specifier string (see https://github.com/d3/d3-format#formatSpecifier) or\n *   time multi-format specifier object.\n * @return {function(*):string} - The generated label formatter.\n */\n\nexport function tickFormat(scale, count, specifier, formatType, noSkip) {\n  var type = scale.type,\n      format = type === Time || formatType === Time ? timeFormat(specifier) : type === UTC || formatType === UTC ? utcFormat(specifier) : scale.tickFormat ? scale.tickFormat(count, specifier) : specifier ? numberFormat(specifier) : String;\n\n  if (isLogarithmic(type)) {\n    var logfmt = variablePrecision(specifier);\n    format = noSkip || scale.bins ? logfmt : filter(format, logfmt);\n  }\n\n  return format;\n}\n\nfunction filter(sourceFormat, targetFormat) {\n  return _ => sourceFormat(_) ? targetFormat(_) : '';\n}\n\nfunction variablePrecision(specifier) {\n  var s = formatSpecifier(specifier || ',');\n\n  if (s.precision == null) {\n    s.precision = 12;\n\n    switch (s.type) {\n      case '%':\n        s.precision -= 2;\n        break;\n\n      case 'e':\n        s.precision -= 1;\n        break;\n    }\n\n    return trimZeroes(numberFormat(s), // number format\n    numberFormat('.1f')(1)[1] // decimal point character\n    );\n  } else {\n    return numberFormat(s);\n  }\n}\n\nfunction trimZeroes(format, decimalChar) {\n  return function (x) {\n    var str = format(x),\n        dec = str.indexOf(decimalChar),\n        idx,\n        end;\n    if (dec < 0) return str;\n    idx = rightmostDigit(str, dec);\n    end = idx < str.length ? str.slice(idx) : '';\n\n    while (--idx > dec) if (str[idx] !== '0') {\n      ++idx;\n      break;\n    }\n\n    return str.slice(0, idx) + end;\n  };\n}\n\nfunction rightmostDigit(str, dec) {\n  var i = str.lastIndexOf('e'),\n      c;\n  if (i > 0) return i;\n\n  for (i = str.length; --i > dec;) {\n    c = str.charCodeAt(i);\n    if (c >= 48 && c <= 57) return i + 1; // is digit\n  }\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-encode/src/ticks.js"],"names":["isLogarithmic","Time","UTC","timeFormat","timeInterval","utcFormat","utcInterval","error","isNumber","isObject","isString","peek","span","format","numberFormat","formatSpecifier","tickCount","scale","count","minStep","step","bins","Math","max","length","min","domain","interval","type","every","validTicks","ticks","range","lo","floor","hi","ceil","filter","v","endpoints","_","i","tickValues","tickFormat","specifier","formatType","noSkip","String","logfmt","variablePrecision","sourceFormat","targetFormat","s","precision","trimZeroes","decimalChar","x","str","dec","indexOf","idx","end","rightmostDigit","slice","lastIndexOf","c","charCodeAt"],"mappings":"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","sourcesContent":["import {isLogarithmic, Time, UTC} from 'vega-scale';\nimport {timeFormat, timeInterval, utcFormat, utcInterval} from 'vega-time';\nimport {error, isNumber, isObject, isString, peek, span} from 'vega-util';\nimport {format as numberFormat, formatSpecifier} from 'd3-format';\n\n/**\n * Determine the tick count or interval function.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} count - The desired tick count or interval specifier.\n * @param {number} minStep - The desired minimum step between tick values.\n * @return {*} - The tick count or interval function.\n */\nexport function tickCount(scale, count, minStep) {\n  var step;\n\n  if (isNumber(count)) {\n    if (scale.bins) {\n      count = Math.max(count, scale.bins.length);\n    }\n    if (minStep != null) {\n      count = Math.min(count, ~~(span(scale.domain()) / minStep) || 1);\n    }\n  }\n\n  if (isObject(count)) {\n    step = count.step;\n    count = count.interval;\n  }\n\n  if (isString(count)) {\n    count = scale.type === Time ? timeInterval(count)\n      : scale.type == UTC ? utcInterval(count)\n      : error('Only time and utc scales accept interval strings.');\n    if (step) count = count.every(step);\n  }\n\n  return count;\n}\n\n/**\n * Filter a set of candidate tick values, ensuring that only tick values\n * that lie within the scale range are included.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {Array<*>} ticks - The candidate tick values.\n * @param {*} count - The tick count or interval function.\n * @return {Array<*>} - The filtered tick values.\n */\nexport function validTicks(scale, ticks, count) {\n  var range = scale.range(),\n      lo = Math.floor(range[0]),\n      hi = Math.ceil(peek(range));\n\n  if (lo > hi) {\n    range = hi;\n    hi = lo;\n    lo = range;\n  }\n\n  ticks = ticks.filter(function(v) {\n    v = scale(v);\n    return lo <= v && v <= hi;\n  });\n\n  if (count > 0 && ticks.length > 1) {\n    var endpoints = [ticks[0], peek(ticks)];\n    while (ticks.length > count && ticks.length >= 3) {\n      ticks = ticks.filter(function(_, i) { return !(i % 2); });\n    }\n    if (ticks.length < 3) {\n      ticks = endpoints;\n    }\n  }\n\n  return ticks;\n}\n\n/**\n * Generate tick values for the given scale and approximate tick count or\n * interval value. If the scale has a 'ticks' method, it will be used to\n * generate the ticks, with the count argument passed as a parameter. If the\n * scale lacks a 'ticks' method, the full scale domain will be returned.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} [count] - The approximate number of desired ticks.\n * @return {Array<*>} - The generated tick values.\n */\nexport function tickValues(scale, count) {\n  return scale.bins ? validTicks(scale, scale.bins)\n    : scale.ticks ? scale.ticks(count)\n    : scale.domain();\n}\n\n/**\n * Generate a label format function for a scale. If the scale has a\n * 'tickFormat' method, it will be used to generate the formatter, with the\n * count and specifier arguments passed as parameters. If the scale lacks a\n * 'tickFormat' method, the returned formatter performs simple string coercion.\n * If the input scale is a logarithmic scale and the format specifier does not\n * indicate a desired decimal precision, a special variable precision formatter\n * that automatically trims trailing zeroes will be generated.\n * @param {Scale} scale - The scale for which to generate the label formatter.\n * @param {*} [count] - The approximate number of desired ticks.\n * @param {string} [specifier] - The format specifier. Must be a legal d3\n *   specifier string (see https://github.com/d3/d3-format#formatSpecifier) or\n *   time multi-format specifier object.\n * @return {function(*):string} - The generated label formatter.\n */\nexport function tickFormat(scale, count, specifier, formatType, noSkip) {\n  var type = scale.type,\n      format = (type === Time || formatType === Time) ? timeFormat(specifier)\n        : (type === UTC || formatType === UTC) ? utcFormat(specifier)\n        : scale.tickFormat ? scale.tickFormat(count, specifier)\n        : specifier ? numberFormat(specifier)\n        : String;\n\n  if (isLogarithmic(type)) {\n    var logfmt = variablePrecision(specifier);\n    format = noSkip || scale.bins ? logfmt : filter(format, logfmt);\n  }\n\n  return format;\n}\n\nfunction filter(sourceFormat, targetFormat) {\n  return _ => sourceFormat(_) ? targetFormat(_) : '';\n}\n\nfunction variablePrecision(specifier) {\n  var s = formatSpecifier(specifier || ',');\n\n  if (s.precision == null) {\n    s.precision = 12;\n    switch (s.type) {\n      case '%': s.precision -= 2; break;\n      case 'e': s.precision -= 1; break;\n    }\n    return trimZeroes(\n      numberFormat(s),          // number format\n      numberFormat('.1f')(1)[1] // decimal point character\n    );\n  } else {\n    return numberFormat(s);\n  }\n}\n\nfunction trimZeroes(format, decimalChar) {\n  return function(x) {\n    var str = format(x),\n        dec = str.indexOf(decimalChar),\n        idx, end;\n\n    if (dec < 0) return str;\n\n    idx = rightmostDigit(str, dec);\n    end = idx < str.length ? str.slice(idx) : '';\n    while (--idx > dec) if (str[idx] !== '0') { ++idx; break; }\n\n    return str.slice(0, idx) + end;\n  };\n}\n\nfunction rightmostDigit(str, dec) {\n  var i = str.lastIndexOf('e'), c;\n  if (i > 0) return i;\n  for (i=str.length; --i > dec;) {\n    c = str.charCodeAt(i);\n    if (c >= 48 && c <= 57) return i + 1; // is digit\n  }\n}\n"]},"metadata":{},"sourceType":"module"}