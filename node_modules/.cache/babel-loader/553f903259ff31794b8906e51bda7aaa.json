{"ast":null,"code":"import { array, isString } from 'vega-util';\nimport * as log from '../../log';\nimport { isLookupData, isLookupSelection } from '../../transform';\nimport { duplicate, hash, varName } from '../../util';\nimport { DataFlowNode, OutputNode } from './dataflow';\nimport { findSource } from './parse';\nimport { SourceNode } from './source';\nexport class LookupNode extends DataFlowNode {\n  constructor(parent, transform, secondary) {\n    super(parent);\n    this.transform = transform;\n    this.secondary = secondary;\n  }\n\n  clone() {\n    return new LookupNode(null, duplicate(this.transform), this.secondary);\n  }\n\n  static make(parent, model, transform, counter) {\n    var _a;\n\n    const sources = model.component.data.sources;\n    const {\n      from\n    } = transform;\n    let fromOutputNode = null;\n\n    if (isLookupData(from)) {\n      let fromSource = findSource(from.data, sources);\n\n      if (!fromSource) {\n        fromSource = new SourceNode(from.data);\n        sources.push(fromSource);\n      }\n\n      const fromOutputName = model.getName(`lookup_${counter}`);\n      fromOutputNode = new OutputNode(fromSource, fromOutputName, 'lookup', model.component.data.outputNodeRefCounts);\n      model.component.data.outputNodes[fromOutputName] = fromOutputNode;\n    } else if (isLookupSelection(from)) {\n      const selName = from.selection;\n      transform.as = (_a = transform.as, _a !== null && _a !== void 0 ? _a : selName);\n      fromOutputNode = model.getSelectionComponent(varName(selName), selName).materialized;\n\n      if (!fromOutputNode) {\n        throw new Error(log.message.noSameUnitLookup(selName));\n      }\n    }\n\n    return new LookupNode(parent, transform, fromOutputNode.getSource());\n  }\n\n  dependentFields() {\n    return new Set([this.transform.lookup]);\n  }\n\n  producedFields() {\n    return new Set(this.transform.as ? array(this.transform.as) : this.transform.from.fields);\n  }\n\n  hash() {\n    return `Lookup ${hash({\n      transform: this.transform,\n      secondary: this.secondary\n    })}`;\n  }\n\n  assemble() {\n    let foreign;\n\n    if (this.transform.from.fields) {\n      // lookup a few fields and add create a flat output\n      foreign = Object.assign({\n        values: this.transform.from.fields\n      }, this.transform.as ? {\n        as: array(this.transform.as)\n      } : {});\n    } else {\n      // lookup full record and nest it\n      let asName = this.transform.as;\n\n      if (!isString(asName)) {\n        log.warn(log.message.NO_FIELDS_NEEDS_AS);\n        asName = '_lookup';\n      }\n\n      foreign = {\n        as: [asName]\n      };\n    }\n\n    return Object.assign(Object.assign({\n      type: 'lookup',\n      from: this.secondary,\n      key: this.transform.from.key,\n      fields: [this.transform.lookup]\n    }, foreign), this.transform.default ? {\n      default: this.transform.default\n    } : {});\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/lookup.ts"],"names":[],"mappings":"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","sourcesContent":["import {LookupTransform as VgLookupTransform} from 'vega';\nimport {array, isString} from 'vega-util';\nimport * as log from '../../log';\nimport {isLookupData, isLookupSelection, LookupTransform} from '../../transform';\nimport {duplicate, hash, varName} from '../../util';\nimport {Model} from '../model';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {findSource} from './parse';\nimport {SourceNode} from './source';\n\nexport class LookupNode extends DataFlowNode {\n  public clone() {\n    return new LookupNode(null, duplicate(this.transform), this.secondary);\n  }\n\n  constructor(parent: DataFlowNode, public readonly transform: LookupTransform, public readonly secondary: string) {\n    super(parent);\n  }\n\n  public static make(parent: DataFlowNode, model: Model, transform: LookupTransform, counter: number) {\n    const sources = model.component.data.sources;\n    const {from} = transform;\n    let fromOutputNode = null;\n\n    if (isLookupData(from)) {\n      let fromSource = findSource(from.data, sources);\n\n      if (!fromSource) {\n        fromSource = new SourceNode(from.data);\n        sources.push(fromSource);\n      }\n\n      const fromOutputName = model.getName(`lookup_${counter}`);\n      fromOutputNode = new OutputNode(fromSource, fromOutputName, 'lookup', model.component.data.outputNodeRefCounts);\n      model.component.data.outputNodes[fromOutputName] = fromOutputNode;\n    } else if (isLookupSelection(from)) {\n      const selName = from.selection;\n      transform.as = transform.as ?? selName;\n      fromOutputNode = model.getSelectionComponent(varName(selName), selName).materialized;\n      if (!fromOutputNode) {\n        throw new Error(log.message.noSameUnitLookup(selName));\n      }\n    }\n\n    return new LookupNode(parent, transform, fromOutputNode.getSource());\n  }\n\n  public dependentFields() {\n    return new Set([this.transform.lookup]);\n  }\n\n  public producedFields() {\n    return new Set(this.transform.as ? array(this.transform.as) : this.transform.from.fields);\n  }\n\n  public hash() {\n    return `Lookup ${hash({transform: this.transform, secondary: this.secondary})}`;\n  }\n\n  public assemble(): VgLookupTransform {\n    let foreign: Partial<VgLookupTransform>;\n\n    if (this.transform.from.fields) {\n      // lookup a few fields and add create a flat output\n      foreign = {\n        values: this.transform.from.fields,\n        ...(this.transform.as ? {as: array(this.transform.as)} : {})\n      };\n    } else {\n      // lookup full record and nest it\n      let asName = this.transform.as;\n      if (!isString(asName)) {\n        log.warn(log.message.NO_FIELDS_NEEDS_AS);\n        asName = '_lookup';\n      }\n\n      foreign = {\n        as: [asName]\n      };\n    }\n\n    return {\n      type: 'lookup',\n      from: this.secondary,\n      key: this.transform.from.key,\n      fields: [this.transform.lookup],\n      ...foreign,\n      ...(this.transform.default ? {default: this.transform.default} : {})\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}