{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst base64_js_1 = require(\"base64-js\");\n\nconst PATH_SEPARATOR = '/';\nconst PATH_PREFIX = 'tensorflowjs_models';\nconst INFO_SUFFIX = 'info';\nconst MODEL_SUFFIX = 'model_without_weight';\nconst WEIGHT_DATA_SUFFIX = 'weight_data';\n\nfunction getModelKeys(path) {\n  return {\n    info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),\n    modelArtifactsWithoutWeights: [PATH_PREFIX, path, MODEL_SUFFIX].join(PATH_SEPARATOR),\n    weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR)\n  };\n}\n/**\n * Populate ModelArtifactsInfo fields for a model with JSON topology.\n * @param modelArtifacts\n * @returns A ModelArtifactsInfo object.\n */\n\n\nfunction getModelArtifactsInfoForJSON(modelArtifacts) {\n  if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n    throw new Error('Expected JSON model topology, received ArrayBuffer.');\n  }\n\n  return {\n    dateSaved: new Date(),\n    // TODO followup on removing this from the the interface\n    modelTopologyType: 'JSON',\n    weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength\n  };\n}\n\nclass AsyncStorageHandler {\n  constructor(modelPath) {\n    this.modelPath = modelPath;\n\n    if (modelPath == null || !modelPath) {\n      throw new Error('modelPath must not be null, undefined or empty.');\n    }\n\n    this.keys = getModelKeys(this.modelPath); // We import this dynamically because it binds to a native library that\n    // needs to be installed by the user if they use this handler. We don't\n    // want users who are not using AsyncStorage to have to install this\n    // library.\n\n    this.asyncStorage = // tslint:disable-next-line:no-require-imports\n    require('@react-native-community/async-storage').default;\n  }\n  /**\n   * Save model artifacts to AsyncStorage\n   *\n   * @param modelArtifacts The model artifacts to be stored.\n   * @returns An instance of SaveResult.\n   */\n\n\n  async save(modelArtifacts) {\n    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n      throw new Error('AsyncStorageHandler.save() does not support saving model topology ' + 'in binary format.');\n    } else {\n      // We save three items separately for each model,\n      // a ModelArtifactsInfo, a ModelArtifacts without weights\n      // and the model weights.\n      const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);\n\n      const {\n        weightData\n      } = modelArtifacts,\n            modelArtifactsWithoutWeights = __rest(modelArtifacts, [\"weightData\"]);\n\n      try {\n        this.asyncStorage.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));\n        this.asyncStorage.setItem(this.keys.modelArtifactsWithoutWeights, JSON.stringify(modelArtifactsWithoutWeights));\n        this.asyncStorage.setItem(this.keys.weightData, base64_js_1.fromByteArray(new Uint8Array(weightData)));\n        return {\n          modelArtifactsInfo\n        };\n      } catch (err) {\n        // If saving failed, clean up all items saved so far.\n        this.asyncStorage.removeItem(this.keys.info);\n        this.asyncStorage.removeItem(this.keys.weightData);\n        this.asyncStorage.removeItem(this.keys.modelArtifactsWithoutWeights);\n        throw new Error(`Failed to save model '${this.modelPath}' to AsyncStorage.\n            Error info ${err}`);\n      }\n    }\n  }\n  /**\n   * Load a model from local storage.\n   *\n   * See the documentation to `browserLocalStorage` for details on the saved\n   * artifacts.\n   *\n   * @returns The loaded model (if loading succeeds).\n   */\n\n\n  async load() {\n    const info = JSON.parse((await this.asyncStorage.getItem(this.keys.info)));\n\n    if (info == null) {\n      throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);\n    }\n\n    if (info.modelTopologyType !== 'JSON') {\n      throw new Error('BrowserLocalStorage does not support loading non-JSON model ' + 'topology yet.');\n    }\n\n    const modelArtifacts = JSON.parse((await this.asyncStorage.getItem(this.keys.modelArtifactsWithoutWeights))); // Load weight data.\n\n    const weightDataBase64 = await this.asyncStorage.getItem(this.keys.weightData);\n\n    if (weightDataBase64 == null) {\n      throw new Error(`In local storage, the binary weight values of model ` + `'${this.modelPath}' are missing.`);\n    }\n\n    modelArtifacts.weightData = base64_js_1.toByteArray(weightDataBase64).buffer;\n    return modelArtifacts;\n  }\n\n}\n/**\n * Factory function for AsyncStorage IOHandler.\n *\n * This `IOHandler` supports both `save` and `load`.\n *\n * For each model's saved artifacts, three items are saved to async storage.\n *   - `tensorflowjs_models/${modelPath}/info`: Contains meta-info about the\n *     model, such as date saved, type of the topology, size in bytes, etc.\n *   - `tensorflowjs_models/${modelPath}/model_without_weight`: The topology,\n *     weights_specs and all other information about the model except for the\n *     weights.\n *   - `tensorflowjs_models/${modelPath}/weight_data`: Concatenated binary\n *     weight values, stored as a base64-encoded string.\n *\n * ```js\n *  async function asyncStorageExample() {\n *    // Define a model\n *    const model = tf.sequential();\n *    model.add(tf.layers.dense({units: 5, inputShape: [1]}));\n *    model.add(tf.layers.dense({units: 1}));\n *    model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *    // Save the model to async storage\n *    await model.save(asyncStorageIO('custom-model-test'));\n *    // Load the model from async storage\n *    await tf.loadLayersModel(asyncStorageIO('custom-model-test'));\n * }\n * ```\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `IOHandler`\n */\n\n/** @doc {heading: 'Models', subheading: 'IOHandlers'} */\n\n\nfunction asyncStorageIO(modelPath) {\n  return new AsyncStorageHandler(modelPath);\n}\n\nexports.asyncStorageIO = asyncStorageIO;","map":{"version":3,"sources":["../src/async_storage_io.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64_js_1 = require(\"base64-js\");\nconst PATH_SEPARATOR = '/';\nconst PATH_PREFIX = 'tensorflowjs_models';\nconst INFO_SUFFIX = 'info';\nconst MODEL_SUFFIX = 'model_without_weight';\nconst WEIGHT_DATA_SUFFIX = 'weight_data';\nfunction getModelKeys(path) {\n    return {\n        info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),\n        modelArtifactsWithoutWeights: [PATH_PREFIX, path, MODEL_SUFFIX].join(PATH_SEPARATOR),\n        weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),\n    };\n}\n/**\n * Populate ModelArtifactsInfo fields for a model with JSON topology.\n * @param modelArtifacts\n * @returns A ModelArtifactsInfo object.\n */\nfunction getModelArtifactsInfoForJSON(modelArtifacts) {\n    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n        throw new Error('Expected JSON model topology, received ArrayBuffer.');\n    }\n    return {\n        dateSaved: new Date(),\n        // TODO followup on removing this from the the interface\n        modelTopologyType: 'JSON',\n        weightDataBytes: modelArtifacts.weightData == null ?\n            0 :\n            modelArtifacts.weightData.byteLength,\n    };\n}\nclass AsyncStorageHandler {\n    constructor(modelPath) {\n        this.modelPath = modelPath;\n        if (modelPath == null || !modelPath) {\n            throw new Error('modelPath must not be null, undefined or empty.');\n        }\n        this.keys = getModelKeys(this.modelPath);\n        // We import this dynamically because it binds to a native library that\n        // needs to be installed by the user if they use this handler. We don't\n        // want users who are not using AsyncStorage to have to install this\n        // library.\n        this.asyncStorage =\n            // tslint:disable-next-line:no-require-imports\n            require('@react-native-community/async-storage').default;\n    }\n    /**\n     * Save model artifacts to AsyncStorage\n     *\n     * @param modelArtifacts The model artifacts to be stored.\n     * @returns An instance of SaveResult.\n     */\n    async save(modelArtifacts) {\n        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n            throw new Error('AsyncStorageHandler.save() does not support saving model topology ' +\n                'in binary format.');\n        }\n        else {\n            // We save three items separately for each model,\n            // a ModelArtifactsInfo, a ModelArtifacts without weights\n            // and the model weights.\n            const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);\n            const { weightData } = modelArtifacts, modelArtifactsWithoutWeights = __rest(modelArtifacts, [\"weightData\"]);\n            try {\n                this.asyncStorage.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));\n                this.asyncStorage.setItem(this.keys.modelArtifactsWithoutWeights, JSON.stringify(modelArtifactsWithoutWeights));\n                this.asyncStorage.setItem(this.keys.weightData, base64_js_1.fromByteArray(new Uint8Array(weightData)));\n                return { modelArtifactsInfo };\n            }\n            catch (err) {\n                // If saving failed, clean up all items saved so far.\n                this.asyncStorage.removeItem(this.keys.info);\n                this.asyncStorage.removeItem(this.keys.weightData);\n                this.asyncStorage.removeItem(this.keys.modelArtifactsWithoutWeights);\n                throw new Error(`Failed to save model '${this.modelPath}' to AsyncStorage.\n            Error info ${err}`);\n            }\n        }\n    }\n    /**\n     * Load a model from local storage.\n     *\n     * See the documentation to `browserLocalStorage` for details on the saved\n     * artifacts.\n     *\n     * @returns The loaded model (if loading succeeds).\n     */\n    async load() {\n        const info = JSON.parse(await this.asyncStorage.getItem(this.keys.info));\n        if (info == null) {\n            throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);\n        }\n        if (info.modelTopologyType !== 'JSON') {\n            throw new Error('BrowserLocalStorage does not support loading non-JSON model ' +\n                'topology yet.');\n        }\n        const modelArtifacts = JSON.parse(await this.asyncStorage.getItem(this.keys.modelArtifactsWithoutWeights));\n        // Load weight data.\n        const weightDataBase64 = await this.asyncStorage.getItem(this.keys.weightData);\n        if (weightDataBase64 == null) {\n            throw new Error(`In local storage, the binary weight values of model ` +\n                `'${this.modelPath}' are missing.`);\n        }\n        modelArtifacts.weightData = base64_js_1.toByteArray(weightDataBase64).buffer;\n        return modelArtifacts;\n    }\n}\n/**\n * Factory function for AsyncStorage IOHandler.\n *\n * This `IOHandler` supports both `save` and `load`.\n *\n * For each model's saved artifacts, three items are saved to async storage.\n *   - `tensorflowjs_models/${modelPath}/info`: Contains meta-info about the\n *     model, such as date saved, type of the topology, size in bytes, etc.\n *   - `tensorflowjs_models/${modelPath}/model_without_weight`: The topology,\n *     weights_specs and all other information about the model except for the\n *     weights.\n *   - `tensorflowjs_models/${modelPath}/weight_data`: Concatenated binary\n *     weight values, stored as a base64-encoded string.\n *\n * ```js\n *  async function asyncStorageExample() {\n *    // Define a model\n *    const model = tf.sequential();\n *    model.add(tf.layers.dense({units: 5, inputShape: [1]}));\n *    model.add(tf.layers.dense({units: 1}));\n *    model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *    // Save the model to async storage\n *    await model.save(asyncStorageIO('custom-model-test'));\n *    // Load the model from async storage\n *    await tf.loadLayersModel(asyncStorageIO('custom-model-test'));\n * }\n * ```\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `IOHandler`\n */\n/** @doc {heading: 'Models', subheading: 'IOHandlers'} */\nfunction asyncStorageIO(modelPath) {\n    return new AsyncStorageHandler(modelPath);\n}\nexports.asyncStorageIO = asyncStorageIO;\n//# sourceMappingURL=async_storage_io.js.map"]},"metadata":{},"sourceType":"script"}