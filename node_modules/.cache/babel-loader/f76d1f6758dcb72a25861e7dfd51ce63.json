{"ast":null,"code":"export var RawCode = 'RawCode';\nexport var Literal = 'Literal';\nexport var Property = 'Property';\nexport var Identifier = 'Identifier';\nexport var ArrayExpression = 'ArrayExpression';\nexport var BinaryExpression = 'BinaryExpression';\nexport var CallExpression = 'CallExpression';\nexport var ConditionalExpression = 'ConditionalExpression';\nexport var LogicalExpression = 'LogicalExpression';\nexport var MemberExpression = 'MemberExpression';\nexport var ObjectExpression = 'ObjectExpression';\nexport var UnaryExpression = 'UnaryExpression';\nexport default function ASTNode(type) {\n  this.type = type;\n}\n\nASTNode.prototype.visit = function (visitor) {\n  var node = this,\n      c,\n      i,\n      n;\n  if (visitor(node)) return 1;\n\n  for (c = children(node), i = 0, n = c.length; i < n; ++i) {\n    if (c[i].visit(visitor)) return 1;\n  }\n};\n\nfunction children(node) {\n  switch (node.type) {\n    case ArrayExpression:\n      return node.elements;\n\n    case BinaryExpression:\n    case LogicalExpression:\n      return [node.left, node.right];\n\n    case CallExpression:\n      var args = node.arguments.slice();\n      args.unshift(node.callee);\n      return args;\n\n    case ConditionalExpression:\n      return [node.test, node.consequent, node.alternate];\n\n    case MemberExpression:\n      return [node.object, node.property];\n\n    case ObjectExpression:\n      return node.properties;\n\n    case Property:\n      return [node.key, node.value];\n\n    case UnaryExpression:\n      return [node.argument];\n\n    case Identifier:\n    case Literal:\n    case RawCode:\n    default:\n      return [];\n  }\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-expression/src/ast.js"],"names":["RawCode","Literal","Property","Identifier","ArrayExpression","BinaryExpression","CallExpression","ConditionalExpression","LogicalExpression","MemberExpression","ObjectExpression","UnaryExpression","ASTNode","type","prototype","visit","visitor","node","c","i","n","children","length","elements","left","right","args","arguments","slice","unshift","callee","test","consequent","alternate","object","property","properties","key","value","argument"],"mappings":"AAAA,OAAO,IAAIA,OAAO,GAAG,SAAd;AACP,OAAO,IAAIC,OAAO,GAAG,SAAd;AACP,OAAO,IAAIC,QAAQ,GAAG,UAAf;AACP,OAAO,IAAIC,UAAU,GAAG,YAAjB;AAEP,OAAO,IAAIC,eAAe,GAAG,iBAAtB;AACP,OAAO,IAAIC,gBAAgB,GAAG,kBAAvB;AACP,OAAO,IAAIC,cAAc,GAAG,gBAArB;AACP,OAAO,IAAIC,qBAAqB,GAAG,uBAA5B;AACP,OAAO,IAAIC,iBAAiB,GAAG,mBAAxB;AACP,OAAO,IAAIC,gBAAgB,GAAG,kBAAvB;AACP,OAAO,IAAIC,gBAAgB,GAAG,kBAAvB;AACP,OAAO,IAAIC,eAAe,GAAG,iBAAtB;AAEP,eAAe,SAASC,OAAT,CAAiBC,IAAjB,EAAuB;AACpC,OAAKA,IAAL,GAAYA,IAAZ;AACD;;AAEDD,OAAO,CAACE,SAAR,CAAkBC,KAAlB,GAA0B,UAASC,OAAT,EAAkB;AAC1C,MAAIC,IAAI,GAAG,IAAX;AAAA,MAAiBC,CAAjB;AAAA,MAAoBC,CAApB;AAAA,MAAuBC,CAAvB;AAEA,MAAIJ,OAAO,CAACC,IAAD,CAAX,EAAmB,OAAO,CAAP;;AAEnB,OAAKC,CAAC,GAACG,QAAQ,CAACJ,IAAD,CAAV,EAAkBE,CAAC,GAAC,CAApB,EAAuBC,CAAC,GAACF,CAAC,CAACI,MAAhC,EAAwCH,CAAC,GAACC,CAA1C,EAA6C,EAAED,CAA/C,EAAkD;AAChD,QAAID,CAAC,CAACC,CAAD,CAAD,CAAKJ,KAAL,CAAWC,OAAX,CAAJ,EAAyB,OAAO,CAAP;AAC1B;AACF,CARD;;AAUA,SAASK,QAAT,CAAkBJ,IAAlB,EAAwB;AACtB,UAAQA,IAAI,CAACJ,IAAb;AACE,SAAKT,eAAL;AACE,aAAOa,IAAI,CAACM,QAAZ;;AACF,SAAKlB,gBAAL;AACA,SAAKG,iBAAL;AACE,aAAO,CAACS,IAAI,CAACO,IAAN,EAAYP,IAAI,CAACQ,KAAjB,CAAP;;AACF,SAAKnB,cAAL;AACE,UAAIoB,IAAI,GAAGT,IAAI,CAACU,SAAL,CAAeC,KAAf,EAAX;AACAF,MAAAA,IAAI,CAACG,OAAL,CAAaZ,IAAI,CAACa,MAAlB;AACA,aAAOJ,IAAP;;AACF,SAAKnB,qBAAL;AACE,aAAO,CAACU,IAAI,CAACc,IAAN,EAAYd,IAAI,CAACe,UAAjB,EAA6Bf,IAAI,CAACgB,SAAlC,CAAP;;AACF,SAAKxB,gBAAL;AACE,aAAO,CAACQ,IAAI,CAACiB,MAAN,EAAcjB,IAAI,CAACkB,QAAnB,CAAP;;AACF,SAAKzB,gBAAL;AACE,aAAOO,IAAI,CAACmB,UAAZ;;AACF,SAAKlC,QAAL;AACE,aAAO,CAACe,IAAI,CAACoB,GAAN,EAAWpB,IAAI,CAACqB,KAAhB,CAAP;;AACF,SAAK3B,eAAL;AACE,aAAO,CAACM,IAAI,CAACsB,QAAN,CAAP;;AACF,SAAKpC,UAAL;AACA,SAAKF,OAAL;AACA,SAAKD,OAAL;AACA;AACE,aAAO,EAAP;AAxBJ;AA0BD","sourcesContent":["export var RawCode = 'RawCode';\nexport var Literal = 'Literal';\nexport var Property = 'Property';\nexport var Identifier = 'Identifier';\n\nexport var ArrayExpression = 'ArrayExpression';\nexport var BinaryExpression = 'BinaryExpression';\nexport var CallExpression = 'CallExpression';\nexport var ConditionalExpression = 'ConditionalExpression';\nexport var LogicalExpression = 'LogicalExpression';\nexport var MemberExpression = 'MemberExpression';\nexport var ObjectExpression = 'ObjectExpression';\nexport var UnaryExpression = 'UnaryExpression';\n\nexport default function ASTNode(type) {\n  this.type = type;\n}\n\nASTNode.prototype.visit = function(visitor) {\n  var node = this, c, i, n;\n\n  if (visitor(node)) return 1;\n\n  for (c=children(node), i=0, n=c.length; i<n; ++i) {\n    if (c[i].visit(visitor)) return 1;\n  }\n};\n\nfunction children(node) {\n  switch (node.type) {\n    case ArrayExpression:\n      return node.elements;\n    case BinaryExpression:\n    case LogicalExpression:\n      return [node.left, node.right];\n    case CallExpression:\n      var args = node.arguments.slice();\n      args.unshift(node.callee);\n      return args;\n    case ConditionalExpression:\n      return [node.test, node.consequent, node.alternate];\n    case MemberExpression:\n      return [node.object, node.property];\n    case ObjectExpression:\n      return node.properties;\n    case Property:\n      return [node.key, node.value];\n    case UnaryExpression:\n      return [node.argument];\n    case Identifier:\n    case Literal:\n    case RawCode:\n    default:\n      return [];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}