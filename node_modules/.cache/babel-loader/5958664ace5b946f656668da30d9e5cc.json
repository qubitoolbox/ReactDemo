{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isObject, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, SHARED_DOMAIN_OP_INDEX, MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX } from '../../aggregate';\nimport { isBinning, isSelectionExtent, isBinParams } from '../../bin';\nimport { getSecondaryRangeChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBand, valueExpr, vgField } from '../../channeldef';\nimport { MAIN, RAW } from '../../data';\nimport * as log from '../../log';\nimport { hasDiscreteDomain, isSelectionDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortArray, isSortByEncoding, isSortField } from '../../sort';\nimport * as util from '../../util';\nimport { isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { FACET_SCALE_PREFIX } from '../data/optimize';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit, mergeValuesWithExplicit } from '../split';\nexport function parseScaleDomain(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model) {\n  const localScaleComponents = model.component.scales;\n  util.keys(localScaleComponents).forEach(channel => {\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.setWithExplicit('domains', domains);\n    parseSelectionDomain(model, channel);\n\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent = model;\n\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n\n      const resolve = facetParent.component.resolve.scale[channel];\n\n      if (resolve === 'shared') {\n        for (const domain of domains.value) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction parseNonUnitScaleDomain(model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n\n  const localScaleComponents = model.component.scales;\n  util.keys(localScaleComponents).forEach(channel => {\n    let domains;\n    let selectionExtent = null;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.getWithExplicit('domains');\n        } else {\n          domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit('domains'), 'domains', 'scale', domainsTieBreaker);\n        }\n\n        const se = childComponent.get('selectionExtent');\n\n        if (selectionExtent && se && selectionExtent.selection !== se.selection) {\n          log.warn('The same selection must be used to override scale domains in a layered view.');\n        }\n\n        selectionExtent = se;\n      }\n    }\n\n    localScaleComponents[channel].setWithExplicit('domains', domains);\n\n    if (selectionExtent) {\n      localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n    }\n  });\n}\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\n\n\nfunction normalizeUnaggregatedDomain(domain, fieldDef, scaleType, scaleConfig) {\n  if (domain === 'unaggregated') {\n    const {\n      valid,\n      reason\n    } = canUseUnaggregatedDomain(fieldDef, scaleType);\n\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {\n      valid\n    } = canUseUnaggregatedDomain(fieldDef, scaleType);\n\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model, channel) {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const domain = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.fieldDef(channel), scaleType, model.config.scale);\n\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), {\n      domain\n    });\n  } // If channel is either X or Y then union them with X2 & Y2 if they exist\n\n\n  if (channel === 'x' && model.channelHasField('x2')) {\n    if (model.channelHasField('x')) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'x'), parseSingleChannelDomain(scaleType, domain, model, 'x2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && model.channelHasField('y2')) {\n    if (model.channelHasField('y')) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'y'), parseSingleChannelDomain(scaleType, domain, model, 'y2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal(domain, type, timeUnit) {\n  return domain.map(v => {\n    const data = valueExpr(v, {\n      timeUnit,\n      type\n    });\n    return {\n      signal: `{data: ${data}}`\n    };\n  });\n}\n\nfunction parseSingleChannelDomain(scaleType, domain, model, channel) {\n  const fieldDef = model.fieldDef(channel);\n\n  if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) {\n    // explicit value\n    const {\n      type,\n      timeUnit\n    } = fieldDef;\n\n    if (type === 'temporal' || timeUnit) {\n      return makeExplicit(mapDomainToDataSignal(domain, type, timeUnit));\n    }\n\n    return makeExplicit([domain]);\n  }\n\n  const stack = model.stack;\n\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n\n    const data = model.requestDataName(MAIN);\n    return makeImplicit([{\n      data,\n      field: model.vgField(channel, {\n        suffix: 'start'\n      })\n    }, {\n      data,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  }\n\n  const sort = isScaleChannel(channel) ? domainSort(model, channel, scaleType) : undefined;\n\n  if (domain === 'unaggregated') {\n    const data = model.requestDataName(MAIN);\n    const {\n      field\n    } = fieldDef;\n    return makeImplicit([{\n      data,\n      field: vgField({\n        field,\n        aggregate: 'min'\n      })\n    }, {\n      data,\n      field: vgField({\n        field,\n        aggregate: 'max'\n      })\n    }]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      } // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n\n\n      return makeImplicit([{\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n        // Use range if we added it and the scale does not support computing a range as a signal.\n        field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {\n          binSuffix: 'range'\n        } : {}),\n        // we have to use a sort object if sort = true to make the sort correct by bin start\n        sort: sort === true || !isObject(sort) ? {\n          field: model.vgField(channel, {}),\n          op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n\n        } : sort\n      }]);\n    } else {\n      // continuous scales\n      const {\n        bin\n      } = fieldDef;\n\n      if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([new SignalRefWrapper(() => {\n          const signal = model.getSignalName(binSignal);\n          return `[${signal}.start, ${signal}.stop]`;\n        })]);\n      } else {\n        return makeImplicit([{\n          data: model.requestDataName(MAIN),\n          field: model.vgField(channel, {})\n        }]);\n      }\n    }\n  } else if (fieldDef.timeUnit && util.contains(['time', 'utc'], scaleType) && hasBand(channel, fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined, model.markDef, model.config)) {\n    const data = model.requestDataName(MAIN);\n    return makeImplicit([{\n      data,\n      field: model.vgField(channel)\n    }, {\n      data,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  } else if (sort) {\n    return makeImplicit([{\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n      field: model.vgField(channel),\n      sort: sort\n    }]);\n  } else {\n    return makeImplicit([{\n      data: model.requestDataName(MAIN),\n      field: model.vgField(channel)\n    }]);\n  }\n}\n\nfunction normalizeSortField(sort, isStacked) {\n  const {\n    op,\n    field,\n    order\n  } = sort;\n  return Object.assign(Object.assign({\n    // Apply default op\n    op: op !== null && op !== void 0 ? op : isStacked ? 'sum' : DEFAULT_SORT_OP\n  }, field ? {\n    field: util.replacePathInField(field)\n  } : {}), order ? {\n    order\n  } : {});\n}\n\nfunction parseSelectionDomain(model, channel) {\n  const scale = model.component.scales[channel];\n  const spec = model.specifiedScales[channel].domain;\n  const bin = model.fieldDef(channel).bin;\n  const domain = isSelectionDomain(spec) && spec;\n  const extent = isBinParams(bin) && isSelectionExtent(bin.extent) && bin.extent;\n\n  if (domain || extent) {\n    // As scale parsing occurs before selection parsing, we cannot set\n    // domainRaw directly. So instead, we store the selectionExtent on\n    // the scale component, and then add domainRaw during scale assembly.\n    scale.set('selectionExtent', domain !== null && domain !== void 0 ? domain : extent, true);\n  }\n}\n\nexport function domainSort(model, channel, scaleType) {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  } // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n\n\n  const fieldDef = model.fieldDef(channel);\n  const sort = fieldDef.sort; // if the sort is specified with array, use the derived sort index field\n\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  const isStacked = model.stack !== null; // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n\n  if (isSortField(sort)) {\n    return normalizeSortField(sort, isStacked);\n  } else if (isSortByEncoding(sort)) {\n    const {\n      encoding,\n      order\n    } = sort;\n    const fieldDefToSortBy = model.fieldDef(encoding);\n    const {\n      aggregate,\n      field\n    } = fieldDefToSortBy;\n\n    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n      return normalizeSortField({\n        field: vgField(fieldDefToSortBy),\n        order\n      }, isStacked);\n    } else if (isAggregateOp(aggregate) || !aggregate) {\n      return normalizeSortField({\n        op: aggregate,\n        field,\n        order\n      }, isStacked);\n    }\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined\n  /* default =ascending*/\n  ], sort)) {\n    return true;\n  } // sort == null\n\n\n  return undefined;\n}\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\n\nexport function canUseUnaggregatedDomain(fieldDef, scaleType) {\n  const {\n    aggregate,\n    type\n  } = fieldDef;\n\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (isString(aggregate) && !SHARED_DOMAIN_OP_INDEX[aggregate]) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {\n    valid: true\n  };\n}\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\n\nfunction domainsTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  } // If equal score, concat the domains so that we union them later.\n\n\n  return {\n    explicit: v1.explicit,\n    value: [...v1.value, ...v2.value]\n  };\n}\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\n\n\nexport function mergeDomains(domains) {\n  const uniqueDomains = util.unique(domains.map(domain => {\n    // ignore sort property when computing the unique domains\n    if (isDataRefDomain(domain)) {\n      const {\n        sort: _s\n      } = domain,\n            domainWithoutSort = __rest(domain, [\"sort\"]);\n\n      return domainWithoutSort;\n    }\n\n    return domain;\n  }), util.hash);\n  const sorts = util.unique(domains.map(d => {\n    if (isDataRefDomain(d)) {\n      const s = d.sort;\n\n      if (s !== undefined && !util.isBoolean(s)) {\n        if ('op' in s && s.op === 'count') {\n          // let's make sure that if op is count, we don't use a field\n          delete s.field;\n        }\n\n        if (s.order === 'ascending') {\n          // drop order: ascending as it is the default\n          delete s.order;\n        }\n      }\n\n      return s;\n    }\n\n    return undefined;\n  }).filter(s => s !== undefined), util.hash);\n\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        sort = true;\n      }\n\n      return Object.assign(Object.assign({}, domain), {\n        sort\n      });\n    }\n\n    return domain;\n  } // only keep sort properties that work with unioned domains\n\n\n  const unionDomainSorts = util.unique(sorts.map(s => {\n    if (util.isBoolean(s) || !('op' in s) || s.op in UNIONDOMAIN_SORT_OP_INDEX) {\n      return s;\n    }\n\n    log.warn(log.message.domainSortDropped(s));\n    return true;\n  }), util.hash);\n  let sort;\n\n  if (unionDomainSorts.length === 1) {\n    sort = unionDomainSorts[0];\n  } else if (unionDomainSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  const allData = util.unique(domains.map(d => {\n    if (isDataRefDomain(d)) {\n      return d.data;\n    }\n\n    return null;\n  }), x => x);\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain = Object.assign({\n      data: allData[0],\n      fields: uniqueDomains.map(d => d.field)\n    }, sort ? {\n      sort\n    } : {});\n    return domain;\n  }\n\n  return Object.assign({\n    fields: uniqueDomains\n  }, sort ? {\n    sort\n  } : {});\n}\n/**\n * Return a field if a scale single field.\n * Return `undefined` otherwise.\n *\n */\n\nexport function getFieldFromDomain(domain) {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn('Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.');\n          return field;\n        }\n      }\n    }\n\n    log.warn('Detected faceted independent scales that union domain of identical fields from different source detected. We will assume that this is the same field from a different fork of the same data source. However, if this is not case, the result view size maybe incorrect.');\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn('Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.');\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n\n  return undefined;\n}\nexport function assembleDomain(model, channel) {\n  const scaleComponent = model.component.scales[channel];\n  const domains = scaleComponent.get('domains').map(domain => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n\n    return domain;\n  }); // domains is an array that has to be merged into a single vega domain\n\n  return mergeDomains(domains);\n}","map":{"version":3,"sources":["../../../../src/compile/scale/domain.ts"],"names":[],"mappings":"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","sourcesContent":["import {isObject, isString} from 'vega-util';\nimport {\n  isAggregateOp,\n  isArgmaxDef,\n  isArgminDef,\n  NonArgAggregateOp,\n  SHARED_DOMAIN_OP_INDEX,\n  MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX\n} from '../../aggregate';\nimport {isBinning, isSelectionExtent, isBinParams} from '../../bin';\nimport {getSecondaryRangeChannel, isScaleChannel, ScaleChannel} from '../../channel';\nimport {binRequiresRange, hasBand, ScaleFieldDef, TypedFieldDef, valueExpr, vgField} from '../../channeldef';\nimport {MAIN, RAW} from '../../data';\nimport {DateTime} from '../../datetime';\nimport * as log from '../../log';\nimport {Domain, hasDiscreteDomain, isSelectionDomain, ScaleConfig, ScaleType} from '../../scale';\nimport {DEFAULT_SORT_OP, EncodingSortField, isSortArray, isSortByEncoding, isSortField} from '../../sort';\nimport {TimeUnit} from '../../timeunit';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {\n  isDataRefDomain,\n  isDataRefUnionedDomain,\n  isFieldRefUnionDomain,\n  VgDataRef,\n  VgDomain,\n  VgFieldRefUnionDomain,\n  VgNonUnionDomain,\n  VgSortField,\n  VgUnionSortField\n} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {FACET_SCALE_PREFIX} from '../data/optimize';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {SignalRefWrapper} from '../signal';\nimport {Explicit, makeExplicit, makeImplicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex, ScaleComponent} from './component';\n\nexport function parseScaleDomain(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  util.keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.setWithExplicit('domains', domains);\n    parseSelectionDomain(model, channel);\n\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent: Model = model;\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n\n      const resolve = facetParent.component.resolve.scale[channel];\n\n      if (resolve === 'shared') {\n        for (const domain of domains.value) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction parseNonUnitScaleDomain(model: Model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  util.keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    let domains: Explicit<VgNonUnionDomain[]>;\n    let selectionExtent = null;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.getWithExplicit('domains');\n        } else {\n          domains = mergeValuesWithExplicit(\n            domains,\n            childComponent.getWithExplicit('domains'),\n            'domains',\n            'scale',\n            domainsTieBreaker\n          );\n        }\n\n        const se = childComponent.get('selectionExtent');\n        if (selectionExtent && se && selectionExtent.selection !== se.selection) {\n          log.warn('The same selection must be used to override scale domains in a layered view.');\n        }\n        selectionExtent = se;\n      }\n    }\n\n    localScaleComponents[channel].setWithExplicit('domains', domains);\n\n    if (selectionExtent) {\n      localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n    }\n  });\n}\n\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(\n  domain: Domain,\n  fieldDef: TypedFieldDef<string>,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig\n) {\n  if (domain === 'unaggregated') {\n    const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {valid} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model: UnitModel, channel: ScaleChannel): Explicit<VgNonUnionDomain[]> {\n  const scaleType = model.getScaleComponent(channel).get('type');\n\n  const domain = normalizeUnaggregatedDomain(\n    model.scaleDomain(channel),\n    model.fieldDef(channel),\n    scaleType,\n    model.config.scale\n  );\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = {\n      ...model.specifiedScales[channel],\n      domain\n    };\n  }\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && model.channelHasField('x2')) {\n    if (model.channelHasField('x')) {\n      return mergeValuesWithExplicit(\n        parseSingleChannelDomain(scaleType, domain, model, 'x'),\n        parseSingleChannelDomain(scaleType, domain, model, 'x2'),\n        'domain',\n        'scale',\n        domainsTieBreaker\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && model.channelHasField('y2')) {\n    if (model.channelHasField('y')) {\n      return mergeValuesWithExplicit(\n        parseSingleChannelDomain(scaleType, domain, model, 'y'),\n        parseSingleChannelDomain(scaleType, domain, model, 'y2'),\n        'domain',\n        'scale',\n        domainsTieBreaker\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal<T>(domain: T[], type: Type, timeUnit: TimeUnit) {\n  return domain.map(v => {\n    const data = valueExpr(v, {timeUnit, type});\n    return {signal: `{data: ${data}}`};\n  });\n}\n\nfunction parseSingleChannelDomain(\n  scaleType: ScaleType,\n  domain: Domain,\n  model: UnitModel,\n  channel: ScaleChannel | 'x2' | 'y2'\n): Explicit<VgNonUnionDomain[]> {\n  const fieldDef = model.fieldDef(channel);\n\n  if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) {\n    // explicit value\n    const {type, timeUnit} = fieldDef;\n    if (type === 'temporal' || timeUnit) {\n      return makeExplicit(mapDomainToDataSignal<number | string | boolean | DateTime>(domain, type, timeUnit));\n    }\n\n    return makeExplicit([domain]);\n  }\n\n  const stack = model.stack;\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n\n    const data = model.requestDataName(MAIN);\n    return makeImplicit([\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'start'})\n      },\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'end'})\n      }\n    ]);\n  }\n\n  const sort: undefined | true | VgSortField = isScaleChannel(channel)\n    ? domainSort(model, channel, scaleType)\n    : undefined;\n\n  if (domain === 'unaggregated') {\n    const data = model.requestDataName(MAIN);\n    const {field} = fieldDef;\n    return makeImplicit([\n      {\n        data,\n        field: vgField({field, aggregate: 'min'})\n      },\n      {\n        data,\n        field: vgField({field, aggregate: 'max'})\n      }\n    ]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      }\n\n      // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n      return makeImplicit([\n        {\n          // If sort by aggregation of a specified sort field, we need to use RAW table,\n          // so we can aggregate values for the scale independently from the main aggregation.\n          data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n          // Use range if we added it and the scale does not support computing a range as a signal.\n          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {binSuffix: 'range'} : {}),\n          // we have to use a sort object if sort = true to make the sort correct by bin start\n          sort:\n            sort === true || !isObject(sort)\n              ? {\n                  field: model.vgField(channel, {}),\n                  op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n                }\n              : sort\n        }\n      ]);\n    } else {\n      // continuous scales\n      const {bin} = fieldDef;\n      if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([\n          new SignalRefWrapper(() => {\n            const signal = model.getSignalName(binSignal);\n            return `[${signal}.start, ${signal}.stop]`;\n          })\n        ]);\n      } else {\n        return makeImplicit([\n          {\n            data: model.requestDataName(MAIN),\n            field: model.vgField(channel, {})\n          }\n        ]);\n      }\n    }\n  } else if (\n    fieldDef.timeUnit &&\n    util.contains(['time', 'utc'], scaleType) &&\n    hasBand(\n      channel,\n      fieldDef,\n      isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined,\n      model.markDef,\n      model.config\n    )\n  ) {\n    const data = model.requestDataName(MAIN);\n    return makeImplicit([\n      {\n        data,\n        field: model.vgField(channel)\n      },\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'end'})\n      }\n    ]);\n  } else if (sort) {\n    return makeImplicit([\n      {\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n        field: model.vgField(channel),\n        sort: sort\n      }\n    ]);\n  } else {\n    return makeImplicit([\n      {\n        data: model.requestDataName(MAIN),\n        field: model.vgField(channel)\n      }\n    ]);\n  }\n}\n\nfunction normalizeSortField(sort: EncodingSortField<string>, isStacked: boolean) {\n  const {op, field, order} = sort;\n  return {\n    // Apply default op\n    op: op ?? (isStacked ? 'sum' : DEFAULT_SORT_OP),\n    // flatten nested fields\n    ...(field ? {field: util.replacePathInField(field)} : {}),\n\n    ...(order ? {order} : {})\n  };\n}\n\nfunction parseSelectionDomain(model: UnitModel, channel: ScaleChannel) {\n  const scale = model.component.scales[channel];\n  const spec = model.specifiedScales[channel].domain;\n  const bin = model.fieldDef(channel).bin;\n  const domain = isSelectionDomain(spec) && spec;\n  const extent = isBinParams(bin) && isSelectionExtent(bin.extent) && bin.extent;\n\n  if (domain || extent) {\n    // As scale parsing occurs before selection parsing, we cannot set\n    // domainRaw directly. So instead, we store the selectionExtent on\n    // the scale component, and then add domainRaw during scale assembly.\n    scale.set('selectionExtent', domain ?? extent, true);\n  }\n}\n\nexport function domainSort(\n  model: UnitModel,\n  channel: ScaleChannel,\n  scaleType: ScaleType\n): undefined | true | VgSortField {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n\n  // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n  const fieldDef = model.fieldDef(channel) as ScaleFieldDef<string>;\n  const sort = fieldDef.sort;\n\n  // if the sort is specified with array, use the derived sort index field\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  const isStacked = model.stack !== null;\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    return normalizeSortField(sort, isStacked);\n  } else if (isSortByEncoding(sort)) {\n    const {encoding, order} = sort;\n    const fieldDefToSortBy = model.fieldDef(encoding);\n    const {aggregate, field} = fieldDefToSortBy;\n\n    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n      return normalizeSortField(\n        {\n          field: vgField(fieldDefToSortBy),\n          order\n        },\n        isStacked\n      );\n    } else if (isAggregateOp(aggregate) || !aggregate) {\n      return normalizeSortField(\n        {\n          op: aggregate as NonArgAggregateOp, // can't be argmin/argmax since we don't support them in encoding field def\n          field,\n          order\n        },\n        isStacked\n      );\n    }\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort == null\n  return undefined;\n}\n\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(\n  fieldDef: TypedFieldDef<string>,\n  scaleType: ScaleType\n): {valid: boolean; reason?: string} {\n  const {aggregate, type} = fieldDef;\n\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (isString(aggregate) && !SHARED_DOMAIN_OP_INDEX[aggregate]) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {valid: true};\n}\n\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\nfunction domainsTieBreaker(\n  v1: Explicit<VgNonUnionDomain[]>,\n  v2: Explicit<VgNonUnionDomain[]>,\n  property: 'domains',\n  propertyOf: 'scale'\n) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, concat the domains so that we union them later.\n  return {explicit: v1.explicit, value: [...v1.value, ...v2.value]};\n}\n\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains: VgNonUnionDomain[]): VgDomain {\n  const uniqueDomains = util.unique(\n    domains.map(domain => {\n      // ignore sort property when computing the unique domains\n      if (isDataRefDomain(domain)) {\n        const {sort: _s, ...domainWithoutSort} = domain;\n        return domainWithoutSort;\n      }\n      return domain;\n    }),\n    util.hash\n  );\n\n  const sorts: VgSortField[] = util.unique(\n    domains\n      .map(d => {\n        if (isDataRefDomain(d)) {\n          const s = d.sort;\n          if (s !== undefined && !util.isBoolean(s)) {\n            if ('op' in s && s.op === 'count') {\n              // let's make sure that if op is count, we don't use a field\n              delete s.field;\n            }\n            if (s.order === 'ascending') {\n              // drop order: ascending as it is the default\n              delete s.order;\n            }\n          }\n          return s;\n        }\n        return undefined;\n      })\n      .filter(s => s !== undefined),\n    util.hash\n  );\n\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        sort = true;\n      }\n      return {\n        ...domain,\n        sort\n      };\n    }\n    return domain;\n  }\n\n  // only keep sort properties that work with unioned domains\n  const unionDomainSorts = util.unique<VgUnionSortField>(\n    sorts.map(s => {\n      if (util.isBoolean(s) || !('op' in s) || s.op in UNIONDOMAIN_SORT_OP_INDEX) {\n        return s as VgUnionSortField;\n      }\n      log.warn(log.message.domainSortDropped(s));\n      return true;\n    }),\n    util.hash\n  ) as VgUnionSortField[];\n\n  let sort: VgUnionSortField;\n\n  if (unionDomainSorts.length === 1) {\n    sort = unionDomainSorts[0];\n  } else if (unionDomainSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  const allData = util.unique(\n    domains.map(d => {\n      if (isDataRefDomain(d)) {\n        return d.data;\n      }\n      return null;\n    }),\n    x => x\n  );\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain: VgFieldRefUnionDomain = {\n      data: allData[0],\n      fields: uniqueDomains.map(d => (d as VgDataRef).field),\n      ...(sort ? {sort} : {})\n    };\n\n    return domain;\n  }\n\n  return {fields: uniqueDomains, ...(sort ? {sort} : {})};\n}\n\n/**\n * Return a field if a scale single field.\n * Return `undefined` otherwise.\n *\n */\nexport function getFieldFromDomain(domain: VgDomain): string {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn(\n            'Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.'\n          );\n          return field;\n        }\n      }\n    }\n    log.warn(\n      'Detected faceted independent scales that union domain of identical fields from different source detected. We will assume that this is the same field from a different fork of the same data source. However, if this is not case, the result view size maybe incorrect.'\n    );\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(\n      'Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.'\n    );\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n\n  return undefined;\n}\n\nexport function assembleDomain(model: Model, channel: ScaleChannel) {\n  const scaleComponent: ScaleComponent = model.component.scales[channel];\n\n  const domains = scaleComponent.get('domains').map((domain: VgNonUnionDomain) => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n    return domain;\n  });\n\n  // domains is an array that has to be merged into a single vega domain\n  return mergeDomains(domains);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}