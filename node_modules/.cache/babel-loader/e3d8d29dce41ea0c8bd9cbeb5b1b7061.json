{"ast":null,"code":"import { keys } from '../util';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { Model } from './model';\nexport class BaseConcatModel extends Model {\n  constructor(spec, specType, parent, parentGivenName, config, repeater, resolve) {\n    super(spec, specType, parent, parentGivenName, config, repeater, resolve);\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n    this.children.forEach(child => {\n      child.parseData();\n    });\n  }\n\n  parseSelections() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n\n    for (const child of this.children) {\n      child.parseSelections();\n      keys(child.component.selection).forEach(key => {\n        this.component.selection[key] = child.component.selection[key];\n      });\n    }\n  }\n\n  parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n\n  parseAxesAndHeaders() {\n    for (const child of this.children) {\n      child.parseAxesAndHeaders();\n    } // TODO(#2415): support shared axes\n\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n\n  assembleSignals() {\n    this.children.forEach(child => child.assembleSignals());\n    return [];\n  }\n\n  assembleLayoutSignals() {\n    return this.children.reduce((signals, child) => {\n      return [...signals, ...child.assembleLayoutSignals()];\n    }, assembleLayoutSignals(this));\n  }\n\n  assembleSelectionData(data) {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n\n  assembleMarks() {\n    // only children have marks\n    return this.children.map(child => {\n      const title = child.assembleTitle();\n      const style = child.assembleGroupStyle();\n      const encodeEntry = child.assembleGroupEncodeEntry(false);\n      return Object.assign(Object.assign(Object.assign(Object.assign({\n        type: 'group',\n        name: child.getName('group')\n      }, title ? {\n        title\n      } : {}), style ? {\n        style\n      } : {}), encodeEntry ? {\n        encode: {\n          update: encodeEntry\n        }\n      } : {}), child.assembleGroup());\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/compile/baseconcat.ts"],"names":[],"mappings":"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","sourcesContent":["import {NewSignal} from 'vega';\nimport {Config} from '../config';\nimport {Resolve} from '../resolve';\nimport {SpecType} from '../spec/base';\nimport {NormalizedConcatSpec} from '../spec/concat';\nimport {NormalizedRepeatSpec} from '../spec/repeat';\nimport {keys} from '../util';\nimport {VgData} from '../vega.schema';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {Model} from './model';\nimport {RepeaterValue} from './repeater';\n\nexport abstract class BaseConcatModel extends Model {\n  constructor(\n    spec: NormalizedConcatSpec | NormalizedRepeatSpec,\n    specType: SpecType,\n    parent: Model,\n    parentGivenName: string,\n    config: Config,\n    repeater: RepeaterValue,\n    resolve: Resolve\n  ) {\n    super(spec, specType, parent, parentGivenName, config, repeater, resolve);\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    this.children.forEach(child => {\n      child.parseData();\n    });\n  }\n  public parseSelections() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n    for (const child of this.children) {\n      child.parseSelections();\n      keys(child.component.selection).forEach(key => {\n        this.component.selection[key] = child.component.selection[key];\n      });\n    }\n  }\n\n  public parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n\n  public parseAxesAndHeaders() {\n    for (const child of this.children) {\n      child.parseAxesAndHeaders();\n    }\n\n    // TODO(#2415): support shared axes\n  }\n\n  public assembleSelectionTopLevelSignals(signals: NewSignal[]): NewSignal[] {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n\n  public assembleSignals(): NewSignal[] {\n    this.children.forEach(child => child.assembleSignals());\n    return [];\n  }\n\n  public assembleLayoutSignals(): NewSignal[] {\n    return this.children.reduce((signals, child) => {\n      return [...signals, ...child.assembleLayoutSignals()];\n    }, assembleLayoutSignals(this));\n  }\n\n  public assembleSelectionData(data: readonly VgData[]): readonly VgData[] {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n\n  public assembleMarks(): any[] {\n    // only children have marks\n    return this.children.map(child => {\n      const title = child.assembleTitle();\n      const style = child.assembleGroupStyle();\n      const encodeEntry = child.assembleGroupEncodeEntry(false);\n\n      return {\n        type: 'group',\n        name: child.getName('group'),\n        ...(title ? {title} : {}),\n        ...(style ? {style} : {}),\n        ...(encodeEntry ? {encode: {update: encodeEntry}} : {}),\n        ...child.assembleGroup()\n      };\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}