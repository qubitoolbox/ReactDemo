{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tfjs_1 = require(\"@tensorflow/tfjs\");\n\nconst utils_1 = require(\"./utils\");\n/**\n * Returns summary statistics for an array of numbers\n *\n * @param input\n */\n\n\nfunction arrayStats(input) {\n  if (!Array.isArray(input)) {\n    throw new Error('input must be an array');\n  }\n\n  if (input.length === 0) {\n    return {\n      numVals: 0,\n      numNans: 0,\n      numZeros: 0,\n      max: undefined,\n      min: undefined\n    };\n  }\n\n  const numVals = input.length;\n  let max = -Infinity;\n  let min = Infinity;\n  let numZeros = 0;\n  let numNans = 0;\n  let numInfs = 0;\n\n  for (let i = 0; i < numVals; i++) {\n    const curr = input[i];\n\n    if (curr > max) {\n      max = curr;\n    }\n\n    if (curr < min) {\n      min = curr;\n    }\n\n    if (curr === 0) {\n      numZeros += 1;\n    }\n\n    if (isNaN(curr)) {\n      numNans += 1;\n    } else if (!isFinite(curr)) {\n      // Make sure NaNs are not double counted as Infs\n      numInfs += 1;\n    }\n  }\n\n  const result = {\n    numVals,\n    numZeros,\n    numNans,\n    max,\n    min,\n    numInfs\n  }; // Handle all NaN input\n\n  if (result.max === -Infinity) {\n    result.max = NaN;\n  }\n\n  if (result.min === Infinity) {\n    result.min = NaN;\n  }\n\n  return result;\n}\n\nexports.arrayStats = arrayStats;\n/**\n * Returns summary statistics for a numeric tensor. *\n *\n * @param input\n */\n\nfunction tensorStats(input) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // TODO. Benchmark this and consider having one of the *stats functions\n    // delegate to the other.\n    const [min, max, numZeros] = tfjs_1.tidy(() => {\n      const zero = tfjs_1.scalar(0, input.dtype);\n      const min = input.min();\n      const max = input.max();\n      const numZeros = input.equal(zero).sum();\n      return [min, max, numZeros];\n    });\n    return Promise.all([input.data(), min.data(), max.data(), numZeros.data()]).then(([tensorVal, minVal, maxVal, numZerosVal]) => {\n      // We currently need to count NaNs on CPU.\n      const numVals = tensorVal.length;\n      let numNans = 0;\n      let numInfs = 0;\n\n      for (let i = 0; i < numVals; i++) {\n        const curr = tensorVal[i];\n\n        if (isNaN(curr)) {\n          numNans += 1;\n        } else if (!isFinite(curr)) {\n          // Make sure NaNs are not double counted as Infs\n          numInfs += 1;\n        }\n      }\n\n      let trueMin = minVal[0];\n      let trueMax = maxVal[0];\n\n      if (numNans === numVals) {\n        // on gpu the min and max won't be accurate if all values are NaN\n        trueMin = NaN;\n        trueMax = NaN;\n      }\n\n      const stats = {\n        numVals,\n        numZeros: numZerosVal[0],\n        numNans,\n        min: trueMin,\n        max: trueMax,\n        numInfs\n      };\n      return stats;\n    });\n  });\n}\n\nexports.tensorStats = tensorStats;\n/**\n * Computes a confusion matrix from predictions and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([1, 2, 4]);\n * const predictions = tf.tensor1d([2, 2, 4]);\n * const result = await tfvis.metrics.confusionMatrix(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n * @param weights 1d tensor that is the same size as predictions.\n *  If weights is passed in then each prediction contributes its corresponding\n *  weight to the total value of the confusion matrix cell.\n *\n */\n\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nfunction confusionMatrix(labels, predictions, numClasses, weights) {\n  return __awaiter(this, void 0, void 0, function* () {\n    utils_1.assert(labels.rank === 1, 'labels must be a 1D tensor');\n    utils_1.assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n    utils_1.assert(labels.size === predictions.size, 'labels and predictions must be the same length');\n\n    if (weights != null) {\n      utils_1.assert(weights.size === predictions.size, 'labels and predictions must be the same length');\n    } // Cast to int in case the caller didn't\n\n\n    const labelsInt = labels.cast('int32');\n    const predictionsInt = predictions.cast('int32');\n\n    if (numClasses == null) {\n      numClasses = tfjs_1.tidy(() => {\n        const max = tfjs_1.maximum(labelsInt.max(), predictionsInt.max()).cast('int32');\n        return max.dataSync()[0] + 1;\n      });\n    }\n\n    let weightsPromise = Promise.resolve(null);\n\n    if (weights != null) {\n      weightsPromise = weights.data();\n    }\n\n    return Promise.all([labelsInt.data(), predictionsInt.data(), weightsPromise]).then(([labelsArray, predsArray, weightsArray]) => {\n      const result = Array(numClasses).fill(0); // Initialize the matrix\n\n      for (let i = 0; i < numClasses; i++) {\n        result[i] = Array(numClasses).fill(0);\n      }\n\n      for (let i = 0; i < labelsArray.length; i++) {\n        const label = labelsArray[i];\n        const pred = predsArray[i];\n\n        if (weightsArray != null) {\n          result[label][pred] += weightsArray[i];\n        } else {\n          result[label][pred] += 1;\n        }\n      }\n\n      return result;\n    });\n  });\n}\n\nexports.confusionMatrix = confusionMatrix;\n/**\n * Computes how often predictions matches labels\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.accuracy(labels, predictions);\n * console.log(result)\n * ```\n *\n * @param labels tensor of true values\n * @param predictions tensor of predicted values\n */\n\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nfunction accuracy(labels, predictions) {\n  return __awaiter(this, void 0, void 0, function* () {\n    utils_1.assertShapesMatch(labels.shape, predictions.shape, 'Error computing accuracy.');\n    const eq = labels.equal(predictions);\n    const mean = eq.mean();\n    const acc = (yield mean.data())[0];\n    tfjs_1.dispose([eq, mean]);\n    return acc;\n  });\n}\n\nexports.accuracy = accuracy;\n/**\n * Computes per class accuracy between prediction and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.perClassAccuracy(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * Returns an array of objects that each have an an `accuracy` and a `count`\n * property for each class.\n *\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n */\n\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nfunction perClassAccuracy(labels, predictions, numClasses) {\n  return __awaiter(this, void 0, void 0, function* () {\n    utils_1.assert(labels.rank === 1, 'labels must be a 1D tensor');\n    utils_1.assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n    utils_1.assert(labels.size === predictions.size, 'labels and predictions must be the same length');\n\n    if (numClasses == null) {\n      numClasses = tfjs_1.tidy(() => {\n        return tfjs_1.maximum(labels.max(), predictions.max()).dataSync()[0] + 1;\n      });\n    }\n\n    return Promise.all([labels.data(), predictions.data()]).then(([labelsArray, predsArray]) => {\n      // Per class total counts\n      const counts = Array(numClasses).fill(0); // Per class accuracy\n\n      const accuracy = Array(numClasses).fill(0);\n\n      for (let i = 0; i < labelsArray.length; i++) {\n        const label = labelsArray[i];\n        const pred = predsArray[i];\n        counts[label] += 1;\n\n        if (label === pred) {\n          accuracy[label] += 1;\n        }\n      }\n\n      const results = [];\n\n      for (let i = 0; i < counts.length; i++) {\n        results.push({\n          count: counts[i],\n          accuracy: counts[i] === 0 ? 0 : accuracy[i] / counts[i]\n        });\n      }\n\n      return results;\n    });\n  });\n}\n\nexports.perClassAccuracy = perClassAccuracy;","map":{"version":3,"sources":["../../src/util/math.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {dispose, maximum, scalar, Tensor, Tensor1D, tidy} from '@tensorflow/tfjs';\n\nimport {HistogramStats, TypedArray} from '../types';\n\nimport {assert, assertShapesMatch} from './utils';\n\n/**\n * Returns summary statistics for an array of numbers\n *\n * @param input\n */\nexport function arrayStats(input: number[]): HistogramStats {\n  if (!Array.isArray(input)) {\n    throw new Error('input must be an array');\n  }\n  if (input.length === 0) {\n    return {\n      numVals: 0,\n      numNans: 0,\n      numZeros: 0,\n      max: undefined,\n      min: undefined,\n    };\n  }\n\n  const numVals = input.length;\n  let max = -Infinity;\n  let min = Infinity;\n  let numZeros = 0;\n  let numNans = 0;\n  let numInfs = 0;\n\n  for (let i = 0; i < numVals; i++) {\n    const curr = input[i];\n    if (curr > max) {\n      max = curr;\n    }\n\n    if (curr < min) {\n      min = curr;\n    }\n\n    if (curr === 0) {\n      numZeros += 1;\n    }\n\n    if (isNaN(curr)) {\n      numNans += 1;\n    } else if (!isFinite(curr)) {\n      // Make sure NaNs are not double counted as Infs\n      numInfs += 1;\n    }\n  }\n\n  const result = {\n    numVals,\n    numZeros,\n    numNans,\n    max,\n    min,\n    numInfs,\n  };\n\n  // Handle all NaN input\n  if (result.max === -Infinity) {\n    result.max = NaN;\n  }\n  if (result.min === Infinity) {\n    result.min = NaN;\n  }\n\n  return result;\n}\n\n/**\n * Returns summary statistics for a numeric tensor. *\n *\n * @param input\n */\nexport async function tensorStats(input: Tensor): Promise<HistogramStats> {\n  // TODO. Benchmark this and consider having one of the *stats functions\n  // delegate to the other.\n\n  const [min, max, numZeros] = tidy(() => {\n    const zero = scalar(0, input.dtype);\n\n    const min = input.min();\n    const max = input.max();\n    const numZeros = input.equal(zero).sum();\n\n    return [min, max, numZeros];\n  });\n\n  return Promise\n      .all([input.data(), min.data(), max.data(), numZeros.data()])\n      .then(([tensorVal, minVal, maxVal, numZerosVal]) => {\n        // We currently need to count NaNs on CPU.\n        const numVals = tensorVal.length;\n        let numNans = 0;\n        let numInfs = 0;\n        for (let i = 0; i < numVals; i++) {\n          const curr = tensorVal[i];\n          if (isNaN(curr)) {\n            numNans += 1;\n          } else if (!isFinite(curr)) {\n            // Make sure NaNs are not double counted as Infs\n            numInfs += 1;\n          }\n        }\n\n        let trueMin = minVal[0];\n        let trueMax = maxVal[0];\n        if (numNans === numVals) {\n          // on gpu the min and max won't be accurate if all values are NaN\n          trueMin = NaN;\n          trueMax = NaN;\n        }\n\n        const stats = {\n          numVals,\n          numZeros: numZerosVal[0],\n          numNans,\n          min: trueMin,\n          max: trueMax,\n          numInfs,\n        };\n\n        return stats;\n      });\n}\n\n/**\n * Computes a confusion matrix from predictions and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([1, 2, 4]);\n * const predictions = tf.tensor1d([2, 2, 4]);\n * const result = await tfvis.metrics.confusionMatrix(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n * @param weights 1d tensor that is the same size as predictions.\n *  If weights is passed in then each prediction contributes its corresponding\n *  weight to the total value of the confusion matrix cell.\n *\n */\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport async function confusionMatrix(\n    labels: Tensor1D, predictions: Tensor1D, numClasses?: number,\n    weights?: Tensor1D): Promise<number[][]> {\n  assert(labels.rank === 1, 'labels must be a 1D tensor');\n  assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n  assert(\n      labels.size === predictions.size,\n      'labels and predictions must be the same length');\n  if (weights != null) {\n    assert(\n        weights.size === predictions.size,\n        'labels and predictions must be the same length');\n  }\n\n  // Cast to int in case the caller didn't\n  const labelsInt = labels.cast('int32');\n  const predictionsInt = predictions.cast('int32');\n\n  if (numClasses == null) {\n    numClasses =\n        tidy(() => {\n          const max =\n              maximum(labelsInt.max(), predictionsInt.max()).cast('int32');\n          return max.dataSync()[0] + 1;\n        });\n  }\n\n  let weightsPromise: Promise<null|TypedArray> = Promise.resolve(null);\n  if (weights != null) {\n    weightsPromise = weights.data();\n  }\n\n  return Promise.all([labelsInt.data(), predictionsInt.data(), weightsPromise])\n      .then(([labelsArray, predsArray, weightsArray]) => {\n        const result: number[][] = Array(numClasses).fill(0);\n        // Initialize the matrix\n        for (let i = 0; i < numClasses; i++) {\n          result[i] = Array(numClasses).fill(0);\n        }\n\n        for (let i = 0; i < labelsArray.length; i++) {\n          const label = labelsArray[i];\n          const pred = predsArray[i];\n\n          if (weightsArray != null) {\n            result[label][pred] += weightsArray[i];\n          } else {\n            result[label][pred] += 1;\n          }\n        }\n\n        return result;\n      });\n}\n\n/**\n * Computes how often predictions matches labels\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.accuracy(labels, predictions);\n * console.log(result)\n * ```\n *\n * @param labels tensor of true values\n * @param predictions tensor of predicted values\n */\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport async function accuracy(\n    labels: Tensor, predictions: Tensor): Promise<number> {\n  assertShapesMatch(\n      labels.shape, predictions.shape, 'Error computing accuracy.');\n\n  const eq = labels.equal(predictions);\n  const mean = eq.mean();\n\n  const acc = (await mean.data())[0];\n\n  dispose([eq, mean]);\n  return acc;\n}\n\n/**\n * Computes per class accuracy between prediction and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.perClassAccuracy(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * Returns an array of objects that each have an an `accuracy` and a `count`\n * property for each class.\n *\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n */\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport async function perClassAccuracy(\n    labels: Tensor1D, predictions: Tensor1D,\n    numClasses?: number): Promise<Array<{accuracy: number, count: number}>> {\n  assert(labels.rank === 1, 'labels must be a 1D tensor');\n  assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n  assert(\n      labels.size === predictions.size,\n      'labels and predictions must be the same length');\n\n  if (numClasses == null) {\n    numClasses = tidy(() => {\n      return maximum(labels.max(), predictions.max()).dataSync()[0] + 1;\n    });\n  }\n\n  return Promise.all([labels.data(), predictions.data()])\n      .then(([labelsArray, predsArray]) => {\n        // Per class total counts\n        const counts: number[] = Array(numClasses).fill(0);\n        // Per class accuracy\n        const accuracy: number[] = Array(numClasses).fill(0);\n\n        for (let i = 0; i < labelsArray.length; i++) {\n          const label = labelsArray[i];\n          const pred = predsArray[i];\n\n          counts[label] += 1;\n          if (label === pred) {\n            accuracy[label] += 1;\n          }\n        }\n\n        const results: Array<{accuracy: number, count: number}> = [];\n        for (let i = 0; i < counts.length; i++) {\n          results.push({\n            count: counts[i],\n            accuracy: counts[i] === 0 ? 0 : accuracy[i] / counts[i],\n          });\n        }\n\n        return results;\n      });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}