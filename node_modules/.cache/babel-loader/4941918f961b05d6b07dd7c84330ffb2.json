{"ast":null,"code":"import { isFieldDef } from '../../../channeldef';\nimport { getFirstDefined } from '../../../util';\nimport { getStyleConfig } from '../../common';\nimport { getOffset } from './offset';\nimport { alignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\nexport function pointOrRangePosition(channel, model, {\n  defaultPos,\n  defaultPos2,\n  range\n}) {\n  if (range) {\n    return rangePosition(channel, model, {\n      defaultPos,\n      defaultPos2\n    });\n  }\n\n  return pointPosition(channel, model, {\n    defaultPos\n  });\n}\nexport function rangePosition(channel, model, {\n  defaultPos,\n  defaultPos2\n}) {\n  const {\n    markDef,\n    config\n  } = model;\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  const pos2Mixins = pointPosition2(model, defaultPos2, channel2);\n  const vgChannel = pos2Mixins[sizeChannel] ? alignedPositionChannel(channel, markDef, config) : channel;\n  return Object.assign(Object.assign({}, pointPosition(channel, model, {\n    defaultPos,\n    vgChannel\n  })), pos2Mixins);\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\n\nfunction pointPosition2(model, defaultPos, channel) {\n  const {\n    encoding,\n    mark,\n    markDef,\n    stack,\n    config\n  } = model;\n  const baseChannel = channel === 'x2' ? 'x' : 'y';\n  const sizeChannel = channel === 'x2' ? 'width' : 'height';\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n  const offset = getOffset(channel, model.markDef);\n\n  if (!channelDef && (encoding.latitude || encoding.longitude)) {\n    // use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.\n    return {\n      [channel]: {\n        field: model.getName(channel)\n      }\n    };\n  }\n\n  const valueRef = position2Ref({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return {\n      [channel]: valueRef\n    };\n  }\n\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    markDef,\n    config,\n    defaultPos,\n    channel,\n    scaleName,\n    scale,\n    mark,\n    checkBarAreaWithoutZero: !encoding[channel] // only check for non-ranged marks\n\n  })(); // TODO: check width/height encoding here once we add them\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n  return getFirstDefined(position2orSize(channel, markDef), position2orSize(channel, {\n    [channel]: getStyleConfig(channel, markDef, config.style),\n    [sizeChannel]: getStyleConfig(sizeChannel, markDef, config.style)\n  }), position2orSize(channel, config[mark]), position2orSize(channel, config.mark), {\n    [channel]: defaultRef\n  });\n}\n\nfunction position2Ref({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}) {\n  if (isFieldDef(channelDef) && stack && // If fieldChannel is X and channel is X2 (or Y and Y2)\n  channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n    return ref.fieldRef(channelDef, scaleName, {\n      suffix: 'start'\n    }, {\n      offset\n    });\n  }\n\n  return ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\n\nfunction position2orSize(channel, markDef) {\n  const sizeChannel = channel === 'x2' ? 'width' : 'height';\n\n  if (markDef[channel]) {\n    return {\n      [channel]: ref.widthHeightValueRef(channel, markDef[channel])\n    };\n  } else if (markDef[sizeChannel]) {\n    return {\n      [sizeChannel]: {\n        value: markDef[sizeChannel]\n      }\n    };\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-range.ts"],"names":[],"mappings":"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","sourcesContent":["import {isFieldDef} from '../../../channeldef';\nimport {MarkConfig} from '../../../mark';\nimport {getFirstDefined} from '../../../util';\nimport {VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getStyleConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {getOffset} from './offset';\nimport {alignedPositionChannel} from './position-align';\nimport {pointPosition, pointPositionDefaultRef} from './position-point';\nimport * as ref from './valueref';\n\nexport function pointOrRangePosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  {\n    defaultPos,\n    defaultPos2,\n    range\n  }: {\n    defaultPos: 'zeroOrMin' | 'zeroOrMax' | 'mid';\n    defaultPos2: 'zeroOrMin' | 'zeroOrMax';\n    range: boolean;\n  }\n) {\n  if (range) {\n    return rangePosition(channel, model, {defaultPos, defaultPos2});\n  }\n  return pointPosition(channel, model, {defaultPos});\n}\n\nexport function rangePosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  {\n    defaultPos,\n    defaultPos2\n  }: {\n    defaultPos: 'zeroOrMin' | 'zeroOrMax' | 'mid';\n    defaultPos2: 'zeroOrMin' | 'zeroOrMax';\n  }\n) {\n  const {markDef, config} = model;\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n\n  const pos2Mixins = pointPosition2(model, defaultPos2, channel2);\n\n  const vgChannel = pos2Mixins[sizeChannel] ? alignedPositionChannel(channel, markDef, config) : channel;\n\n  return {\n    ...pointPosition(channel, model, {defaultPos, vgChannel}),\n    ...pos2Mixins\n  };\n}\n\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2(model: UnitModel, defaultPos: 'zeroOrMin' | 'zeroOrMax', channel: 'x2' | 'y2') {\n  const {encoding, mark, markDef, stack, config} = model;\n\n  const baseChannel = channel === 'x2' ? 'x' : 'y';\n  const sizeChannel = channel === 'x2' ? 'width' : 'height';\n\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n\n  const offset = getOffset(channel, model.markDef);\n\n  if (!channelDef && (encoding.latitude || encoding.longitude)) {\n    // use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.\n    return {[channel]: {field: model.getName(channel)}};\n  }\n\n  const valueRef = position2Ref({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return {[channel]: valueRef};\n  }\n\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    markDef,\n    config,\n    defaultPos,\n    channel,\n    scaleName,\n    scale,\n    mark,\n    checkBarAreaWithoutZero: !encoding[channel] // only check for non-ranged marks\n  })();\n\n  // TODO: check width/height encoding here once we add them\n\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n  return getFirstDefined<VgEncodeEntry>(\n    position2orSize(channel, markDef),\n    position2orSize(channel, {\n      [channel]: getStyleConfig(channel, markDef, config.style),\n      [sizeChannel]: getStyleConfig(sizeChannel, markDef, config.style)\n    }),\n    position2orSize(channel, config[mark]),\n    position2orSize(channel, config.mark),\n    {\n      [channel]: defaultRef\n    }\n  );\n}\n\nfunction position2Ref({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}: ref.MidPointParams & {\n  channel: 'x2' | 'y2';\n}): VgValueRef | VgValueRef[] {\n  if (\n    isFieldDef(channelDef) &&\n    stack &&\n    // If fieldChannel is X and channel is X2 (or Y and Y2)\n    channel.charAt(0) === stack.fieldChannel.charAt(0)\n  ) {\n    return ref.fieldRef(channelDef, scaleName, {suffix: 'start'}, {offset});\n  }\n  return ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\n\nfunction position2orSize(channel: 'x2' | 'y2', markDef: MarkConfig) {\n  const sizeChannel = channel === 'x2' ? 'width' : 'height';\n  if (markDef[channel]) {\n    return {[channel]: ref.widthHeightValueRef(channel, markDef[channel])};\n  } else if (markDef[sizeChannel]) {\n    return {[sizeChannel]: {value: markDef[sizeChannel]}};\n  }\n  return undefined;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}