{"ast":null,"code":"import { max } from 'd3-array';\nimport { ingest, rederive, Transform } from 'vega-dataflow';\nimport { identity, inherits, isArray, isFunction, isNumber } from 'vega-util';\nimport contours from './util/contours';\nimport quantize from './util/quantize';\n/**\n * Generate isocontours (level sets) based on input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   specified, the levels, nice, resolve, and zero parameters are ignored.\n * @param {number} [params.levels] - The desired number of contour levels.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified levels.\n * @param {string} [params.resolve] - The method for resolving thresholds\n *   across multiple input grids. If 'independent' (the default), threshold\n *   calculation will be performed separately for each grid. If 'shared', a\n *   single set of threshold values will be used for all input grids.\n * @param {boolean} [params.zero] - Boolean flag indicating if the contour\n *   threshold values should include zero.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n * @param {boolean} [params.scale] - Optional numerical value by which to\n *   scale the output isocontour coordinates. This parameter can be useful\n *   to scale the contours to match a desired output resolution.\n * @param {string} [params.as='contour'] - The output field in which to store\n *   the generated isocontour data (default 'contour').\n */\n\nexport default function Isocontour(params) {\n  Transform.call(this, null, params);\n}\nIsocontour.Definition = {\n  \"type\": \"Isocontour\",\n  \"metadata\": {\n    \"generates\": true\n  },\n  \"params\": [{\n    \"name\": \"field\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"thresholds\",\n    \"type\": \"number\",\n    \"array\": true\n  }, {\n    \"name\": \"levels\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"nice\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }, {\n    \"name\": \"resolve\",\n    \"type\": \"enum\",\n    \"values\": [\"shared\", \"independent\"],\n    \"default\": \"independent\"\n  }, {\n    \"name\": \"zero\",\n    \"type\": \"boolean\",\n    \"default\": true\n  }, {\n    \"name\": \"smooth\",\n    \"type\": \"boolean\",\n    \"default\": true\n  }, {\n    \"name\": \"scale\",\n    \"type\": \"number\",\n    \"expr\": true\n  }, {\n    \"name\": \"translate\",\n    \"type\": \"number\",\n    \"array\": true,\n    \"expr\": true\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"null\": true,\n    \"default\": \"contour\"\n  }]\n};\nvar prototype = inherits(Isocontour, Transform);\n\nprototype.transform = function (_, pulse) {\n  if (this.value && !pulse.changed() && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      field = _.field || identity,\n      contour = contours().smooth(_.smooth !== false),\n      tz = _.thresholds || levels(source, field, _),\n      as = _.as === null ? null : _.as || 'contour',\n      values = [];\n  source.forEach(t => {\n    const grid = field(t); // generate contour paths in GeoJSON format\n\n    const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values)); // adjust contour path coordinates as needed\n\n    transformPaths(paths, grid, t, _); // ingest; copy source data properties to output\n\n    paths.forEach(p => {\n      values.push(rederive(t, ingest(as != null ? {\n        [as]: p\n      } : p)));\n    });\n  });\n  if (this.value) out.rem = this.value;\n  this.value = out.source = out.add = values;\n  return out;\n};\n\nfunction levels(values, f, _) {\n  const q = quantize(_.levels || 10, _.nice, _.zero !== false);\n  return _.resolve !== 'shared' ? q : q(values.map(t => max(f(t).values)));\n}\n\nfunction transformPaths(paths, grid, datum, _) {\n  let s = _.scale || grid.scale,\n      t = _.translate || grid.translate;\n  if (isFunction(s)) s = s(datum, _);\n  if (isFunction(t)) t = t(datum, _);\n  if ((s === 1 || s == null) && !t) return;\n  const sx = (isNumber(s) ? s : s[0]) || 1,\n        sy = (isNumber(s) ? s : s[1]) || 1,\n        tx = t && t[0] || 0,\n        ty = t && t[1] || 0;\n  paths.forEach(transform(grid, sx, sy, tx, ty));\n}\n\nexport function transform(grid, sx, sy, tx, ty) {\n  const x1 = grid.x1 || 0,\n        y1 = grid.y1 || 0,\n        flip = sx * sy < 0;\n\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n\n  function transformRing(coordinates) {\n    if (flip) coordinates.reverse(); // maintain winding order\n\n    coordinates.forEach(transformPoint);\n  }\n\n  function transformPoint(coordinates) {\n    coordinates[0] = (coordinates[0] - x1) * sx + tx;\n    coordinates[1] = (coordinates[1] - y1) * sy + ty;\n  }\n\n  return function (geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  };\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-geo/src/Isocontour.js"],"names":["max","ingest","rederive","Transform","identity","inherits","isArray","isFunction","isNumber","contours","quantize","Isocontour","params","call","Definition","prototype","transform","_","pulse","value","changed","modified","StopPropagation","out","fork","NO_SOURCE","NO_FIELDS","source","materialize","SOURCE","field","contour","smooth","tz","thresholds","levels","as","values","forEach","t","grid","paths","size","width","height","transformPaths","p","push","rem","add","f","q","nice","zero","resolve","map","datum","s","scale","translate","sx","sy","tx","ty","x1","y1","flip","transformPolygon","coordinates","transformRing","reverse","transformPoint","geometry"],"mappings":"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","sourcesContent":["import {max} from 'd3-array';\nimport {ingest, rederive, Transform} from 'vega-dataflow';\nimport {identity, inherits, isArray, isFunction, isNumber} from 'vega-util';\nimport contours from './util/contours';\nimport quantize from './util/quantize';\n\n/**\n * Generate isocontours (level sets) based on input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   specified, the levels, nice, resolve, and zero parameters are ignored.\n * @param {number} [params.levels] - The desired number of contour levels.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified levels.\n * @param {string} [params.resolve] - The method for resolving thresholds\n *   across multiple input grids. If 'independent' (the default), threshold\n *   calculation will be performed separately for each grid. If 'shared', a\n *   single set of threshold values will be used for all input grids.\n * @param {boolean} [params.zero] - Boolean flag indicating if the contour\n *   threshold values should include zero.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n * @param {boolean} [params.scale] - Optional numerical value by which to\n *   scale the output isocontour coordinates. This parameter can be useful\n *   to scale the contours to match a desired output resolution.\n * @param {string} [params.as='contour'] - The output field in which to store\n *   the generated isocontour data (default 'contour').\n */\nexport default function Isocontour(params) {\n  Transform.call(this, null, params);\n}\n\nIsocontour.Definition = {\n  \"type\": \"Isocontour\",\n  \"metadata\": {\"generates\": true},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\" },\n    { \"name\": \"thresholds\", \"type\": \"number\", \"array\": true },\n    { \"name\": \"levels\", \"type\": \"number\" },\n    { \"name\": \"nice\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"resolve\", \"type\": \"enum\", \"values\": [\"shared\", \"independent\"], \"default\": \"independent\" },\n    { \"name\": \"zero\", \"type\": \"boolean\", \"default\": true },\n    { \"name\": \"smooth\", \"type\": \"boolean\", \"default\": true },\n    { \"name\": \"scale\", \"type\": \"number\", \"expr\": true },\n    { \"name\": \"translate\", \"type\": \"number\", \"array\": true, \"expr\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"null\": true, \"default\": \"contour\" }\n  ]\n};\n\nvar prototype = inherits(Isocontour, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (this.value && !pulse.changed() && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      field = _.field || identity,\n      contour = contours().smooth(_.smooth !== false),\n      tz = _.thresholds || levels(source, field, _),\n      as = _.as === null ? null : _.as || 'contour',\n      values = [];\n\n  source.forEach(t => {\n    const grid = field(t);\n\n    // generate contour paths in GeoJSON format\n    const paths = contour.size([grid.width, grid.height])(\n      grid.values, isArray(tz) ? tz : tz(grid.values)\n    );\n\n    // adjust contour path coordinates as needed\n    transformPaths(paths, grid, t, _);\n\n    // ingest; copy source data properties to output\n    paths.forEach(p => {\n      values.push(rederive(t, ingest(as != null ? {[as]: p} : p)));\n    });\n  });\n\n  if (this.value) out.rem = this.value;\n  this.value = out.source = out.add = values;\n\n  return out;\n};\n\nfunction levels(values, f, _) {\n  const q = quantize(_.levels || 10, _.nice, _.zero !== false);\n  return _.resolve !== 'shared'\n    ? q\n    : q(values.map(t => max(f(t).values)));\n}\n\nfunction transformPaths(paths, grid, datum, _) {\n  let s = _.scale || grid.scale,\n      t = _.translate || grid.translate;\n  if (isFunction(s)) s = s(datum, _);\n  if (isFunction(t)) t = t(datum, _);\n  if ((s === 1 || s == null) && !t) return;\n\n  const sx = (isNumber(s) ? s : s[0]) || 1,\n        sy = (isNumber(s) ? s : s[1]) || 1,\n        tx = t && t[0] || 0,\n        ty = t && t[1] || 0;\n\n  paths.forEach(transform(grid, sx, sy, tx, ty));\n}\n\nexport function transform(grid, sx, sy, tx, ty) {\n  const x1 = grid.x1 || 0,\n        y1 = grid.y1 || 0,\n        flip = sx * sy < 0;\n\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n\n  function transformRing(coordinates) {\n    if (flip) coordinates.reverse(); // maintain winding order\n    coordinates.forEach(transformPoint);\n  }\n\n  function transformPoint(coordinates) {\n    coordinates[0] = (coordinates[0] - x1) * sx + tx;\n    coordinates[1] = (coordinates[1] - y1) * sy + ty;\n  }\n\n  return function(geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}