{"ast":null,"code":"import { isColorChannel } from '../../channel';\nimport { valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { getFirstConditionValue } from './encode';\nexport function values(legend, fieldDef) {\n  const vals = legend.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n\n  return undefined;\n}\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n  var _a;\n\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    const shape = (_a = getFirstConditionValue(shapeChannelDef), _a !== null && _a !== void 0 ? _a : markShape);\n\n    if (shape) {\n      return shape;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\nexport function clipHeight(legendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n\n  return undefined;\n}\nexport function type(params) {\n  const {\n    legend\n  } = params;\n  return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType({\n  channel,\n  timeUnit,\n  scaleType,\n  alwaysReturn\n}) {\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n\n    if (isContinuousToContinuous(scaleType)) {\n      return alwaysReturn ? 'gradient' : undefined;\n    }\n  }\n\n  return alwaysReturn ? 'symbol' : undefined;\n}\nexport function direction({\n  legend,\n  legendConfig,\n  timeUnit,\n  channel,\n  scaleType\n}) {\n  const orient = getFirstDefined(legend.orient, legendConfig.orient, 'right');\n  const legendType = type({\n    legend,\n    channel,\n    timeUnit,\n    scaleType,\n    alwaysReturn: true\n  });\n  return getFirstDefined(legend.direction, legendConfig[legendType ? 'gradientDirection' : 'symbolDirection'], defaultDirection(orient, legendType));\n}\n\nfunction defaultDirection(orient, legendType) {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined:\n      // undefined = \"right\" in Vega\n      return undefined;\n    // vertical is Vega's default\n\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\n\nexport function defaultGradientLength({\n  legend,\n  legendConfig,\n  model,\n  channel,\n  scaleType\n}) {\n  const {\n    gradientHorizontalMaxLength,\n    gradientHorizontalMinLength,\n    gradientVerticalMaxLength,\n    gradientVerticalMinLength\n  } = legendConfig;\n  const dir = direction({\n    legend,\n    legendConfig,\n    channel,\n    scaleType\n  });\n\n  if (dir === 'horizontal') {\n    const orient = getFirstDefined(legend.orient, legendConfig.orient);\n\n    if (orient === 'top' || orient === 'bottom') {\n      return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n    } else {\n      return gradientHorizontalMinLength;\n    }\n  } else {\n    // vertical / undefined (Vega uses vertical by default)\n    return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n  }\n}\n\nfunction gradientLengthSignal(model, sizeType, min, max) {\n  const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {\n    signal: `clamp(${sizeSignal}, ${min}, ${max})`\n  };\n}\n\nexport function defaultLabelOverlap(scaleType) {\n  if (contains(['quantile', 'threshold', 'log'], scaleType)) {\n    return 'greedy';\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../../../src/compile/legend/properties.ts"],"names":[],"mappings":"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","sourcesContent":["import {LabelOverlap, LegendOrient, LegendType, SymbolShape} from 'vega';\nimport {Channel, isColorChannel} from '../../channel';\nimport {\n  FieldDefWithCondition,\n  MarkPropFieldDef,\n  TypedFieldDef,\n  valueArray,\n  ValueDefWithCondition\n} from '../../channeldef';\nimport {Legend, LegendConfig} from '../../legend';\nimport {Mark} from '../../mark';\nimport {isContinuousToContinuous, ScaleType} from '../../scale';\nimport {TimeUnit} from '../../timeunit';\nimport {contains, getFirstDefined} from '../../util';\nimport {Model} from '../model';\nimport {getFirstConditionValue} from './encode';\n\nexport function values(legend: Legend, fieldDef: TypedFieldDef<string>) {\n  const vals = legend.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n  return undefined;\n}\n\nexport function defaultSymbolType(\n  mark: Mark,\n  channel: Channel,\n  shapeChannelDef:\n    | FieldDefWithCondition<MarkPropFieldDef<string>, SymbolShape>\n    | ValueDefWithCondition<MarkPropFieldDef<string>, SymbolShape>,\n  markShape: SymbolShape\n): SymbolShape {\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    const shape = getFirstConditionValue(shapeChannelDef) ?? markShape;\n    if (shape) {\n      return shape;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\n\nexport function clipHeight(legendType: LegendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n  return undefined;\n}\n\nexport function type(params: {\n  legend: Legend;\n  channel: Channel;\n  timeUnit?: TimeUnit;\n  scaleType: ScaleType;\n  alwaysReturn: boolean;\n}): LegendType {\n  const {legend} = params;\n\n  return getFirstDefined(legend.type, defaultType(params));\n}\n\nexport function defaultType({\n  channel,\n  timeUnit,\n  scaleType,\n  alwaysReturn\n}: {\n  channel: Channel;\n  timeUnit?: TimeUnit;\n  scaleType: ScaleType;\n  alwaysReturn: boolean;\n}): LegendType {\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n\n    if (isContinuousToContinuous(scaleType)) {\n      return alwaysReturn ? 'gradient' : undefined;\n    }\n  }\n  return alwaysReturn ? 'symbol' : undefined;\n}\n\nexport function direction({\n  legend,\n  legendConfig,\n  timeUnit,\n  channel,\n  scaleType\n}: {\n  legend: Legend;\n  legendConfig: LegendConfig;\n  timeUnit?: TimeUnit;\n  channel: Channel;\n  scaleType: ScaleType;\n}) {\n  const orient = getFirstDefined(legend.orient, legendConfig.orient, 'right');\n\n  const legendType = type({legend, channel, timeUnit, scaleType, alwaysReturn: true});\n  return getFirstDefined(\n    legend.direction,\n    legendConfig[legendType ? 'gradientDirection' : 'symbolDirection'],\n    defaultDirection(orient, legendType)\n  );\n}\n\nfunction defaultDirection(orient: LegendOrient, legendType: LegendType) {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined: // undefined = \"right\" in Vega\n      return undefined; // vertical is Vega's default\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\n\nexport function defaultGradientLength({\n  legend,\n  legendConfig,\n  model,\n  channel,\n  scaleType\n}: {\n  legend: Legend;\n  legendConfig: LegendConfig;\n  model: Model;\n  channel: Channel;\n  scaleType: ScaleType;\n}) {\n  const {\n    gradientHorizontalMaxLength,\n    gradientHorizontalMinLength,\n    gradientVerticalMaxLength,\n    gradientVerticalMinLength\n  } = legendConfig;\n\n  const dir = direction({legend, legendConfig, channel, scaleType});\n\n  if (dir === 'horizontal') {\n    const orient = getFirstDefined(legend.orient, legendConfig.orient);\n    if (orient === 'top' || orient === 'bottom') {\n      return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n    } else {\n      return gradientHorizontalMinLength;\n    }\n  } else {\n    // vertical / undefined (Vega uses vertical by default)\n    return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n  }\n}\n\nfunction gradientLengthSignal(model: Model, sizeType: 'width' | 'height', min: number, max: number) {\n  const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {signal: `clamp(${sizeSignal}, ${min}, ${max})`};\n}\n\nexport function defaultLabelOverlap(scaleType: ScaleType): LabelOverlap {\n  if (contains(['quantile', 'threshold', 'log'], scaleType)) {\n    return 'greedy';\n  }\n  return undefined;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}