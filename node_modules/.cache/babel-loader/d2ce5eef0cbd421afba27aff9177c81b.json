{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst linechart_1 = require(\"../render/linechart\");\n\nconst render_utils_1 = require(\"../render/render_utils\");\n\nconst dom_1 = require(\"../util/dom\");\n/**\n * Renders a tf.Model training 'History'.\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.history', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * const history = await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32\n * });\n *\n * tfvis.show.history(surface, history, ['loss', 'acc']);\n * ```\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.history live', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * const history = [];\n * await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32,\n *    callbacks: {\n *      onEpochEnd: (epoch, log) => {\n *        history.push(log);\n *        tfvis.show.history(surface, history, ['loss', 'acc']);\n *      }\n *    }\n * });\n * ```\n *\n * @param history A history like object. Either a tfjs-layers `History` object\n *  or an array of tfjs-layers `Logs` objects.\n * @param metrics An array of strings for each metric to plot from the history\n *  object. Using this allows you to control which metrics appear on the same\n *  plot.\n * @param opts Optional parameters for the line charts.\n */\n\n/**\n * @doc {heading: 'Models & Tensors', subheading: 'Model Training', namespace:\n * 'show'}\n */\n\n\nfunction history(container, history, metrics, opts = {}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Get the draw surface\n    const drawArea = render_utils_1.getDrawArea(container); // We organize the data from the history object into discrete plot data\n    // objects so that we can group together appropriate metrics into single\n    // multi-series charts.\n\n    const plots = {};\n\n    for (const metric of metrics) {\n      if (!/val_/.test(metric)) {\n        // Non validation metric\n        const values = getValues(history, metric, metrics.indexOf(metric));\n        initPlot(plots, metric);\n        plots[metric].series.push(metric);\n        plots[metric].values.push(values);\n      } else {\n        // Validation metrics are grouped with their equivalent non validation\n        // metrics. Note that the corresponding non validation metric may not\n        // actually be included but we still want to use it as a plot name.\n        const nonValidationMetric = metric.replace('val_', '');\n        initPlot(plots, nonValidationMetric);\n        const values = getValues(history, metric, metrics.indexOf(metric));\n        plots[nonValidationMetric].series.push(metric);\n        plots[nonValidationMetric].values.push(values);\n      }\n    } // Render each plot specified above to a new subsurface.\n    // A plot may have multiple series.\n\n\n    const plotNames = Object.keys(plots);\n    const options = Object.assign({}, {\n      xLabel: 'Iteration',\n      yLabel: 'Value'\n    }, opts);\n    const renderPromises = [];\n\n    for (const name of plotNames) {\n      const subContainer = dom_1.subSurface(drawArea, name);\n      const series = plots[name].series;\n      const values = plots[name].values;\n\n      if (series.every(seriesName => Boolean(seriesName.match('acc')))) {\n        // Set a domain of 0-1 if all the series in this plot are related to\n        // accuracy. Can be overridden by setting zoomToFitAccuracy to true.\n        if (options.zoomToFitAccuracy) {\n          options.zoomToFit = true;\n        } else {\n          options.yAxisDomain = [0, 1];\n          delete options.zoomToFit;\n        }\n      }\n\n      const done = linechart_1.linechart(subContainer, {\n        values,\n        series\n      }, options);\n      renderPromises.push(done);\n    }\n\n    yield Promise.all(renderPromises);\n  });\n}\n\nexports.history = history;\n\nfunction initPlot(plot, name) {\n  if (plot[name] == null) {\n    plot[name] = {\n      series: [],\n      values: []\n    };\n  }\n}\n/*\n * Extracts a list of Point2D's suitable for plotting from a HistoryLike for\n * a single metric.\n * @param history a HistoryLike object\n * @param metric the metric to extract from the logs\n * @param metricIndex this is needed because the historylike can be a nested\n * list of logs for multiple metrics, this index lets us extract the correct\n * list.\n */\n\n\nfunction getValues(history, metric, metricIndex) {\n  if (Array.isArray(history)) {\n    // If we were passed a nested array we want to get the correct list\n    // for this given metric, metrix index gives us this list.\n    const metricHistory = Array.isArray(history[0]) ? history[metricIndex] : history;\n    const points = [];\n\n    for (let i = 0; i < metricHistory.length; i++) {\n      const log = metricHistory[i];\n      points.push({\n        x: i,\n        y: log[metric]\n      });\n    }\n\n    return points;\n  } else {\n    return history.history[metric].map((y, x) => ({\n      x,\n      y\n    }));\n  }\n}\n/**\n * Returns a collection of callbacks to pass to tf.Model.fit. Callbacks are\n * returned for the following events, `onBatchEnd` & `onEpochEnd`.\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.fitCallbacks', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32,\n *    callbacks: tfvis.show.fitCallbacks(surface, ['loss', 'acc']),\n * });\n * ```\n *\n * @param metrics List of metrics to plot.\n * @param opts Optional parameters\n */\n\n/**\n * @doc {heading: 'Models & Tensors', subheading: 'Model Training', namespace:\n * 'show'}\n */\n\n\nfunction fitCallbacks(container, metrics, opts = {}) {\n  const accumulators = {};\n  const callbackNames = opts.callbacks || ['onEpochEnd', 'onBatchEnd'];\n  const drawArea = render_utils_1.getDrawArea(container);\n  const historyOpts = Object.assign({}, opts);\n  delete historyOpts.callbacks;\n\n  function makeCallbackFor(callbackName) {\n    return (_, log) => __awaiter(this, void 0, void 0, function* () {\n      // Set a nicer x axis name where possible\n      if (/batch/i.test(callbackName)) {\n        historyOpts.xLabel = 'Batch';\n      } else if (/epoch/i.test(callbackName)) {\n        historyOpts.xLabel = 'Epoch';\n      } // Because of how the _ (iteration) numbers are given in the layers api\n      // we have to store each metric for each callback in different arrays else\n      // we cannot get accurate 'global' batch numbers for onBatchEnd.\n      // However at render time we want to be able to combine metrics for a\n      // given callback. So here we make a nested list of metrics, the first\n      // level are arrays for each callback, the second level contains arrays\n      // (of logs) for each metric within that callback.\n\n\n      const metricLogs = [];\n      const presentMetrics = [];\n\n      for (const metric of metrics) {\n        // not all logs have all kinds of metrics.\n        if (log[metric] != null) {\n          presentMetrics.push(metric);\n          const accumulator = getAccumulator(accumulators, callbackName, metric);\n          accumulator.push({\n            [metric]: log[metric]\n          });\n          metricLogs.push(accumulator);\n        }\n      }\n\n      const subContainer = dom_1.subSurface(drawArea, callbackName, {\n        title: callbackName\n      });\n      history(subContainer, metricLogs, presentMetrics, historyOpts);\n      yield render_utils_1.nextFrame();\n    });\n  }\n\n  const callbacks = {};\n  callbackNames.forEach(name => {\n    callbacks[name] = makeCallbackFor(name);\n  });\n  return callbacks;\n}\n\nexports.fitCallbacks = fitCallbacks;\n\nfunction getAccumulator(accumulators, callback, metric) {\n  if (accumulators[callback] == null) {\n    accumulators[callback] = {};\n  }\n\n  if (accumulators[callback][metric] == null) {\n    accumulators[callback][metric] = [];\n  }\n\n  return accumulators[callback][metric];\n}","map":{"version":3,"sources":["../../src/show/history.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Logs} from '@tensorflow/tfjs-layers';\n\nimport {linechart} from '../render/linechart';\nimport {getDrawArea, nextFrame} from '../render/render_utils';\nimport {Drawable, Point2D, XYPlotOptions} from '../types';\nimport {subSurface} from '../util/dom';\n\n/**\n * Renders a tf.Model training 'History'.\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.history', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * const history = await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32\n * });\n *\n * tfvis.show.history(surface, history, ['loss', 'acc']);\n * ```\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.history live', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * const history = [];\n * await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32,\n *    callbacks: {\n *      onEpochEnd: (epoch, log) => {\n *        history.push(log);\n *        tfvis.show.history(surface, history, ['loss', 'acc']);\n *      }\n *    }\n * });\n * ```\n *\n * @param history A history like object. Either a tfjs-layers `History` object\n *  or an array of tfjs-layers `Logs` objects.\n * @param metrics An array of strings for each metric to plot from the history\n *  object. Using this allows you to control which metrics appear on the same\n *  plot.\n * @param opts Optional parameters for the line charts.\n */\n/**\n * @doc {heading: 'Models & Tensors', subheading: 'Model Training', namespace:\n * 'show'}\n */\nexport async function history(\n    container: Drawable, history: HistoryLike, metrics: string[],\n    opts: HistoryOptions = {}): Promise<void> {\n  // Get the draw surface\n  const drawArea = getDrawArea(container);\n\n  // We organize the data from the history object into discrete plot data\n  // objects so that we can group together appropriate metrics into single\n  // multi-series charts.\n  const plots: HistoryPlotData = {};\n  for (const metric of metrics) {\n    if (!(/val_/.test(metric))) {\n      // Non validation metric\n      const values = getValues(history, metric, metrics.indexOf(metric));\n      initPlot(plots, metric);\n      plots[metric].series.push(metric);\n      plots[metric].values.push(values);\n    } else {\n      // Validation metrics are grouped with their equivalent non validation\n      // metrics. Note that the corresponding non validation metric may not\n      // actually be included but we still want to use it as a plot name.\n      const nonValidationMetric = metric.replace('val_', '');\n      initPlot(plots, nonValidationMetric);\n      const values = getValues(history, metric, metrics.indexOf(metric));\n      plots[nonValidationMetric].series.push(metric);\n      plots[nonValidationMetric].values.push(values);\n    }\n  }\n\n  // Render each plot specified above to a new subsurface.\n  // A plot may have multiple series.\n  const plotNames = Object.keys(plots);\n  const options =\n      Object.assign({}, {xLabel: 'Iteration', yLabel: 'Value'}, opts);\n\n  const renderPromises = [];\n  for (const name of plotNames) {\n    const subContainer = subSurface(drawArea, name);\n    const series = plots[name].series;\n    const values = plots[name].values;\n\n    if (series.every(seriesName => Boolean(seriesName.match('acc')))) {\n      // Set a domain of 0-1 if all the series in this plot are related to\n      // accuracy. Can be overridden by setting zoomToFitAccuracy to true.\n      if (options.zoomToFitAccuracy) {\n        options.zoomToFit = true;\n      } else {\n        options.yAxisDomain = [0, 1];\n        delete options.zoomToFit;\n      }\n    }\n\n    const done = linechart(subContainer, {values, series}, options);\n    renderPromises.push(done);\n  }\n  await Promise.all(renderPromises);\n}\n\ninterface HistoryOptions extends XYPlotOptions {\n  zoomToFitAccuracy?: boolean;\n}\n\ntype HistoryLike = Logs[]|Logs[][]|{\n  history: {\n    [key: string]: number[],\n  }\n};\n\ninterface HistoryPlotData {\n  [name: string]: {\n    series: string[],\n    values: Point2D[][],\n  };\n}\n\nfunction initPlot(plot: HistoryPlotData, name: string) {\n  if (plot[name] == null) {\n    plot[name] = {series: [], values: []};\n  }\n}\n\n/*\n * Extracts a list of Point2D's suitable for plotting from a HistoryLike for\n * a single metric.\n * @param history a HistoryLike object\n * @param metric the metric to extract from the logs\n * @param metricIndex this is needed because the historylike can be a nested\n * list of logs for multiple metrics, this index lets us extract the correct\n * list.\n */\nfunction getValues(\n    history: HistoryLike, metric: string, metricIndex: number): Point2D[] {\n  if (Array.isArray(history)) {\n    // If we were passed a nested array we want to get the correct list\n    // for this given metric, metrix index gives us this list.\n    const metricHistory =\n        (Array.isArray(history[0]) ? history[metricIndex] : history) as Logs[];\n    const points: Point2D[] = [];\n\n    for (let i = 0; i < metricHistory.length; i++) {\n      const log = metricHistory[i];\n      points.push({x: i, y: log[metric]});\n    }\n    return points;\n  } else {\n    return history.history[metric].map((y, x) => ({x, y}));\n  }\n}\n\n/**\n * Returns a collection of callbacks to pass to tf.Model.fit. Callbacks are\n * returned for the following events, `onBatchEnd` & `onEpochEnd`.\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.fitCallbacks', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32,\n *    callbacks: tfvis.show.fitCallbacks(surface, ['loss', 'acc']),\n * });\n * ```\n *\n * @param metrics List of metrics to plot.\n * @param opts Optional parameters\n */\n/**\n * @doc {heading: 'Models & Tensors', subheading: 'Model Training', namespace:\n * 'show'}\n */\nexport function fitCallbacks(\n    container: Drawable, metrics: string[],\n    opts: FitCallbackOptions = {}): FitCallbackHandlers {\n  const accumulators: FitCallbackLogs = {};\n  const callbackNames = opts.callbacks || ['onEpochEnd', 'onBatchEnd'];\n  const drawArea = getDrawArea(container);\n\n  const historyOpts = Object.assign({}, opts);\n  delete historyOpts.callbacks;\n  function makeCallbackFor(callbackName: string) {\n    return async (_: number, log: Logs) => {\n      // Set a nicer x axis name where possible\n      if ((/batch/i).test(callbackName)) {\n        historyOpts.xLabel = 'Batch';\n      } else if ((/epoch/i).test(callbackName)) {\n        historyOpts.xLabel = 'Epoch';\n      }\n\n      // Because of how the _ (iteration) numbers are given in the layers api\n      // we have to store each metric for each callback in different arrays else\n      // we cannot get accurate 'global' batch numbers for onBatchEnd.\n\n      // However at render time we want to be able to combine metrics for a\n      // given callback. So here we make a nested list of metrics, the first\n      // level are arrays for each callback, the second level contains arrays\n      // (of logs) for each metric within that callback.\n\n      const metricLogs: Logs[][] = [];\n      const presentMetrics: string[] = [];\n      for (const metric of metrics) {\n        // not all logs have all kinds of metrics.\n        if (log[metric] != null) {\n          presentMetrics.push(metric);\n\n          const accumulator =\n              getAccumulator(accumulators, callbackName, metric);\n          accumulator.push({[metric]: log[metric]});\n          metricLogs.push(accumulator);\n        }\n      }\n\n      const subContainer =\n          subSurface(drawArea, callbackName, {title: callbackName});\n      history(subContainer, metricLogs, presentMetrics, historyOpts);\n      await nextFrame();\n    };\n  }\n\n  const callbacks: FitCallbackHandlers = {};\n  callbackNames.forEach((name: string) => {\n    callbacks[name] = makeCallbackFor(name);\n  });\n  return callbacks;\n}\n\ninterface FitCallbackHandlers {\n  [key: string]: (iteration: number, log: Logs) => Promise<void>;\n}\n\ninterface FitCallbackLogs {\n  [callback: string]: {\n    [metric: string]: Logs[],\n  };\n}\n\ninterface FitCallbackOptions extends HistoryOptions {\n  /**\n   * Array of callback names. Valid options\n   * are 'onEpochEnd' and 'onBatchEnd'. Defaults to ['onEpochEnd',\n   * 'onBatchEnd'].\n   */\n  callbacks?: string[];\n}\n\nfunction getAccumulator(\n    accumulators: FitCallbackLogs, callback: string, metric: string): Logs[] {\n  if (accumulators[callback] == null) {\n    accumulators[callback] = {};\n  }\n  if (accumulators[callback][metric] == null) {\n    accumulators[callback][metric] = [];\n  }\n  return accumulators[callback][metric];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}