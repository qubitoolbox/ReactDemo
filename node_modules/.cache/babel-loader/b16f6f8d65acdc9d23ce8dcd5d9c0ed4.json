{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nconst dom_1 = require(\"../util/dom\");\n\nconst render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a confusion matrix.\n *\n * Can optionally exclude the diagonal from being shaded if one wants the visual\n * focus to be on the incorrect classifications. Note that if the classification\n * is perfect (i.e. only the diagonal has values) then the diagonal will always\n * be shaded.\n *\n * ```js\n * const rows = 5;\n * const cols = 5;\n * const values = [];\n * for (let i = 0; i < rows; i++) {\n *   const row = []\n *   for (let j = 0; j < cols; j++) {\n *     row.push(Math.round(Math.random() * 50));\n *   }\n *   values.push(row);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Confusion Matrix', tab: 'Charts' };\n * tfvis.render.confusionMatrix(surface, data);\n * ```\n *\n * ```js\n * // The diagonal can be excluded from shading.\n *\n * const data = {\n *   values: [[4, 2, 8], [1, 7, 2], [3, 3, 20]],\n * }\n *\n * // Render to visor\n * const surface = {\n *  name: 'Confusion Matrix with Excluded Diagonal', tab: 'Charts'\n * };\n *\n * tfvis.render.confusionMatrix(surface, data, {\n *   shadeDiagonal: false\n * });\n * ```\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\n\nfunction confusionMatrix(container, data, opts = {}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const options = Object.assign({}, defaultOpts, opts);\n    const drawArea = render_utils_1.getDrawArea(container); // Format data for vega spec; an array of objects, one for for each cell\n    // in the matrix.\n\n    const values = [];\n    const inputArray = data.values;\n    const tickLabels = data.tickLabels || [];\n    const generateLabels = tickLabels.length === 0;\n    let nonDiagonalIsAllZeroes = true;\n\n    for (let i = 0; i < inputArray.length; i++) {\n      const label = generateLabels ? `Class ${i}` : tickLabels[i];\n\n      if (generateLabels) {\n        tickLabels.push(label);\n      }\n\n      for (let j = 0; j < inputArray[i].length; j++) {\n        const prediction = generateLabels ? `Class ${j}` : tickLabels[j];\n        const count = inputArray[i][j];\n\n        if (i === j && !options.shadeDiagonal) {\n          values.push({\n            label,\n            prediction,\n            count,\n            noFill: true\n          });\n        } else {\n          values.push({\n            label,\n            prediction,\n            count,\n            scaleCount: count\n          }); // When not shading the diagonal we want to check if there is a non\n          // zero value. If all values are zero we will not color them as the\n          // scale will be invalid.\n\n          if (count !== 0) {\n            nonDiagonalIsAllZeroes = false;\n          }\n        }\n      }\n    }\n\n    if (!options.shadeDiagonal && nonDiagonalIsAllZeroes) {\n      // User has specified requested not to shade the diagonal but all the other\n      // values are zero. We have two choices, don't shade the anything or only\n      // shade the diagonal. We choose to shade the diagonal as that is likely\n      // more helpful even if it is not what the user specified.\n      for (const val of values) {\n        if (val.noFill === true) {\n          val.noFill = false;\n          val.scaleCount = val.count;\n        }\n      }\n    }\n\n    const embedOpts = {\n      actions: false,\n      mode: 'vega-lite',\n      defaultStyle: false\n    };\n    const spec = {\n      'width': options.width || dom_1.getDefaultWidth(drawArea),\n      'height': options.height || dom_1.getDefaultHeight(drawArea),\n      'padding': 0,\n      'autosize': {\n        'type': 'fit',\n        'contains': 'padding',\n        'resize': true\n      },\n      'config': {\n        'axis': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        },\n        'text': {\n          'fontSize': options.fontSize\n        },\n        'legend': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        }\n      },\n      'data': {\n        'values': values\n      },\n      'encoding': {\n        'x': {\n          'field': 'prediction',\n          'type': 'ordinal',\n          'title': options.xLabel || 'prediction',\n          // Maintain sort order of the axis if labels is passed in\n          'scale': {\n            'domain': tickLabels\n          }\n        },\n        'y': {\n          'field': 'label',\n          'type': 'ordinal',\n          'title': options.yLabel || 'label',\n          // Maintain sort order of the axis if labels is passed in\n          'scale': {\n            'domain': tickLabels\n          }\n        }\n      },\n      'layer': [{\n        // The matrix\n        'transform': [{\n          'filter': 'datum.noFill != true'\n        }],\n        'mark': {\n          'type': 'rect'\n        },\n        'encoding': {\n          'color': {\n            'field': 'scaleCount',\n            'type': 'quantitative',\n            'scale': {\n              'range': options.colorMap\n            }\n          },\n          'tooltip': [{\n            'field': 'label',\n            'type': 'nominal'\n          }, {\n            'field': 'prediction',\n            'type': 'nominal'\n          }, {\n            'field': 'count',\n            'type': 'quantitative'\n          }]\n        }\n      }]\n    };\n\n    if (options.shadeDiagonal === false) {\n      spec.layer.push({\n        // render unfilled rects for the diagonal\n        'transform': [{\n          'filter': 'datum.noFill == true'\n        }],\n        'mark': {\n          'type': 'rect',\n          'fill': 'white'\n        },\n        'encoding': {\n          'tooltip': [{\n            'field': 'label',\n            'type': 'nominal'\n          }, {\n            'field': 'prediction',\n            'type': 'nominal'\n          }, {\n            'field': 'count',\n            'type': 'quantitative'\n          }]\n        }\n      });\n    }\n\n    if (options.showTextOverlay) {\n      spec.layer.push({\n        // The text labels\n        'mark': {\n          'type': 'text',\n          'baseline': 'middle'\n        },\n        'encoding': {\n          'text': {\n            'field': 'count',\n            'type': 'nominal'\n          }\n        }\n      });\n    }\n\n    const colorMap = typeof options.colorMap === 'string' ? {\n      scheme: options.colorMap\n    } : options.colorMap; //@ts-ignore\n\n    spec.layer[0].encoding.color.scale.range = colorMap;\n    yield vega_embed_1.default(drawArea, spec, embedOpts);\n  });\n}\n\nexports.confusionMatrix = confusionMatrix;\nconst defaultOpts = {\n  xLabel: null,\n  yLabel: null,\n  xType: 'nominal',\n  yType: 'nominal',\n  shadeDiagonal: true,\n  fontSize: 12,\n  showTextOverlay: true,\n  height: 400,\n  colorMap: ['#f7fbff', '#4292c6']\n};","map":{"version":3,"sources":["../../src/render/confusion_matrix.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport embed, {Mode, VisualizationSpec} from 'vega-embed';\n\nimport {ConfusionMatrixData, ConfusionMatrixOptions, Drawable,} from '../types';\nimport {getDefaultHeight, getDefaultWidth} from '../util/dom';\nimport {getDrawArea} from './render_utils';\n\n/**\n * Renders a confusion matrix.\n *\n * Can optionally exclude the diagonal from being shaded if one wants the visual\n * focus to be on the incorrect classifications. Note that if the classification\n * is perfect (i.e. only the diagonal has values) then the diagonal will always\n * be shaded.\n *\n * ```js\n * const rows = 5;\n * const cols = 5;\n * const values = [];\n * for (let i = 0; i < rows; i++) {\n *   const row = []\n *   for (let j = 0; j < cols; j++) {\n *     row.push(Math.round(Math.random() * 50));\n *   }\n *   values.push(row);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Confusion Matrix', tab: 'Charts' };\n * tfvis.render.confusionMatrix(surface, data);\n * ```\n *\n * ```js\n * // The diagonal can be excluded from shading.\n *\n * const data = {\n *   values: [[4, 2, 8], [1, 7, 2], [3, 3, 20]],\n * }\n *\n * // Render to visor\n * const surface = {\n *  name: 'Confusion Matrix with Excluded Diagonal', tab: 'Charts'\n * };\n *\n * tfvis.render.confusionMatrix(surface, data, {\n *   shadeDiagonal: false\n * });\n * ```\n */\n/** @doc {heading: 'Charts', namespace: 'render'} */\nexport async function confusionMatrix(\n    container: Drawable, data: ConfusionMatrixData,\n    opts: ConfusionMatrixOptions = {}): Promise<void> {\n  const options = Object.assign({}, defaultOpts, opts);\n  const drawArea = getDrawArea(container);\n\n  // Format data for vega spec; an array of objects, one for for each cell\n  // in the matrix.\n  const values: MatrixEntry[] = [];\n\n  const inputArray = data.values;\n  const tickLabels = data.tickLabels || [];\n  const generateLabels = tickLabels.length === 0;\n\n  let nonDiagonalIsAllZeroes = true;\n  for (let i = 0; i < inputArray.length; i++) {\n    const label = generateLabels ? `Class ${i}` : tickLabels[i];\n\n    if (generateLabels) {\n      tickLabels.push(label);\n    }\n\n    for (let j = 0; j < inputArray[i].length; j++) {\n      const prediction = generateLabels ? `Class ${j}` : tickLabels[j];\n\n      const count = inputArray[i][j];\n      if (i === j && !options.shadeDiagonal) {\n        values.push({\n          label,\n          prediction,\n          count,\n          noFill: true,\n        });\n      } else {\n        values.push({\n          label,\n          prediction,\n          count,\n          scaleCount: count,\n        });\n        // When not shading the diagonal we want to check if there is a non\n        // zero value. If all values are zero we will not color them as the\n        // scale will be invalid.\n        if (count !== 0) {\n          nonDiagonalIsAllZeroes = false;\n        }\n      }\n    }\n  }\n\n  if (!options.shadeDiagonal && nonDiagonalIsAllZeroes) {\n    // User has specified requested not to shade the diagonal but all the other\n    // values are zero. We have two choices, don't shade the anything or only\n    // shade the diagonal. We choose to shade the diagonal as that is likely\n    // more helpful even if it is not what the user specified.\n    for (const val of values) {\n      if (val.noFill === true) {\n        val.noFill = false;\n        val.scaleCount = val.count;\n      }\n    }\n  }\n\n  const embedOpts = {\n    actions: false,\n    mode: 'vega-lite' as Mode,\n    defaultStyle: false,\n  };\n\n  const spec: VisualizationSpec = {\n    'width': options.width || getDefaultWidth(drawArea),\n    'height': options.height || getDefaultHeight(drawArea),\n    'padding': 0,\n    'autosize': {\n      'type': 'fit',\n      'contains': 'padding',\n      'resize': true,\n    },\n    'config': {\n      'axis': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      },\n      'text': {'fontSize': options.fontSize},\n      'legend': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      }\n    },\n    'data': {'values': values},\n    'encoding': {\n      'x': {\n        'field': 'prediction',\n        'type': 'ordinal',\n        'title': options.xLabel || 'prediction',\n        // Maintain sort order of the axis if labels is passed in\n        'scale': {'domain': tickLabels},\n      },\n      'y': {\n        'field': 'label',\n        'type': 'ordinal',\n        'title': options.yLabel || 'label',\n        // Maintain sort order of the axis if labels is passed in\n        'scale': {'domain': tickLabels},\n      },\n    },\n    'layer': [\n      {\n        // The matrix\n        'transform': [\n          {'filter': 'datum.noFill != true'},\n        ],\n        'mark': {\n          'type': 'rect',\n        },\n        'encoding': {\n          'color': {\n            'field': 'scaleCount',\n            'type': 'quantitative',\n            'scale': {'range': options.colorMap},\n          },\n          'tooltip': [\n            {'field': 'label', 'type': 'nominal'},\n            {'field': 'prediction', 'type': 'nominal'},\n            {'field': 'count', 'type': 'quantitative'},\n          ]\n        },\n      },\n    ]\n  };\n\n  if (options.shadeDiagonal === false) {\n    spec.layer.push(\n        {\n          // render unfilled rects for the diagonal\n          'transform': [\n            {'filter': 'datum.noFill == true'},\n          ],\n          'mark': {\n            'type': 'rect',\n            'fill': 'white',\n          },\n          'encoding': {\n            'tooltip': [\n              {'field': 'label', 'type': 'nominal'},\n              {'field': 'prediction', 'type': 'nominal'},\n              {'field': 'count', 'type': 'quantitative'},\n            ]\n          },\n        },\n    );\n  }\n\n  if (options.showTextOverlay) {\n    spec.layer.push({\n      // The text labels\n      'mark': {'type': 'text', 'baseline': 'middle'},\n      'encoding': {\n        'text': {\n          'field': 'count',\n          'type': 'nominal',\n        },\n      }\n    });\n  }\n\n  const colorMap = typeof options.colorMap === 'string' ?\n      {scheme: options.colorMap} :\n      options.colorMap;\n  //@ts-ignore\n  spec.layer[0].encoding.color.scale.range = colorMap;\n\n  await embed(drawArea, spec, embedOpts);\n}\n\nconst defaultOpts: ConfusionMatrixOptions = {\n  xLabel: null,\n  yLabel: null,\n  xType: 'nominal',\n  yType: 'nominal',\n  shadeDiagonal: true,\n  fontSize: 12,\n  showTextOverlay: true,\n  height: 400,\n  colorMap: ['#f7fbff', '#4292c6'],\n};\n\ninterface MatrixEntry {\n  label: string;\n  prediction: string;\n  // The displayed count\n  count: number;\n  // The count values used to compute the color scale\n  scaleCount?: number;\n  noFill?: boolean;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}