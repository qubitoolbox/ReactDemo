{"ast":null,"code":"import { array } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { isScaleFieldDef, isTimeFormatFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression } from '../timeunit';\nimport { isText } from '../title';\nimport { QUANTITATIVE } from '../type';\nimport { getFirstDefined } from '../util';\nimport { deepEqual } from './../util';\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function applyMarkConfig(e, model, propsList) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n\n    if (value !== undefined) {\n      e[property] = {\n        value: value\n      };\n    }\n  }\n\n  return e;\n}\nexport function getStyles(mark) {\n  var _a;\n\n  return [].concat(mark.type, (_a = mark.style, _a !== null && _a !== void 0 ? _a : []));\n}\nexport function getMarkPropOrConfig(channel, mark, config) {\n  return getFirstDefined(mark[channel], getMarkConfig(channel, mark, config));\n}\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\n\nexport function getMarkConfig(channel, mark, config, {\n  vgChannel\n} = {} // Note: Ham: I use `any` here as it's too hard to make TS knows that MarkConfig[vgChannel] would have the same type as MarkConfig[P]\n) {\n  return getFirstDefined( // style config has highest precedence\n  vgChannel ? getStyleConfig(channel, mark, config.style) : undefined, getStyleConfig(channel, mark, config.style), // then mark-specific config\n  vgChannel ? config[mark.type][vgChannel] : undefined, config[mark.type][channel], // If there is vgChannel, skip vl channel.\n  // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n  vgChannel ? config.mark[vgChannel] : config.mark[channel]);\n}\nexport function getStyleConfig(prop, mark, styleConfigIndex) {\n  const styles = getStyles(mark);\n  let value;\n\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style]; // MarkConfig extends VgMarkConfig so a prop may not be a valid property for style\n    // However here we also check if it is defined, so it is okay to cast here\n\n    const p = prop;\n\n    if (styleConfig && styleConfig[p] !== undefined) {\n      value = styleConfig[p];\n    }\n  }\n\n  return value;\n}\nexport function formatSignalRef(fieldDef, specifiedFormat, expr, config) {\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = isScaleFieldDef(fieldDef) && fieldDef['scale'] && fieldDef['scale'].type === ScaleType.UTC;\n    return {\n      signal: timeFormatExpression(vgField(fieldDef, {\n        expr\n      }), fieldDef.timeUnit, specifiedFormat, config.timeFormat, isUTCScale, true)\n    };\n  } else {\n    const format = numberFormat(fieldDef, specifiedFormat, config);\n\n    if (isBinning(fieldDef.bin)) {\n      const startField = vgField(fieldDef, {\n        expr\n      });\n      const endField = vgField(fieldDef, {\n        expr,\n        binSuffix: 'end'\n      });\n      return {\n        signal: binFormatExpression(startField, endField, format, config)\n      };\n    } else if (fieldDef.type === 'quantitative' || format) {\n      return {\n        signal: `${formatExpr(vgField(fieldDef, {\n          expr,\n          binSuffix: 'range'\n        }), format)}`\n      };\n    } else {\n      return {\n        signal: `''+${vgField(fieldDef, {\n          expr\n        })}`\n      };\n    }\n  }\n}\n/**\n * Returns number format for a fieldDef\n */\n\nexport function numberFormat(fieldDef, specifiedFormat, config) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (fieldDef.type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return config.numberFormat;\n  }\n\n  return undefined;\n}\n\nfunction formatExpr(field, format) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nexport function numberFormatExpr(field, specifiedFormat, config) {\n  return formatExpr(field, specifiedFormat !== null && specifiedFormat !== void 0 ? specifiedFormat : config.numberFormat);\n}\nexport function binFormatExpression(startField, endField, format, config) {\n  return `${fieldValidPredicate(startField, false)} ? \"null\" : ${numberFormatExpr(startField, format, config)} + \"${BIN_RANGE_DELIMITER}\" + ${numberFormatExpr(endField, format, config)}`;\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\n\nexport function timeFormatExpression(field, timeUnit, format, rawTimeFormat, // should be provided only for actual text and headers, not axis/legend labels\nisUTCScale, alwaysReturn = false) {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    format = format !== null && format !== void 0 ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n\n    if (format || alwaysReturn) {\n      return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n    } else {\n      return undefined;\n    }\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\n\nexport function sortParams(orderDef, fieldRefOption) {\n  return array(orderDef).reduce((s, orderChannelDef) => {\n    var _a;\n\n    s.field.push(vgField(orderChannelDef, fieldRefOption));\n    s.order.push((_a = orderChannelDef.sort, _a !== null && _a !== void 0 ? _a : 'ascending'));\n    return s;\n  }, {\n    field: [],\n    order: []\n  });\n}\nexport function mergeTitleFieldDefs(f1, f2) {\n  const merged = [...f1];\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (deepEqual(fieldDef1, fdToMerge)) {\n        return;\n      }\n    }\n\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\nexport function mergeTitle(title1, title2) {\n  if (deepEqual(title1, title2) || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    return [...array(title1), ...array(title2)].join(', ');\n  }\n}\nexport function mergeTitleComponent(v1, v2) {\n  const v1Val = v1.value;\n  const v2Val = v2.value;\n\n  if (v1Val == null || v2Val === null) {\n    return {\n      explicit: v1.explicit,\n      value: null\n    };\n  } else if (isText(v1Val) && isText(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1Val, v2Val)\n    };\n  } else if (!isText(v1Val) && !isText(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1Val, v2Val)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n\n\n  throw new Error('It should never reach here');\n}","map":{"version":3,"sources":["../../../src/compile/common.ts"],"names":[],"mappings":"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","sourcesContent":["import {Text} from 'vega';\nimport {array} from 'vega-util';\nimport {isBinning} from '../bin';\nimport {\n  FieldDefBase,\n  FieldRefOption,\n  isScaleFieldDef,\n  isTimeFormatFieldDef,\n  OrderFieldDef,\n  TypedFieldDef,\n  vgField\n} from '../channeldef';\nimport {Config, StyleConfigIndex} from '../config';\nimport {MarkConfig, MarkDef} from '../mark';\nimport {fieldValidPredicate} from '../predicate';\nimport {ScaleType} from '../scale';\nimport {SortFields} from '../sort';\nimport {formatExpression, TimeUnit} from '../timeunit';\nimport {isText} from '../title';\nimport {QUANTITATIVE} from '../type';\nimport {getFirstDefined} from '../util';\nimport {BaseMarkConfig, VgEncodeEntry} from '../vega.schema';\nimport {deepEqual} from './../util';\nimport {AxisComponentProps} from './axis/component';\nimport {Explicit} from './split';\nimport {UnitModel} from './unit';\n\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: (keyof MarkConfig)[]) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  }\n  return e;\n}\n\nexport function getStyles(mark: MarkDef): string[] {\n  return [].concat(mark.type, mark.style ?? []);\n}\n\nexport function getMarkPropOrConfig<P extends keyof MarkConfig>(channel: P, mark: MarkDef, config: Config) {\n  return getFirstDefined(mark[channel], getMarkConfig(channel, mark, config));\n}\n\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig<P extends keyof MarkConfig>(\n  channel: P,\n  mark: MarkDef,\n  config: Config,\n  {vgChannel}: {vgChannel?: any} = {} // Note: Ham: I use `any` here as it's too hard to make TS knows that MarkConfig[vgChannel] would have the same type as MarkConfig[P]\n): MarkConfig[P] {\n  return getFirstDefined(\n    // style config has highest precedence\n    vgChannel ? getStyleConfig(channel, mark, config.style) : undefined,\n    getStyleConfig(channel, mark, config.style),\n    // then mark-specific config\n    vgChannel ? config[mark.type][vgChannel] : undefined,\n    config[mark.type][channel],\n    // If there is vgChannel, skip vl channel.\n    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n    vgChannel ? config.mark[vgChannel] : config.mark[channel]\n  );\n}\n\nexport function getStyleConfig<P extends keyof MarkConfig>(prop: P, mark: MarkDef, styleConfigIndex: StyleConfigIndex) {\n  const styles = getStyles(mark);\n  let value;\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style];\n\n    // MarkConfig extends VgMarkConfig so a prop may not be a valid property for style\n    // However here we also check if it is defined, so it is okay to cast here\n    const p = prop as keyof BaseMarkConfig;\n    if (styleConfig && styleConfig[p] !== undefined) {\n      value = styleConfig[p];\n    }\n  }\n  return value;\n}\n\nexport function formatSignalRef(\n  fieldDef: TypedFieldDef<string>,\n  specifiedFormat: string,\n  expr: 'datum' | 'parent' | 'datum.datum',\n  config: Config\n) {\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = isScaleFieldDef(fieldDef) && fieldDef['scale'] && fieldDef['scale'].type === ScaleType.UTC;\n    return {\n      signal: timeFormatExpression(\n        vgField(fieldDef, {\n          expr\n        }),\n        fieldDef.timeUnit,\n        specifiedFormat,\n        config.timeFormat,\n        isUTCScale,\n        true\n      )\n    };\n  } else {\n    const format = numberFormat(fieldDef, specifiedFormat, config);\n    if (isBinning(fieldDef.bin)) {\n      const startField = vgField(fieldDef, {expr});\n      const endField = vgField(fieldDef, {expr, binSuffix: 'end'});\n      return {\n        signal: binFormatExpression(startField, endField, format, config)\n      };\n    } else if (fieldDef.type === 'quantitative' || format) {\n      return {\n        signal: `${formatExpr(vgField(fieldDef, {expr, binSuffix: 'range'}), format)}`\n      };\n    } else {\n      return {signal: `''+${vgField(fieldDef, {expr})}`};\n    }\n  }\n}\n\n/**\n * Returns number format for a fieldDef\n */\nexport function numberFormat(fieldDef: TypedFieldDef<string>, specifiedFormat: string, config: Config) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (fieldDef.type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\nfunction formatExpr(field: string, format: string) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nexport function numberFormatExpr(field: string, specifiedFormat: string, config: Config) {\n  return formatExpr(field, specifiedFormat ?? config.numberFormat);\n}\n\nexport function binFormatExpression(startField: string, endField: string, format: string, config: Config) {\n  return `${fieldValidPredicate(startField, false)} ? \"null\" : ${numberFormatExpr(\n    startField,\n    format,\n    config\n  )} + \"${BIN_RANGE_DELIMITER}\" + ${numberFormatExpr(endField, format, config)}`;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(\n  field: string,\n  timeUnit: TimeUnit,\n  format: string,\n  rawTimeFormat: string, // should be provided only for actual text and headers, not axis/legend labels\n  isUTCScale: boolean,\n  alwaysReturn = false\n): string {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    format = format ?? rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n    if (format || alwaysReturn) {\n      return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n    } else {\n      return undefined;\n    }\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(\n  orderDef: OrderFieldDef<string> | OrderFieldDef<string>[],\n  fieldRefOption?: FieldRefOption\n): SortFields {\n  return array(orderDef).reduce(\n    (s, orderChannelDef) => {\n      s.field.push(vgField(orderChannelDef, fieldRefOption));\n      s.order.push(orderChannelDef.sort ?? 'ascending');\n      return s;\n    },\n    {field: [], order: []}\n  );\n}\n\nexport type AxisTitleComponent = AxisComponentProps['title'];\n\nexport function mergeTitleFieldDefs(f1: readonly FieldDefBase<string>[], f2: readonly FieldDefBase<string>[]) {\n  const merged = [...f1];\n\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (deepEqual(fieldDef1, fdToMerge)) {\n        return;\n      }\n    }\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\n\nexport function mergeTitle(title1: Text, title2: Text) {\n  if (deepEqual(title1, title2) || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    return [...array(title1), ...array(title2)].join(', ');\n  }\n}\n\nexport function mergeTitleComponent(v1: Explicit<AxisTitleComponent>, v2: Explicit<AxisTitleComponent>) {\n  const v1Val = v1.value;\n  const v2Val = v2.value;\n\n  if (v1Val == null || v2Val === null) {\n    return {\n      explicit: v1.explicit,\n      value: null\n    };\n  } else if (isText(v1Val) && isText(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1Val, v2Val)\n    };\n  } else if (!isText(v1Val) && !isText(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1Val, v2Val)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n  throw new Error('It should never reach here');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}