{"ast":null,"code":"import { isBoolean, isObject } from 'vega-util';\nimport { COLOR, COLUMN, FILL, FILLOPACITY, OPACITY, ROW, SHAPE, SIZE, STROKE, STROKEOPACITY, STROKEWIDTH } from './channel';\nimport { normalizeBin } from './channeldef';\nimport { keys, varName } from './util';\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\n\nexport function binToString(bin) {\n  if (isBoolean(bin)) {\n    bin = normalizeBin(bin, undefined);\n  }\n\n  return 'bin' + keys(bin).map(p => isSelectionExtent(bin[p]) ? varName(`_${p}_${Object.entries(bin[p])}`) : varName(`_${p}_${bin[p]}`)).join('');\n}\n/**\n * Vega-Lite should bin the data.\n */\n\nexport function isBinning(bin) {\n  return bin === true || isBinParams(bin) && !bin.binned;\n}\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\n\nexport function isBinned(bin) {\n  return bin === 'binned' || isBinParams(bin) && bin.binned === true;\n}\nexport function isBinParams(bin) {\n  return isObject(bin);\n}\nexport function isSelectionExtent(extent) {\n  var _a;\n\n  return (_a = extent) === null || _a === void 0 ? void 0 : _a['selection'];\n}\nexport function autoMaxBins(channel) {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY: // Facets and Size shouldn't have too many bins\n    // We choose 6 like shape to simplify the rule [falls through]\n\n    case SHAPE:\n      return 6;\n    // Vega's \"shape\" has 6 distinct values\n\n    default:\n      return 10;\n  }\n}","map":{"version":3,"sources":["../../src/bin.ts"],"names":[],"mappings":"AAAA,SAAQ,SAAR,EAAmB,QAAnB,QAAkC,WAAlC;AACA,SAEE,KAFF,EAGE,MAHF,EAIE,IAJF,EAKE,WALF,EAME,OANF,EAOE,GAPF,EAQE,KARF,EASE,IATF,EAUE,MAVF,EAWE,aAXF,EAYE,WAZF,QAaO,WAbP;AAcA,SAAQ,YAAR,QAA2B,cAA3B;AAEA,SAAQ,IAAR,EAAc,OAAd,QAA4B,QAA5B;AA0EA;;;;AAGA,OAAM,SAAU,WAAV,CAAsB,GAAtB,EAA2C;AAC/C,MAAI,SAAS,CAAC,GAAD,CAAb,EAAoB;AAClB,IAAA,GAAG,GAAG,YAAY,CAAC,GAAD,EAAM,SAAN,CAAlB;AACD;;AACD,SACE,QACA,IAAI,CAAC,GAAD,CAAJ,CACG,GADH,CACO,CAAC,IAAK,iBAAiB,CAAC,GAAG,CAAC,CAAD,CAAJ,CAAjB,GAA4B,OAAO,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,OAAP,CAAe,GAAG,CAAC,CAAD,CAAlB,CAAsB,EAAhC,CAAnC,GAAyE,OAAO,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAD,CAAG,EAAhB,CAD7F,EAEG,IAFH,CAEQ,EAFR,CAFF;AAMD;AAED;;;;AAGA,OAAM,SAAU,SAAV,CAAoB,GAApB,EAAuD;AAC3D,SAAO,GAAG,KAAK,IAAR,IAAiB,WAAW,CAAC,GAAD,CAAX,IAAoB,CAAC,GAAG,CAAC,MAAjD;AACD;AAED;;;;AAGA,OAAM,SAAU,QAAV,CAAmB,GAAnB,EAAsD;AAC1D,SAAO,GAAG,KAAK,QAAR,IAAqB,WAAW,CAAC,GAAD,CAAX,IAAoB,GAAG,CAAC,MAAJ,KAAe,IAA/D;AACD;AAED,OAAM,SAAU,WAAV,CAAsB,GAAtB,EAAyD;AAC7D,SAAO,QAAQ,CAAC,GAAD,CAAf;AACD;AAED,OAAM,SAAU,iBAAV,CAA4B,MAA5B,EAA6C;;;AACjD,SAAA,CAAA,EAAA,GAAO,MAAP,MAAa,IAAb,IAAa,EAAA,KAAA,KAAA,CAAb,GAAa,KAAA,CAAb,GAAa,EAAA,CAAG,WAAH,CAAb;AACD;AAED,OAAM,SAAU,WAAV,CAAsB,OAAtB,EAAuC;AAC3C,UAAQ,OAAR;AACE,SAAK,GAAL;AACA,SAAK,MAAL;AACA,SAAK,IAAL;AACA,SAAK,KAAL;AACA,SAAK,IAAL;AACA,SAAK,MAAL;AACA,SAAK,WAAL;AACA,SAAK,OAAL;AACA,SAAK,WAAL;AACA,SAAK,aAAL,CAVF,CAWE;AACA;;AACA,SAAK,KAAL;AACE,aAAO,CAAP;AAAU;;AACZ;AACE,aAAO,EAAP;AAhBJ;AAkBD","sourcesContent":["import {isBoolean, isObject} from 'vega-util';\nimport {\n  Channel,\n  COLOR,\n  COLUMN,\n  FILL,\n  FILLOPACITY,\n  OPACITY,\n  ROW,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEOPACITY,\n  STROKEWIDTH\n} from './channel';\nimport {normalizeBin} from './channeldef';\nimport {SelectionExtent} from './selection';\nimport {keys, varName} from './util';\n\nexport interface BaseBin {\n  /**\n   * The number base to use for automatic bin determination (default is base 10).\n   *\n   * __Default value:__ `10`\n   *\n   */\n  base?: number;\n  /**\n   * An exact step size to use between bins.\n   *\n   * __Note:__ If provided, options such as maxbins will be ignored.\n   */\n  step?: number;\n  /**\n   * An array of allowable step sizes to choose from.\n   * @minItems 1\n   */\n  steps?: number[];\n  /**\n   * A minimum allowable step size (particularly useful for integer values).\n   */\n  minstep?: number;\n  /**\n   * Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n   *\n   * __Default value:__ `[5, 2]`\n   *\n   * @minItems 1\n   */\n  divide?: [number, number];\n  /**\n   * Maximum number of bins.\n   *\n   * __Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels\n   *\n   * @minimum 2\n   */\n  maxbins?: number;\n  /**\n   * A value in the binned domain at which to anchor the bins, shifting the bin boundaries if necessary to ensure that a boundary aligns with the anchor value.\n   *\n   * __Default value:__ the minimum bin extent value\n   */\n  anchor?: number;\n  /**\n   * If true, attempts to make the bin boundaries use human-friendly boundaries, such as multiples of ten.\n   *\n   * __Default value:__ `true`\n   */\n  nice?: boolean;\n}\n\n/**\n * Binning properties or boolean flag for determining whether to bin data or not.\n */\nexport interface BinParams extends BaseBin {\n  /**\n   * A two-element (`[min, max]`) array indicating the range of desired bin values.\n   */\n  extent?: BinExtent; // VgBinTransform uses a different extent so we need to pull this out.\n\n  /**\n   * When set to `true`, Vega-Lite treats the input data as already binned.\n   */\n  binned?: boolean;\n}\n\nexport type Bin = boolean | BinParams | 'binned' | null;\n\nexport type BinExtent = [number, number] | SelectionExtent;\n\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\nexport function binToString(bin: BinParams | true) {\n  if (isBoolean(bin)) {\n    bin = normalizeBin(bin, undefined);\n  }\n  return (\n    'bin' +\n    keys(bin)\n      .map(p => (isSelectionExtent(bin[p]) ? varName(`_${p}_${Object.entries(bin[p])}`) : varName(`_${p}_${bin[p]}`)))\n      .join('')\n  );\n}\n\n/**\n * Vega-Lite should bin the data.\n */\nexport function isBinning(bin: BinParams | boolean | 'binned'): bin is BinParams | true {\n  return bin === true || (isBinParams(bin) && !bin.binned);\n}\n\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\nexport function isBinned(bin: BinParams | boolean | 'binned'): bin is 'binned' {\n  return bin === 'binned' || (isBinParams(bin) && bin.binned === true);\n}\n\nexport function isBinParams(bin: BinParams | boolean | 'binned'): bin is BinParams {\n  return isObject(bin);\n}\n\nexport function isSelectionExtent(extent: BinExtent): extent is SelectionExtent {\n  return extent?.['selection'];\n}\n\nexport function autoMaxBins(channel?: Channel): number {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    // Facets and Size shouldn't have too many bins\n    // We choose 6 like shape to simplify the rule [falls through]\n    case SHAPE:\n      return 6; // Vega's \"shape\" has 6 distinct values\n    default:\n      return 10;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}