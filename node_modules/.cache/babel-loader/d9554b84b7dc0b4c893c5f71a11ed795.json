{"ast":null,"code":"import { GuideLabelStyle, Skip, Symbols, Gradient, Discrete, LegendScales } from './guides/constants';\nimport legendGradient from './guides/legend-gradient';\nimport legendGradientDiscrete from './guides/legend-gradient-discrete';\nimport legendGradientLabels from './guides/legend-gradient-labels';\nimport { default as legendSymbolGroups, legendSymbolLayout } from './guides/legend-symbol-groups';\nimport legendTitle from './guides/legend-title';\nimport guideGroup from './guides/guide-group';\nimport { getEncoding, getStyle, lookup } from './guides/guide-util';\nimport parseExpression from './expression';\nimport parseMark from './mark';\nimport { LegendRole, LegendEntryRole } from './marks/roles';\nimport { addEncoders, extendEncode } from './encode/encode-util';\nimport { ref, deref } from '../util';\nimport { Collect, LegendEntries } from '../transforms';\nimport { isContinuous, isDiscretizing } from 'vega-scale';\nimport { error } from 'vega-util';\nexport default function (spec, scope) {\n  var config = scope.config.legend,\n      encode = spec.encode || {},\n      legendEncode = encode.legend || {},\n      name = legendEncode.name || undefined,\n      interactive = legendEncode.interactive,\n      style = legendEncode.style,\n      _ = lookup(spec, config),\n      entryEncode,\n      entryLayout,\n      params,\n      children,\n      type,\n      datum,\n      dataRef,\n      entryRef,\n      group; // resolve 'canonical' scale name\n\n\n  var scale = LegendScales.reduce(function (a, b) {\n    return a || spec[b];\n  }, 0);\n  if (!scale) error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n  type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n  datum = {\n    title: spec.title != null,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend group\n\n  legendEncode = extendEncode(buildLegendEncode(_, config), legendEncode, Skip); // encoding properties for legend entry sub-group\n\n  entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  }; // data source for legend values\n\n  entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // continuous gradient legend\n\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);\n  } // discrete gradient legend\n  else if (type === Discrete) {\n      children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n    } // symbol legend\n    else {\n        // determine legend symbol group layout\n        entryLayout = legendSymbolLayout(spec, config);\n        children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n        params.size = sizeExpression(spec, scope, children[0].marks);\n      } // generate legend marks\n\n\n  children = [guideGroup(LegendEntryRole, null, null, dataRef, interactive, entryEncode, children, entryLayout)]; // include legend title if defined\n\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  } // build legend specification\n\n\n  group = guideGroup(LegendRole, style, name, dataRef, interactive, legendEncode, children);\n  if (spec.zindex) group.zindex = spec.zindex; // parse legend specification\n\n  return parseMark(group, scope);\n}\n\nfunction legendType(spec, scaleType) {\n  var type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce(function (count, type) {\n    return count + (spec[type] ? 1 : 0);\n  }, 0);\n}\n\nfunction buildLegendEncode(_, config) {\n  var encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY')\n  });\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  var size = deref(getChannel('size', spec, marks)),\n      strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n      fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? `scale(\"${spec[name]}\",datum)` : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/legend.js"],"names":["GuideLabelStyle","Skip","Symbols","Gradient","Discrete","LegendScales","legendGradient","legendGradientDiscrete","legendGradientLabels","default","legendSymbolGroups","legendSymbolLayout","legendTitle","guideGroup","getEncoding","getStyle","lookup","parseExpression","parseMark","LegendRole","LegendEntryRole","addEncoders","extendEncode","ref","deref","Collect","LegendEntries","isContinuous","isDiscretizing","error","spec","scope","config","legend","encode","legendEncode","name","undefined","interactive","style","_","entryEncode","entryLayout","params","children","type","datum","dataRef","entryRef","group","scale","reduce","a","b","legendType","scaleType","title","vgrad","isVertical","add","buildLegendEncode","enter","x","value","y","scaleRef","count","objectProperty","limit","property","values","minstep","tickMinStep","formatType","formatSpecifier","format","gradient","labels","signalRef","gradientLength","columns","size","sizeExpression","marks","push","zindex","scaleCount","fill","stroke","update","orient","offset","padding","titlePadding","cornerRadius","strokeWidth","strokeDash","getChannel","fontSize","getFontSize"],"mappings":"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","sourcesContent":["import {\n  GuideLabelStyle, Skip,\n  Symbols, Gradient, Discrete, LegendScales\n} from './guides/constants';\nimport legendGradient from './guides/legend-gradient';\nimport legendGradientDiscrete from './guides/legend-gradient-discrete';\nimport legendGradientLabels from './guides/legend-gradient-labels';\nimport {default as legendSymbolGroups, legendSymbolLayout} from './guides/legend-symbol-groups';\nimport legendTitle from './guides/legend-title';\nimport guideGroup from './guides/guide-group';\nimport {getEncoding, getStyle, lookup} from './guides/guide-util';\nimport parseExpression from './expression';\nimport parseMark from './mark';\nimport {LegendRole, LegendEntryRole} from './marks/roles';\nimport {addEncoders, extendEncode} from './encode/encode-util';\nimport {ref, deref} from '../util';\nimport {Collect, LegendEntries} from '../transforms';\n\nimport {isContinuous, isDiscretizing} from 'vega-scale';\nimport {error} from 'vega-util';\n\nexport default function(spec, scope) {\n  var config = scope.config.legend,\n      encode = spec.encode || {},\n      legendEncode = encode.legend || {},\n      name = legendEncode.name || undefined,\n      interactive = legendEncode.interactive,\n      style = legendEncode.style,\n      _ = lookup(spec, config),\n      entryEncode, entryLayout, params, children,\n      type, datum, dataRef, entryRef, group;\n\n  // resolve 'canonical' scale name\n  var scale = LegendScales.reduce(function(a, b) { return a || spec[b]; }, 0);\n  if (!scale) error('Missing valid scale for legend.');\n\n  // resolve legend type (symbol, gradient, or discrete gradient)\n  type = legendType(spec, scope.scaleType(scale));\n\n  // single-element data source for legend group\n  datum = {\n    title:  spec.title != null,\n    type:   type,\n    vgrad:  type !== 'symbol' &&  _.isVertical()\n  };\n  dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // encoding properties for legend group\n  legendEncode = extendEncode(\n    buildLegendEncode(_, config), legendEncode, Skip\n  );\n\n  // encoding properties for legend entry sub-group\n  entryEncode = {enter: {x: {value: 0}, y: {value: 0}}};\n\n  // data source for legend values\n  entryRef = ref(scope.add(LegendEntries(params = {\n    type:    type,\n    scale:   scope.scaleRef(scale),\n    count:   scope.objectProperty(_('tickCount')),\n    limit:   scope.property(_('symbolLimit')),\n    values:  scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // continuous gradient legend\n  if (type === Gradient) {\n    children = [\n      legendGradient(spec, scale, config, encode.gradient),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n    // adjust default tick count based on the gradient length\n    params.count = params.count || scope.signalRef(\n      `max(2,2*floor((${deref(_.gradientLength())})/100))`\n    );\n  }\n\n  // discrete gradient legend\n  else if (type === Discrete) {\n    children = [\n      legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n  }\n\n  // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [\n      legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))\n    ];\n    // pass symbol size information to legend entry generator\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  }\n\n  // generate legend marks\n  children = [\n    guideGroup(LegendEntryRole, null, null, dataRef, interactive,\n               entryEncode, children, entryLayout)\n  ];\n\n  // include legend title if defined\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  }\n\n  // build legend specification\n  group = guideGroup(LegendRole, style, name, dataRef, interactive, legendEncode, children);\n  if (spec.zindex) group.zindex = spec.zindex;\n\n  // parse legend specification\n  return parseMark(group, scope);\n}\n\nfunction legendType(spec, scaleType) {\n  var type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient\n      : isDiscretizing(scaleType) ? Discrete\n      : Symbols;\n  }\n\n  return type !== Gradient ? type\n    : isDiscretizing(scaleType) ? Discrete\n    : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce(function(count, type) {\n    return count + (spec[type] ? 1 : 0);\n  }, 0);\n}\n\nfunction buildLegendEncode(_, config) {\n  var encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:       _('orient'),\n    offset:       _('offset'),\n    padding:      _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill:         _('fillColor'),\n    stroke:       _('strokeColor'),\n    strokeWidth:  config.strokeWidth,\n    strokeDash:   config.strokeDash,\n    x:            _('legendX'),\n    y:            _('legendY'),\n  });\n\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  var size = deref(getChannel('size', spec, marks)),\n      strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n      fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n\n  return parseExpression(\n    `max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`,\n    scope\n  );\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name]\n    ? `scale(\"${spec[name]}\",datum)`\n    : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n"]},"metadata":{},"sourceType":"module"}