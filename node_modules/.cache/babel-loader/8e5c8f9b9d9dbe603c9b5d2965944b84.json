{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '..';\nimport { isScaleChannel, X, Y } from '../../../channel';\nimport * as log from '../../../log';\nimport { hasContinuousDomain } from '../../../scale';\nimport { isLayerModel } from '../../model';\nconst scaleBindings = {\n  has: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n  parse: (model, selCmpt) => {\n    const bound = selCmpt.scales = [];\n\n    for (const proj of selCmpt.project.items) {\n      const channel = proj.channel;\n\n      if (!isScaleChannel(channel)) {\n        continue;\n      }\n\n      const scale = model.getScaleComponent(channel);\n      const scaleType = scale ? scale.get('type') : undefined;\n\n      if (!scale || !hasContinuousDomain(scaleType)) {\n        log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n        continue;\n      }\n\n      const extent = {\n        selection: selCmpt.name,\n        field: proj.field\n      };\n      scale.set('selectionExtent', extent, true);\n      bound.push(proj); // Bind both x/y for diag plot of repeated views.\n\n      if (model.repeater && model.repeater.row === model.repeater.column) {\n        const scale2 = model.getScaleComponent(channel === X ? Y : X);\n        scale2.set('selectionExtent', extent, true);\n      }\n    }\n  },\n  topLevelSignals: (model, selCmpt, signals) => {\n    const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0); // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n\n    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n      return signals;\n    } // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n\n\n    const namedSg = signals.filter(s => s.name === selCmpt.name)[0];\n    let update = namedSg.update;\n\n    if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n      namedSg.update = `{${bound.map(proj => `${stringValue(proj.field)}: ${proj.signals.data}`).join(', ')}}`;\n    } else {\n      for (const proj of bound) {\n        const mapping = `${stringValue(proj.field)}: ${proj.signals.data}`;\n\n        if (update.indexOf(mapping) < 0) {\n          update = `${update.substring(0, update.length - 1)}, ${mapping}}`;\n        }\n      }\n\n      namedSg.update = update;\n    }\n\n    return signals.concat(bound.map(proj => ({\n      name: proj.signals.data\n    })));\n  },\n  signals: (model, selCmpt, signals) => {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      for (const proj of selCmpt.scales) {\n        const signal = signals.filter(s => s.name === proj.signals.data)[0];\n        signal.push = 'outer';\n        delete signal.value;\n        delete signal.update;\n      }\n    }\n\n    return signals;\n  }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n  const scale = stringValue(model.scaleName(channel));\n  return `domain(${scale})`;\n}\n\nfunction isTopLevelLayer(model) {\n  var _a;\n\n  return model.parent && isLayerModel(model.parent) && (_a = !model.parent.parent, _a !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));\n}","map":{"version":3,"sources":["../../../../../src/compile/selection/transforms/scales.ts"],"names":[],"mappings":"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","sourcesContent":["import {stringValue} from 'vega-util';\nimport {VL_SELECTION_RESOLVE} from '..';\nimport {Channel, isScaleChannel, X, Y} from '../../../channel';\nimport * as log from '../../../log';\nimport {hasContinuousDomain} from '../../../scale';\nimport {UnitModel} from '../../unit';\nimport {SelectionProjection} from './project';\nimport {TransformCompiler} from './transforms';\nimport {isLayerModel, Model} from '../../model';\n\nconst scaleBindings: TransformCompiler = {\n  has: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n\n  parse: (model, selCmpt) => {\n    const bound: SelectionProjection[] = (selCmpt.scales = []);\n\n    for (const proj of selCmpt.project.items) {\n      const channel = proj.channel;\n\n      if (!isScaleChannel(channel)) {\n        continue;\n      }\n\n      const scale = model.getScaleComponent(channel);\n      const scaleType = scale ? scale.get('type') : undefined;\n\n      if (!scale || !hasContinuousDomain(scaleType)) {\n        log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n        continue;\n      }\n\n      const extent = {selection: selCmpt.name, field: proj.field};\n      scale.set('selectionExtent', extent, true);\n      bound.push(proj);\n\n      // Bind both x/y for diag plot of repeated views.\n      if (model.repeater && model.repeater.row === model.repeater.column) {\n        const scale2 = model.getScaleComponent(channel === X ? Y : X);\n        scale2.set('selectionExtent', extent, true);\n      }\n    }\n  },\n\n  topLevelSignals: (model, selCmpt, signals) => {\n    const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0);\n\n    // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n      return signals;\n    }\n\n    // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n    const namedSg = signals.filter(s => s.name === selCmpt.name)[0];\n    let update = namedSg.update;\n    if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n      namedSg.update = `{${bound.map(proj => `${stringValue(proj.field)}: ${proj.signals.data}`).join(', ')}}`;\n    } else {\n      for (const proj of bound) {\n        const mapping = `${stringValue(proj.field)}: ${proj.signals.data}`;\n        if (update.indexOf(mapping) < 0) {\n          update = `${update.substring(0, update.length - 1)}, ${mapping}}`;\n        }\n      }\n      namedSg.update = update;\n    }\n\n    return signals.concat(bound.map(proj => ({name: proj.signals.data})));\n  },\n\n  signals: (model, selCmpt, signals) => {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      for (const proj of selCmpt.scales) {\n        const signal: any = signals.filter(s => s.name === proj.signals.data)[0];\n        signal.push = 'outer';\n        delete signal.value;\n        delete signal.update;\n      }\n    }\n\n    return signals;\n  }\n};\n\nexport default scaleBindings;\n\nexport function domain(model: UnitModel, channel: Channel) {\n  const scale = stringValue(model.scaleName(channel));\n  return `domain(${scale})`;\n}\n\nfunction isTopLevelLayer(model: Model): boolean {\n  return model.parent && isLayerModel(model.parent) && (!model.parent.parent ?? isTopLevelLayer(model.parent.parent));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}