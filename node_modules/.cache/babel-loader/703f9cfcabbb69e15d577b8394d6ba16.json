{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst preact_1 = require(\"preact\");\n\nconst glamor_1 = require(\"glamor\");\n\nconst surface_1 = require(\"./surface\");\n\nconst tabs_1 = require(\"./tabs\");\n/**\n * The Visor is a component that displays and manages 'Tabs' and 'Surfaces'.\n *\n * It is meant to exist as a singleton component on a given page and is thus\n * accessed by a visor() function that exposes a single instance of this\n * component via an imperative API (i.e. its implementation as a (p)react\n * component is an internal implementation detail.\n *\n * Following that, and somewhat unlike a typical react component, it does allow\n * for imperative calls to that instance to modify internal state. Any state\n * that needs to be serialized or persisted should be lifted to props.\n */\n\n\nclass VisorComponent extends preact_1.Component {\n  /**\n   * Helper function to render the component to the DOM.\n   *\n   * Note that although the visor has a parent element, it rendered via absolute\n   * positioning and is thus taken out of regular document flow.\n   *\n   * @param parent A DOM element\n   * @param replaceNode The element that re-rendering this component would\n   *                    replace. Usually null initially and will be returned by\n   *                    this function after the first render.\n   * @param props Initial visor props\n   */\n  static render(parent, replaceNode, props) {\n    return preact_1.render(preact_1.h(VisorComponent, Object.assign({}, props)), parent, replaceNode);\n  }\n\n  constructor(props) {\n    super(props);\n    this.surfaces = new Map();\n    const startOpen = props.startOpen == null ? true : props.startOpen;\n    this.state = {\n      isOpen: startOpen,\n      isFullscreen: false,\n      activeTab: null,\n      tabs: new Set()\n    };\n    this.keyHandler = this.keyHandler.bind(this);\n  } // These public methods are exposed via an imperative interface\n\n\n  close() {\n    this.setState({\n      isOpen: false\n    });\n  }\n\n  open() {\n    this.setState({\n      isOpen: true\n    });\n  }\n\n  toggle() {\n    this.setState({\n      isOpen: !this.state.isOpen\n    });\n  }\n\n  toggleFullScreen() {\n    this.setState({\n      isFullscreen: !this.state.isFullscreen\n    });\n  }\n\n  isOpen() {\n    return this.state.isOpen;\n  }\n\n  isFullscreen() {\n    return this.state.isFullscreen;\n  }\n\n  getSurface(label, tab) {\n    const surfaceId = this.surfaceId(label, tab);\n    let surface;\n\n    if (this.surfaces.has(surfaceId)) {\n      surface = this.surfaces.get(surfaceId);\n    } else {\n      throw Error(`Surface not found with id: ${surfaceId}`);\n    }\n\n    return {\n      container: surface.container,\n      label: surface.label,\n      drawArea: surface.drawArea\n    };\n  }\n\n  bindKeys() {\n    document.addEventListener('keydown', this.keyHandler, false);\n  }\n\n  unbindKeys() {\n    document.removeEventListener('keydown', this.keyHandler);\n  }\n\n  surfaceId(label, tab) {\n    return label + tab;\n  }\n\n  setTabs(surfaceList) {\n    // Check if we have new tabs\n    const nextTabs = surfaceList.map(s => s.tab);\n    const tabs = this.state.tabs;\n    let newActiveTab;\n\n    for (const tab of nextTabs) {\n      if (!tabs.has(tab)) {\n        tabs.add(tab);\n        newActiveTab = tab;\n      }\n    }\n\n    if (newActiveTab != null) {\n      this.setState({\n        tabs,\n        activeTab: newActiveTab\n      });\n    }\n  }\n\n  getTabs() {\n    return this.state.tabs;\n  } // Event Handlers\n\n\n  registerSurface(name, tab, surface) {\n    const surfaceId = this.surfaceId(name, tab);\n    this.surfaces.set(surfaceId, surface);\n  }\n\n  keyHandler(event) {\n    const BACKTICK_KEY = 192;\n\n    if (event.keyCode === BACKTICK_KEY) {\n      if (event.shiftKey) {\n        this.toggleFullScreen();\n      } else {\n        this.toggle();\n      }\n    }\n  }\n\n  setActiveTab(tab) {\n    this.setState({\n      activeTab: tab\n    });\n  } // Lifecycle Methods\n\n\n  componentDidMount() {\n    this.bindKeys();\n  }\n\n  componentWillMount() {\n    this.setTabs(this.props.surfaceList);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setTabs(nextProps.surfaceList);\n  }\n\n  render() {\n    const {\n      isOpen,\n      isFullscreen,\n      activeTab\n    } = this.state;\n    const {\n      surfaceList\n    } = this.props;\n    const tabNames = Array.from(this.getTabs().values());\n    const SMALL_WIDTH = '550px';\n    const LARGE_WIDTH = '90vw';\n    const width = isFullscreen ? LARGE_WIDTH : SMALL_WIDTH;\n    const defaultStyles = glamor_1.css({\n      width,\n      height: '100%',\n      backgroundColor: '#fafafa',\n      boxSizing: 'border-box',\n      padding: '10px',\n      position: 'fixed',\n      top: '0px',\n      // tslint:disable-next-line\n      transition: `right 0.5s cubic-bezier(0.645, 0.045, 0.355, 1), width 0.5s cubic-bezier(0.645, 0.045, 0.355, 1)`,\n      boxShadow: '0 2px 5px rgba(0, 0, 0, 0.12), 0 2px 5px rgba(0, 0, 0, 0.24)',\n      overflow: 'auto',\n      fontFamily: 'sans-serif',\n      fontSize: '14px',\n      zIndex: 1000\n    });\n    const openStyle = glamor_1.css({\n      right: '0'\n    });\n    const closedStyle = glamor_1.css({\n      right: `calc(-${width} - 10px)`\n    });\n    const position = isOpen ? openStyle : closedStyle; // TODO. Add flex wrapping for surfaces\n\n    const surfacesContainerStyle = glamor_1.css({});\n    return preact_1.h(\"div\", {\n      className: `${defaultStyles} ${position} visor`,\n      \"data-isopen\": isOpen,\n      \"data-isfullscreen\": isFullscreen\n    }, preact_1.h(VisorControls, {\n      fullScreenHandler: this.toggleFullScreen.bind(this),\n      closeHandler: this.close.bind(this),\n      isFullScreen: isFullscreen\n    }), preact_1.h(tabs_1.Tabs, {\n      tabNames: tabNames,\n      activeTab: activeTab,\n      handleClick: this.setActiveTab.bind(this)\n    }), preact_1.h(\"div\", {\n      className: `${surfacesContainerStyle} visor-surfaces`\n    }, surfaceList.map(surfaceInfo => preact_1.h(surface_1.SurfaceComponent, {\n      key: surfaceInfo.name + surfaceInfo.tab,\n      name: surfaceInfo.name,\n      tab: surfaceInfo.tab,\n      styles: surfaceInfo.styles,\n      registerSurface: this.registerSurface.bind(this),\n      visible: activeTab === surfaceInfo.tab\n    }))));\n  }\n\n}\n\nexports.VisorComponent = VisorComponent;\n\nfunction VisorControls(props) {\n  const {\n    isFullScreen,\n    fullScreenHandler,\n    closeHandler\n  } = props;\n  const toolBarStyle = glamor_1.css({\n    display: 'flex',\n    backgroundColor: 'white',\n    border: '1px solid white',\n    padding: '6px',\n    paddingTop: '10px',\n    marginBottom: '10px',\n    borderRadius: '6px',\n    marginTop: '-16px'\n  });\n  const controlsButtonClass = glamor_1.css({\n    fontSize: '.875rem',\n    borderRadius: '.25rem',\n    paddingLeft: '1rem',\n    paddingRight: '1rem',\n    paddingTop: '.5rem',\n    paddingBottom: '.5rem',\n    textDecoration: 'none',\n    transition: 'color .15s ease-in',\n    color: '#111'\n  });\n  const floatRight = glamor_1.css({\n    marginLeft: 'auto'\n  });\n  return preact_1.h(\"div\", {\n    className: `${toolBarStyle} visor-controls`\n  }, preact_1.h(\"button\", {\n    className: `${controlsButtonClass}`,\n    onClick: fullScreenHandler\n  }, isFullScreen ? 'Minimize' : 'Maximize'), preact_1.h(\"button\", {\n    className: `${controlsButtonClass} ${floatRight}`,\n    onClick: closeHandler\n  }, \"Hide\"));\n}","map":{"version":3,"sources":["../../src/components/visor.tsx"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { h, Component, render } from 'preact';\nimport { css } from 'glamor';\n\nimport { SurfaceComponent } from './surface';\nimport { Tabs } from './tabs';\n\nimport { SurfaceInfoStrict } from '../types';\n\ninterface VisorProps {\n  // An ordered list of surfaces to render. These are specified by SurfaceInfo\n  // objects that allow configuration of the surface. The actual surface\n  // instance is managed by the visor.\n  surfaceList: SurfaceInfoStrict[];\n  // Whether to inialize the visor to the open or closed state. Optional.\n  startOpen?: boolean;\n  // A ref handler\n  ref?: (r: VisorComponent) => void;\n}\n\ninterface VisorState {\n  isOpen: boolean;\n  isFullscreen: boolean;\n  activeTab: string | null;\n  tabs: Set<string>;\n}\n\n/**\n * The Visor is a component that displays and manages 'Tabs' and 'Surfaces'.\n *\n * It is meant to exist as a singleton component on a given page and is thus\n * accessed by a visor() function that exposes a single instance of this\n * component via an imperative API (i.e. its implementation as a (p)react\n * component is an internal implementation detail.\n *\n * Following that, and somewhat unlike a typical react component, it does allow\n * for imperative calls to that instance to modify internal state. Any state\n * that needs to be serialized or persisted should be lifted to props.\n */\nexport class VisorComponent extends Component<VisorProps, VisorState> {\n\n  /**\n   * Helper function to render the component to the DOM.\n   *\n   * Note that although the visor has a parent element, it rendered via absolute\n   * positioning and is thus taken out of regular document flow.\n   *\n   * @param parent A DOM element\n   * @param replaceNode The element that re-rendering this component would\n   *                    replace. Usually null initially and will be returned by\n   *                    this function after the first render.\n   * @param props Initial visor props\n   */\n  static render(\n    parent: Element,\n    replaceNode: Element,\n    props: VisorProps): Element {\n    return render(\n      <VisorComponent\n        {...props}\n      />,\n      parent,\n      replaceNode\n    );\n  }\n\n  // Lookup dictionary for Surfaces\n  private surfaces: Map<string, SurfaceComponent>;\n\n  constructor(props: VisorProps) {\n    super(props);\n    this.surfaces = new Map<string, SurfaceComponent>();\n    const startOpen = props.startOpen == null ? true : props.startOpen;\n\n    this.state = {\n      isOpen: startOpen,\n      isFullscreen: false,\n      activeTab: null,\n      tabs: new Set<string>()\n    };\n\n    this.keyHandler = this.keyHandler.bind(this);\n  }\n\n  // These public methods are exposed via an imperative interface\n\n  close() {\n    this.setState({ isOpen: false });\n  }\n\n  open() {\n    this.setState({ isOpen: true });\n  }\n\n  toggle() {\n    this.setState({ isOpen: !this.state.isOpen });\n  }\n\n  toggleFullScreen() {\n    this.setState({ isFullscreen: !this.state.isFullscreen });\n  }\n\n  isOpen(): boolean {\n    return this.state.isOpen;\n  }\n\n  isFullscreen(): boolean {\n    return this.state.isFullscreen;\n  }\n\n  getSurface(label: string, tab: string) {\n    const surfaceId = this.surfaceId(label, tab);\n    let surface: SurfaceComponent;\n\n    if (this.surfaces.has(surfaceId)) {\n      surface = this.surfaces.get(surfaceId);\n    } else {\n      throw Error(`Surface not found with id: ${surfaceId}`);\n    }\n\n    return {\n      container: surface.container,\n      label: surface.label,\n      drawArea: surface.drawArea,\n    };\n  }\n\n  bindKeys() {\n    document.addEventListener('keydown', this.keyHandler, false);\n  }\n\n  unbindKeys() {\n    document.removeEventListener('keydown', this.keyHandler);\n  }\n\n  private surfaceId(label: string, tab: string): string {\n    return label + tab;\n  }\n\n  private setTabs(surfaceList: SurfaceInfoStrict[]) {\n    // Check if we have new tabs\n    const nextTabs = surfaceList.map(s => s.tab);\n    const tabs = this.state.tabs;\n    let newActiveTab;\n    for (const tab of nextTabs) {\n      if (!tabs.has(tab)) {\n        tabs.add(tab);\n        newActiveTab = tab;\n      }\n    }\n\n    if (newActiveTab != null) {\n      this.setState({\n        tabs,\n        activeTab: newActiveTab,\n      });\n    }\n  }\n\n  private getTabs(): Set<string> {\n    return this.state.tabs;\n  }\n\n  // Event Handlers\n\n  private registerSurface(name: string, tab: string,\n    surface: SurfaceComponent) {\n    const surfaceId = this.surfaceId(name, tab);\n    this.surfaces.set(surfaceId, surface);\n  }\n\n  private keyHandler(event: KeyboardEvent) {\n    const BACKTICK_KEY = 192;\n\n    if (event.keyCode === BACKTICK_KEY) {\n      if (event.shiftKey) {\n        this.toggleFullScreen();\n      } else {\n        this.toggle();\n      }\n    }\n  }\n\n  private setActiveTab(tab: string) {\n    this.setState({ activeTab: tab });\n  }\n\n  // Lifecycle Methods\n\n  componentDidMount() {\n    this.bindKeys();\n  }\n\n  componentWillMount() {\n    this.setTabs(this.props.surfaceList);\n  }\n\n  componentWillReceiveProps(nextProps: VisorProps) {\n    this.setTabs(nextProps.surfaceList);\n  }\n\n  render() {\n    const { isOpen, isFullscreen, activeTab } = this.state;\n    const { surfaceList } = this.props;\n    const tabNames = Array.from(this.getTabs().values());\n\n    const SMALL_WIDTH = '550px';\n    const LARGE_WIDTH = '90vw';\n\n    const width = isFullscreen ? LARGE_WIDTH : SMALL_WIDTH;\n\n    const defaultStyles = css({\n      width,\n      height: '100%',\n      backgroundColor: '#fafafa',\n      boxSizing: 'border-box',\n      padding: '10px',\n      position: 'fixed',\n      top: '0px',\n      // tslint:disable-next-line\n      transition: `right 0.5s cubic-bezier(0.645, 0.045, 0.355, 1), width 0.5s cubic-bezier(0.645, 0.045, 0.355, 1)`,\n      boxShadow: '0 2px 5px rgba(0, 0, 0, 0.12), 0 2px 5px rgba(0, 0, 0, 0.24)',\n      overflow: 'auto',\n      fontFamily: 'sans-serif',\n      fontSize: '14px',\n      zIndex: 1000,\n    });\n\n    const openStyle = css({ right: '0' });\n\n    const closedStyle = css({ right: `calc(-${width} - 10px)` });\n    const position = isOpen ? openStyle : closedStyle;\n\n    // TODO. Add flex wrapping for surfaces\n    const surfacesContainerStyle = css({});\n\n    return (\n      <div\n        className={`${defaultStyles} ${position} visor`}\n        data-isopen={isOpen}\n        data-isfullscreen={isFullscreen}\n      >\n        {/* Controls  */}\n        <VisorControls\n          fullScreenHandler={this.toggleFullScreen.bind(this)}\n          closeHandler={this.close.bind(this)}\n          isFullScreen={isFullscreen}\n        />\n        {/* Tabs */}\n        <Tabs\n          tabNames={tabNames}\n          activeTab={activeTab}\n          handleClick={this.setActiveTab.bind(this)}\n        />\n\n        {/* Surfaces */}\n        {/* Note that we 'render' all surfaces so they can be added\n            to the DOM regardless of whether they are currently visible */}\n        <div className={`${surfacesContainerStyle} visor-surfaces`} >\n          {\n            surfaceList.map((surfaceInfo) => (\n              <SurfaceComponent\n                key={surfaceInfo.name + surfaceInfo.tab}\n                name={surfaceInfo.name}\n                tab={surfaceInfo.tab}\n                styles={surfaceInfo.styles}\n                registerSurface={this.registerSurface.bind(this)}\n                visible={activeTab === surfaceInfo.tab}\n              />\n            ))\n          }\n        </div>\n\n      </div >\n    );\n  }\n}\n\n//\n// Helper Components\n//\n\ninterface VisorControlProps {\n  fullScreenHandler: () => void;\n  closeHandler: () => void;\n  isFullScreen: boolean;\n}\n\nfunction VisorControls(props: VisorControlProps) {\n  const { isFullScreen, fullScreenHandler, closeHandler } = props;\n\n  const toolBarStyle = css({\n    display: 'flex',\n    backgroundColor: 'white',\n    border: '1px solid white',\n    padding: '6px',\n    paddingTop: '10px',\n    marginBottom: '10px',\n    borderRadius: '6px',\n    marginTop: '-16px'\n  });\n\n  const controlsButtonClass = css({\n    fontSize: '.875rem',\n    borderRadius: '.25rem',\n    paddingLeft: '1rem',\n    paddingRight: '1rem',\n    paddingTop: '.5rem',\n    paddingBottom: '.5rem',\n    textDecoration: 'none',\n    transition: 'color .15s ease-in',\n    color: '#111',\n  });\n\n  const floatRight = css({\n    marginLeft: 'auto',\n  });\n\n  return (\n    <div className={`${toolBarStyle} visor-controls`}>\n      <button className={`${controlsButtonClass}`} onClick={fullScreenHandler}>\n        {isFullScreen ? 'Minimize' : 'Maximize'}\n      </button>\n\n      <button\n        className={`${controlsButtonClass} ${floatRight}`}\n        onClick={closeHandler}\n      >\n        Hide\n      </button>\n    </div>\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}