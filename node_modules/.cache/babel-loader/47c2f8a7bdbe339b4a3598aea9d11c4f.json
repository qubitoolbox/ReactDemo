{"ast":null,"code":"import { array } from 'vega-util';\nimport { isConditionalSelection } from '../../../channeldef';\nimport { expression } from '../../predicate';\nimport { parseSelectionPredicate } from '../../selection/parse';\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\n\nexport function wrapCondition(model, channelDef, vgChannel, refFn) {\n  const condition = channelDef && channelDef.condition;\n  const valueRef = refFn(channelDef);\n\n  if (condition) {\n    const conditions = array(condition);\n    const vgConditions = conditions.map(c => {\n      const conditionValueRef = refFn(c);\n      const test = isConditionalSelection(c) ? parseSelectionPredicate(model, c.selection) : expression(model, c.test);\n      return Object.assign({\n        test\n      }, conditionValueRef);\n    });\n    return {\n      [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n    };\n  } else {\n    return valueRef !== undefined ? {\n      [vgChannel]: valueRef\n    } : {};\n  }\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/conditional.ts"],"names":[],"mappings":"AAAA,SAAQ,KAAR,QAAoB,WAApB;AACA,SAIE,sBAJF,QAOO,qBAPP;AASA,SAAQ,UAAR,QAAyB,iBAAzB;AACA,SAAQ,uBAAR,QAAsC,uBAAtC;AAGA;;;;;AAIA,OAAM,SAAU,aAAV,CACJ,KADI,EAEJ,UAFI,EAGJ,SAHI,EAIJ,KAJI,EAI0E;AAE9E,QAAM,SAAS,GAAG,UAAU,IAAI,UAAU,CAAC,SAA3C;AACA,QAAM,QAAQ,GAAG,KAAK,CAAC,UAAD,CAAtB;;AACA,MAAI,SAAJ,EAAe;AACb,UAAM,UAAU,GAAG,KAAK,CAAC,SAAD,CAAxB;AACA,UAAM,YAAY,GAAG,UAAU,CAAC,GAAX,CAAe,CAAC,IAAG;AACtC,YAAM,iBAAiB,GAAG,KAAK,CAAC,CAAD,CAA/B;AACA,YAAM,IAAI,GAAG,sBAAsB,CAAC,CAAD,CAAtB,GAA4B,uBAAuB,CAAC,KAAD,EAAQ,CAAC,CAAC,SAAV,CAAnD,GAA0E,UAAU,CAAC,KAAD,EAAQ,CAAC,CAAC,IAAV,CAAjG;AACA,aAAA,MAAA,CAAA,MAAA,CAAA;AACE,QAAA;AADF,OAAA,EAEK,iBAFL,CAAA;AAID,KAPoB,CAArB;AAQA,WAAO;AACL,OAAC,SAAD,GAAa,CAAC,GAAG,YAAJ,EAAkB,IAAI,QAAQ,KAAK,SAAb,GAAyB,CAAC,QAAD,CAAzB,GAAsC,EAA1C,CAAlB;AADR,KAAP;AAGD,GAbD,MAaO;AACL,WAAO,QAAQ,KAAK,SAAb,GAAyB;AAAC,OAAC,SAAD,GAAa;AAAd,KAAzB,GAAmD,EAA1D;AACD;AACF","sourcesContent":["import {array} from 'vega-util';\nimport {\n  ChannelDef,\n  Conditional,\n  FieldDef,\n  isConditionalSelection,\n  ValueDef,\n  ValueOrGradientOrText\n} from '../../../channeldef';\nimport {VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {expression} from '../../predicate';\nimport {parseSelectionPredicate} from '../../selection/parse';\nimport {UnitModel} from '../../unit';\n\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition<FD extends FieldDef<any>, V extends ValueOrGradientOrText>(\n  model: UnitModel,\n  channelDef: ChannelDef<FD, V>,\n  vgChannel: string,\n  refFn: (cDef: ChannelDef<FD, V> | Conditional<ValueDef<V> | FD>) => VgValueRef\n): VgEncodeEntry {\n  const condition = channelDef && channelDef.condition;\n  const valueRef = refFn(channelDef);\n  if (condition) {\n    const conditions = array(condition);\n    const vgConditions = conditions.map(c => {\n      const conditionValueRef = refFn(c);\n      const test = isConditionalSelection(c) ? parseSelectionPredicate(model, c.selection) : expression(model, c.test);\n      return {\n        test,\n        ...conditionValueRef\n      };\n    });\n    return {\n      [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n    };\n  } else {\n    return valueRef !== undefined ? {[vgChannel]: valueRef} : {};\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}