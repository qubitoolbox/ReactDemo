{"ast":null,"code":"import { hasDiscreteDomain } from '../../scale';\nimport { getFirstDefined } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { isFacetModel } from '../model';\nimport { getViewConfigContinuousSize } from '../../config';\nexport function assembleLayoutSignals(model) {\n  return [...sizeSignals(model, 'width'), ...sizeSignals(model, 'height')];\n}\nexport function sizeSignals(model, sizeType) {\n  const channel = sizeType === 'width' ? 'x' : 'y';\n  const size = model.component.layoutSize.get(sizeType);\n\n  if (!size || size === 'merged') {\n    return [];\n  } // Read size signal name from name map, just in case it is the top-level size signal that got renamed.\n\n\n  const name = model.getSizeSignalRef(sizeType).signal;\n\n  if (size === 'step') {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const type = scaleComponent.get('type');\n      const range = scaleComponent.get('range');\n\n      if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n        const scaleName = model.scaleName(channel);\n\n        if (isFacetModel(model.parent)) {\n          // If parent is facet and this is an independent scale, return only signal signal\n          // as the width/height will be calculated using the cardinality from\n          // facet's aggregate rather than reading from scale domain\n          const parentResolve = model.parent.component.resolve;\n\n          if (parentResolve.scale[channel] === 'independent') {\n            return [stepSignal(scaleName, range)];\n          }\n        }\n\n        return [stepSignal(scaleName, range), {\n          name,\n          update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)\n        }];\n      }\n    }\n    /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n\n\n    throw new Error('layout size is step although width/height is not step.');\n  } else if (size == 'container') {\n    const isWidth = name.endsWith('width');\n    const expr = isWidth ? 'containerSize()[0]' : 'containerSize()[1]';\n    const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? 'width' : 'height');\n    const safeExpr = `isFinite(${expr}) ? ${expr} : ${defaultValue}`;\n    return [{\n      name,\n      init: safeExpr,\n      on: [{\n        update: safeExpr,\n        events: 'window:resize'\n      }]\n    }];\n  } else {\n    return [{\n      name,\n      value: size\n    }];\n  }\n}\n\nfunction stepSignal(scaleName, range) {\n  return {\n    name: scaleName + '_step',\n    value: range.step\n  };\n}\n\nexport function sizeExpr(scaleName, scaleComponent, cardinality) {\n  const type = scaleComponent.get('type');\n  const padding = scaleComponent.get('padding');\n  const paddingOuter = getFirstDefined(scaleComponent.get('paddingOuter'), padding);\n  let paddingInner = scaleComponent.get('paddingInner');\n  paddingInner = type === 'band' ? // only band has real paddingInner\n  paddingInner !== undefined ? paddingInner : padding : // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n  // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n  1;\n  return `bandspace(${cardinality}, ${paddingInner}, ${paddingOuter}) * ${scaleName}_step`;\n}","map":{"version":3,"sources":["../../../../src/compile/layoutsize/assemble.ts"],"names":[],"mappings":"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","sourcesContent":["import {NewSignal, InitSignal} from 'vega';\nimport {hasDiscreteDomain} from '../../scale';\nimport {getFirstDefined} from '../../util';\nimport {isVgRangeStep, VgRangeStep} from '../../vega.schema';\nimport {isFacetModel, Model} from '../model';\nimport {ScaleComponent} from '../scale/component';\nimport {getViewConfigContinuousSize} from '../../config';\n\nexport function assembleLayoutSignals(model: Model): NewSignal[] {\n  return [...sizeSignals(model, 'width'), ...sizeSignals(model, 'height')];\n}\n\nexport function sizeSignals(model: Model, sizeType: 'width' | 'height'): (NewSignal | InitSignal)[] {\n  const channel = sizeType === 'width' ? 'x' : 'y';\n  const size = model.component.layoutSize.get(sizeType);\n  if (!size || size === 'merged') {\n    return [];\n  }\n\n  // Read size signal name from name map, just in case it is the top-level size signal that got renamed.\n  const name = model.getSizeSignalRef(sizeType).signal;\n\n  if (size === 'step') {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const type = scaleComponent.get('type');\n      const range = scaleComponent.get('range');\n\n      if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n        const scaleName = model.scaleName(channel);\n\n        if (isFacetModel(model.parent)) {\n          // If parent is facet and this is an independent scale, return only signal signal\n          // as the width/height will be calculated using the cardinality from\n          // facet's aggregate rather than reading from scale domain\n          const parentResolve = model.parent.component.resolve;\n          if (parentResolve.scale[channel] === 'independent') {\n            return [stepSignal(scaleName, range)];\n          }\n        }\n\n        return [\n          stepSignal(scaleName, range),\n          {\n            name,\n            update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)\n          }\n        ];\n      }\n    }\n    /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n    throw new Error('layout size is step although width/height is not step.');\n  } else if (size == 'container') {\n    const isWidth = name.endsWith('width');\n    const expr = isWidth ? 'containerSize()[0]' : 'containerSize()[1]';\n    const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? 'width' : 'height');\n    const safeExpr = `isFinite(${expr}) ? ${expr} : ${defaultValue}`;\n    return [{name, init: safeExpr, on: [{update: safeExpr, events: 'window:resize'}]}];\n  } else {\n    return [\n      {\n        name,\n        value: size\n      }\n    ];\n  }\n}\n\nfunction stepSignal(scaleName: string, range: VgRangeStep): NewSignal {\n  return {\n    name: scaleName + '_step',\n    value: range.step\n  };\n}\n\nexport function sizeExpr(scaleName: string, scaleComponent: ScaleComponent, cardinality: string) {\n  const type = scaleComponent.get('type');\n  const padding = scaleComponent.get('padding');\n  const paddingOuter = getFirstDefined(scaleComponent.get('paddingOuter'), padding);\n\n  let paddingInner = scaleComponent.get('paddingInner');\n  paddingInner =\n    type === 'band'\n      ? // only band has real paddingInner\n        paddingInner !== undefined\n        ? paddingInner\n        : padding\n      : // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n        // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n        1;\n  return `bandspace(${cardinality}, ${paddingInner}, ${paddingOuter}) * ${scaleName}_step`;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}