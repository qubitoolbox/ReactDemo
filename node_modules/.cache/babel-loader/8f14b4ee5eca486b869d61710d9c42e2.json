{"ast":null,"code":"import { getSizeType } from '../channel';\nimport { stringify, replaceAll } from '../util';\n/**\n * Collection of all Vega-Lite Error Messages\n */\n\nexport function invalidSpec(spec) {\n  return `Invalid specification ${JSON.stringify(spec)}. Make sure the specification includes at least one of the following properties: \"mark\", \"layer\", \"facet\", \"hconcat\", \"vconcat\", \"concat\", or \"repeat\".`;\n} // FIT\n\nexport const FIT_NON_SINGLE = 'Autosize \"fit\" only works for single views and layered views.';\nexport function containerSizeNonSingle(name) {\n  const uName = name == 'width' ? 'Width' : 'Height';\n  return `${uName} \"container\" only works for single views and layered views.`;\n}\nexport function containerSizeNotCompatibleWithAutosize(name) {\n  const uName = name == 'width' ? 'Width' : 'Height';\n  return `${uName} \"container\" only works well with autosize \"fit\" or \"fit-x\".`;\n}\nexport function droppingFit(channel) {\n  return channel ? `Dropping \"fit-${channel}\" because spec has discrete ${getSizeType(channel)}.` : `Dropping \"fit\" because spec has discrete size.`;\n} // SELECTION\n\nexport function cannotProjectOnChannelWithoutField(channel) {\n  return `Cannot project a selection on encoding channel \"${channel}\", which has no field.`;\n}\nexport function cannotProjectAggregate(channel, aggregate) {\n  return `Cannot project a selection on encoding channel \"${channel}\" as it uses an aggregate function (\"${aggregate}\").`;\n}\nexport function nearestNotSupportForContinuous(mark) {\n  return `The \"nearest\" transform is not supported for ${mark} marks.`;\n}\nexport function selectionNotSupported(mark) {\n  return `Selection not supported for ${mark} yet.`;\n}\nexport function selectionNotFound(name) {\n  return `Cannot find a selection named \"${name}\".`;\n}\nexport const SCALE_BINDINGS_CONTINUOUS = 'Scale bindings are currently only supported for scales with unbinned, continuous domains.';\nexport const LEGEND_BINDINGS_PROJECT_LENGTH = 'Legend bindings are only supported for selections over an individual field or encoding channel.';\nexport function noSameUnitLookup(name) {\n  return `Cannot define and lookup the \"${name}\" selection in the same view. ` + `Try moving the lookup into a second, layered view?`;\n} // REPEAT\n\nexport function noSuchRepeatedValue(field) {\n  return `Unknown repeated value \"${field}\".`;\n}\nexport function columnsNotSupportByRowCol(type) {\n  return `The \"columns\" property cannot be used when \"${type}\" has nested row/column.`;\n} // CONCAT\n\nexport const CONCAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in concatenated views yet (https://github.com/vega/vega-lite/issues/2415).'; // REPEAT\n\nexport const REPEAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in repeated views yet (https://github.com/vega/vega-lite/issues/2415).'; // DATA\n\nexport function unrecognizedParse(p) {\n  return `Unrecognized parse \"${p}\".`;\n}\nexport function differentParse(field, local, ancestor) {\n  return `An ancestor parsed field \"${field}\" as ${ancestor} but a child wants to parse the field as ${local}.`;\n} // TRANSFORMS\n\nexport function invalidTransformIgnored(transform) {\n  return `Ignoring an invalid transform: ${stringify(transform)}.`;\n}\nexport const NO_FIELDS_NEEDS_AS = 'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.'; // ENCODING & FACET\n\nexport function encodingOverridden(channels) {\n  return `Layer's shared ${channels.join(',')} channel ${channels.length === 1 ? 'is' : 'are'} overriden.`;\n}\nexport function projectionOverridden(opt) {\n  const {\n    parentProjection,\n    projection\n  } = opt;\n  return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection)}.`;\n}\nexport function primitiveChannelDef(channel, type, value) {\n  return `Channel ${channel} is a ${type}. Converted to {value: ${stringify(value)}}.`;\n}\nexport function invalidFieldType(type) {\n  return `Invalid field type \"${type}\".`;\n}\nexport function nonZeroScaleUsedWithLengthMark(mark, channel, opt) {\n  const scaleText = opt.scaleType ? `${opt.scaleType} scale` : opt.zeroFalse ? 'scale with zero=false' : 'scale with custom domain that excludes zero';\n  return `A ${scaleText} is used to encode ${mark}'s ${channel}. This can be misleading as the ${channel === 'x' ? 'width' : 'height'} of the ${mark} can be arbitrary based on the scale domain. You may want to use point mark instead.`;\n}\nexport function invalidFieldTypeForCountAggregate(type, aggregate) {\n  return `Invalid field type \"${type}\" for aggregate: \"${aggregate}\", using \"quantitative\" instead.`;\n}\nexport function invalidAggregate(aggregate) {\n  return `Invalid aggregation operator \"${aggregate}\".`;\n}\nexport function missingFieldType(channel, newType) {\n  return `Missing type for channel \"${channel}\", using \"${newType}\" instead.`;\n}\nexport function droppingColor(type, opt) {\n  const {\n    fill,\n    stroke\n  } = opt;\n  return `Dropping color ${type} as the plot also has ${fill && stroke ? 'fill and stroke' : fill ? 'fill' : 'stroke'}.`;\n}\nexport function emptyFieldDef(fieldDef, channel) {\n  return `Dropping ${stringify(fieldDef)} from channel \"${channel}\" since it does not contain data field or value.`;\n}\nexport function latLongDeprecated(channel, type, newChannel) {\n  return `${channel}-encoding with type ${type} is deprecated. Replacing with ${newChannel}-encoding.`;\n}\nexport const LINE_WITH_VARYING_SIZE = 'Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.';\nexport function incompatibleChannel(channel, markOrFacet, when) {\n  return `${channel} dropped as it is incompatible with \"${markOrFacet}\"${when ? ` when ${when}` : ''}.`;\n}\nexport function invalidEncodingChannel(channel) {\n  return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;\n}\nexport function facetChannelShouldBeDiscrete(channel) {\n  return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n}\nexport function facetChannelDropped(channels) {\n  return `Facet encoding dropped as ${channels.join(' and ')} ${channels.length > 1 ? 'are' : 'is'} also specified.`;\n}\nexport function discreteChannelCannotEncode(channel, type) {\n  return `Using discrete channel \"${channel}\" to encode \"${type}\" field can be misleading as it does not encode ${type === 'ordinal' ? 'order' : 'magnitude'}.`;\n} // Mark\n\nexport function lineWithRange(hasX2, hasY2) {\n  const channels = hasX2 && hasY2 ? 'x2 and y2' : hasX2 ? 'x2' : 'y2';\n  return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;\n}\nexport function orientOverridden(original, actual) {\n  return `Specified orient \"${original}\" overridden with \"${actual}\".`;\n} // SCALE\n\nexport const CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'Custom domain scale cannot be unioned with default field-based domain.';\nexport const RANGE_STEP_DEPRECATED = `Scale's \"rangeStep\" is deprecated and will be removed in Vega-Lite 5.0. Please use \"width\"/\"height\": {\"step\": ...} instead. See https://vega.github.io/vega-lite/docs/size.html.`;\nexport function cannotUseScalePropertyWithNonColor(prop) {\n  return `Cannot use the scale property \"${prop}\" with non-color channel.`;\n}\nexport function unaggregateDomainHasNoEffectForRawField(fieldDef) {\n  return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;\n}\nexport function unaggregateDomainWithNonSharedDomainOp(aggregate) {\n  return `Unaggregated domain not applicable for \"${aggregate}\" since it produces values outside the origin domain of the source data.`;\n}\nexport function unaggregatedDomainWithLogScale(fieldDef) {\n  return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;\n}\nexport function cannotApplySizeToNonOrientedMark(mark) {\n  return `Cannot apply size to non-oriented mark \"${mark}\".`;\n}\nexport function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {\n  return `Channel \"${channel}\" does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\nexport function scaleTypeNotWorkWithFieldDef(scaleType, defaultScaleType) {\n  return `FieldDef does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\nexport function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {\n  return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n}\nexport function scaleTypeNotWorkWithMark(mark, scaleType) {\n  return `Scale type \"${scaleType}\" does not work with mark \"${mark}\".`;\n}\nexport function stepDropped(channel) {\n  return `The step for \"${channel}\" is dropped because the ${channel === 'width' ? 'x' : 'y'} is continuous.`;\n}\nexport function mergeConflictingProperty(property, propertyOf, v1, v2) {\n  return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`;\n}\nexport function mergeConflictingDomainProperty(property, propertyOf, v1, v2) {\n  return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(v2)}). Using the union of the two domains.`;\n}\nexport function independentScaleMeansIndependentGuide(channel) {\n  return `Setting the scale to be independent for \"${channel}\" means we also have to set the guide (axis or legend) to be independent.`;\n}\nexport function domainSortDropped(sort) {\n  return `Dropping sort property ${stringify(sort)} as unioned domains only support boolean or op \"count\", \"min\", and \"max\".`;\n}\nexport const UNABLE_TO_MERGE_DOMAINS = 'Unable to merge domains.';\nexport const MORE_THAN_ONE_SORT = 'Domains that should be unioned has conflicting sort properties. Sort will be set to true.'; // AXIS\n\nexport const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.'; // STACK\n\nexport function cannotStackRangedMark(channel) {\n  return `Cannot stack \"${channel}\" if there is already \"${channel}2\".`;\n}\nexport function cannotStackNonLinearScale(scaleType) {\n  return `Cannot stack non-linear scale (${scaleType}).`;\n}\nexport function stackNonSummativeAggregate(aggregate) {\n  return `Stacking is applied even though the aggregate function is non-summative (\"${aggregate}\").`;\n} // TIMEUNIT\n\nexport function invalidTimeUnit(unitName, value) {\n  return `Invalid ${unitName}: ${stringify(value)}.`;\n}\nexport function dayReplacedWithDate(fullTimeUnit) {\n  return `Time unit \"${fullTimeUnit}\" is not supported. We are replacing it with ${replaceAll(fullTimeUnit, 'day', 'date')}.`;\n}\nexport function droppedDay(d) {\n  return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;\n}\nexport function errorBarCenterAndExtentAreNotNeeded(center, extent) {\n  return `${extent ? 'extent ' : ''}${extent && center ? 'and ' : ''}${center ? 'center ' : ''}${extent && center ? 'are ' : 'is '}not needed when data are aggregated.`;\n}\nexport function errorBarCenterIsUsedWithWrongExtent(center, extent, mark) {\n  return `${center} is not usually used with ${extent} for ${mark}.`;\n}\nexport function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {\n  return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;\n}\nexport function errorBarCenterIsNotNeeded(extent, mark) {\n  return `Center is not needed to be specified in ${mark} when extent is ${extent}.`;\n}\nexport function errorBand1DNotSupport(property) {\n  return `1D error band does not support ${property}.`;\n} // CHANNEL\n\nexport function channelRequiredForBinned(channel) {\n  return `Channel ${channel} is required for \"binned\" bin.`;\n}\nexport function domainRequiredForThresholdScale(channel) {\n  return `Domain for ${channel} is required for threshold scale.`;\n}","map":{"version":3,"sources":["../../../src/log/message.ts"],"names":[],"mappings":"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","sourcesContent":["import {AggregateOp} from 'vega';\nimport {Aggregate} from '../aggregate';\nimport {Channel, FacetChannel, GeoPositionChannel, getSizeType, PositionScaleChannel} from '../channel';\nimport {TypedFieldDef, Value, HiddenCompositeAggregate} from '../channeldef';\nimport {SplitParentProperty} from '../compile/split';\nimport {CompositeMark} from '../compositemark';\nimport {ErrorBarCenter, ErrorBarExtent} from '../compositemark/errorbar';\nimport {DateTime, DateTimeExpr} from '../datetime';\nimport {Mark} from '../mark';\nimport {Projection} from '../projection';\nimport {ScaleType} from '../scale';\nimport {GenericSpec} from '../spec';\nimport {Type} from '../type';\nimport {stringify, replaceAll} from '../util';\nimport {VgSortField} from '../vega.schema';\n\n/**\n * Collection of all Vega-Lite Error Messages\n */\n\nexport function invalidSpec(spec: GenericSpec<any, any>) {\n  return `Invalid specification ${JSON.stringify(\n    spec\n  )}. Make sure the specification includes at least one of the following properties: \"mark\", \"layer\", \"facet\", \"hconcat\", \"vconcat\", \"concat\", or \"repeat\".`;\n}\n\n// FIT\nexport const FIT_NON_SINGLE = 'Autosize \"fit\" only works for single views and layered views.';\n\nexport function containerSizeNonSingle(name: 'width' | 'height') {\n  const uName = name == 'width' ? 'Width' : 'Height';\n  return `${uName} \"container\" only works for single views and layered views.`;\n}\n\nexport function containerSizeNotCompatibleWithAutosize(name: 'width' | 'height') {\n  const uName = name == 'width' ? 'Width' : 'Height';\n  return `${uName} \"container\" only works well with autosize \"fit\" or \"fit-x\".`;\n}\n\nexport function droppingFit(channel?: PositionScaleChannel) {\n  return channel\n    ? `Dropping \"fit-${channel}\" because spec has discrete ${getSizeType(channel)}.`\n    : `Dropping \"fit\" because spec has discrete size.`;\n}\n\n// SELECTION\nexport function cannotProjectOnChannelWithoutField(channel: Channel) {\n  return `Cannot project a selection on encoding channel \"${channel}\", which has no field.`;\n}\n\nexport function cannotProjectAggregate(channel: Channel, aggregate: Aggregate | HiddenCompositeAggregate) {\n  return `Cannot project a selection on encoding channel \"${channel}\" as it uses an aggregate function (\"${aggregate}\").`;\n}\n\nexport function nearestNotSupportForContinuous(mark: string) {\n  return `The \"nearest\" transform is not supported for ${mark} marks.`;\n}\n\nexport function selectionNotSupported(mark: CompositeMark) {\n  return `Selection not supported for ${mark} yet.`;\n}\n\nexport function selectionNotFound(name: string) {\n  return `Cannot find a selection named \"${name}\".`;\n}\n\nexport const SCALE_BINDINGS_CONTINUOUS =\n  'Scale bindings are currently only supported for scales with unbinned, continuous domains.';\n\nexport const LEGEND_BINDINGS_PROJECT_LENGTH =\n  'Legend bindings are only supported for selections over an individual field or encoding channel.';\nexport function noSameUnitLookup(name: string) {\n  return (\n    `Cannot define and lookup the \"${name}\" selection in the same view. ` +\n    `Try moving the lookup into a second, layered view?`\n  );\n}\n\n// REPEAT\nexport function noSuchRepeatedValue(field: string) {\n  return `Unknown repeated value \"${field}\".`;\n}\n\nexport function columnsNotSupportByRowCol(type: 'facet' | 'repeat') {\n  return `The \"columns\" property cannot be used when \"${type}\" has nested row/column.`;\n}\n\n// CONCAT\nexport const CONCAT_CANNOT_SHARE_AXIS =\n  'Axes cannot be shared in concatenated views yet (https://github.com/vega/vega-lite/issues/2415).';\n\n// REPEAT\nexport const REPEAT_CANNOT_SHARE_AXIS =\n  'Axes cannot be shared in repeated views yet (https://github.com/vega/vega-lite/issues/2415).';\n\n// DATA\nexport function unrecognizedParse(p: string) {\n  return `Unrecognized parse \"${p}\".`;\n}\n\nexport function differentParse(field: string, local: string, ancestor: string) {\n  return `An ancestor parsed field \"${field}\" as ${ancestor} but a child wants to parse the field as ${local}.`;\n}\n\n// TRANSFORMS\nexport function invalidTransformIgnored(transform: any) {\n  return `Ignoring an invalid transform: ${stringify(transform)}.`;\n}\n\nexport const NO_FIELDS_NEEDS_AS =\n  'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.';\n\n// ENCODING & FACET\n\nexport function encodingOverridden(channels: Channel[]) {\n  return `Layer's shared ${channels.join(',')} channel ${channels.length === 1 ? 'is' : 'are'} overriden.`;\n}\nexport function projectionOverridden(opt: {parentProjection: Projection; projection: Projection}) {\n  const {parentProjection, projection} = opt;\n  return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(\n    projection\n  )}.`;\n}\n\nexport function primitiveChannelDef(\n  channel: Channel,\n  type: 'string' | 'number' | 'boolean',\n  value: Exclude<Value, null>\n) {\n  return `Channel ${channel} is a ${type}. Converted to {value: ${stringify(value)}}.`;\n}\n\nexport function invalidFieldType(type: Type) {\n  return `Invalid field type \"${type}\".`;\n}\n\nexport function nonZeroScaleUsedWithLengthMark(\n  mark: 'bar' | 'area',\n  channel: Channel,\n  opt: {scaleType?: ScaleType; zeroFalse?: boolean}\n) {\n  const scaleText = opt.scaleType\n    ? `${opt.scaleType} scale`\n    : opt.zeroFalse\n    ? 'scale with zero=false'\n    : 'scale with custom domain that excludes zero';\n\n  return `A ${scaleText} is used to encode ${mark}'s ${channel}. This can be misleading as the ${\n    channel === 'x' ? 'width' : 'height'\n  } of the ${mark} can be arbitrary based on the scale domain. You may want to use point mark instead.`;\n}\n\nexport function invalidFieldTypeForCountAggregate(type: Type, aggregate: Aggregate | string) {\n  return `Invalid field type \"${type}\" for aggregate: \"${aggregate}\", using \"quantitative\" instead.`;\n}\n\nexport function invalidAggregate(aggregate: AggregateOp | string) {\n  return `Invalid aggregation operator \"${aggregate}\".`;\n}\n\nexport function missingFieldType(channel: Channel, newType: Type) {\n  return `Missing type for channel \"${channel}\", using \"${newType}\" instead.`;\n}\nexport function droppingColor(type: 'encoding' | 'property', opt: {fill?: boolean; stroke?: boolean}) {\n  const {fill, stroke} = opt;\n  return `Dropping color ${type} as the plot also has ${\n    fill && stroke ? 'fill and stroke' : fill ? 'fill' : 'stroke'\n  }.`;\n}\n\nexport function emptyFieldDef(fieldDef: TypedFieldDef<string>, channel: Channel) {\n  return `Dropping ${stringify(fieldDef)} from channel \"${channel}\" since it does not contain data field or value.`;\n}\nexport function latLongDeprecated(channel: Channel, type: Type, newChannel: GeoPositionChannel) {\n  return `${channel}-encoding with type ${type} is deprecated. Replacing with ${newChannel}-encoding.`;\n}\n\nexport const LINE_WITH_VARYING_SIZE =\n  'Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.';\n\nexport function incompatibleChannel(channel: Channel, markOrFacet: Mark | 'facet' | CompositeMark, when?: string) {\n  return `${channel} dropped as it is incompatible with \"${markOrFacet}\"${when ? ` when ${when}` : ''}.`;\n}\n\nexport function invalidEncodingChannel(channel: string) {\n  return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;\n}\n\nexport function facetChannelShouldBeDiscrete(channel: string) {\n  return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n}\n\nexport function facetChannelDropped(channels: FacetChannel[]) {\n  return `Facet encoding dropped as ${channels.join(' and ')} ${channels.length > 1 ? 'are' : 'is'} also specified.`;\n}\n\nexport function discreteChannelCannotEncode(channel: Channel, type: Type) {\n  return `Using discrete channel \"${channel}\" to encode \"${type}\" field can be misleading as it does not encode ${\n    type === 'ordinal' ? 'order' : 'magnitude'\n  }.`;\n}\n\n// Mark\nexport function lineWithRange(hasX2: boolean, hasY2: boolean) {\n  const channels = hasX2 && hasY2 ? 'x2 and y2' : hasX2 ? 'x2' : 'y2';\n  return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;\n}\n\nexport function orientOverridden(original: string, actual: string) {\n  return `Specified orient \"${original}\" overridden with \"${actual}\".`;\n}\n\n// SCALE\nexport const CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN =\n  'Custom domain scale cannot be unioned with default field-based domain.';\n\nexport const RANGE_STEP_DEPRECATED = `Scale's \"rangeStep\" is deprecated and will be removed in Vega-Lite 5.0. Please use \"width\"/\"height\": {\"step\": ...} instead. See https://vega.github.io/vega-lite/docs/size.html.`;\n\nexport function cannotUseScalePropertyWithNonColor(prop: string) {\n  return `Cannot use the scale property \"${prop}\" with non-color channel.`;\n}\n\nexport function unaggregateDomainHasNoEffectForRawField(fieldDef: TypedFieldDef<string>) {\n  return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;\n}\n\nexport function unaggregateDomainWithNonSharedDomainOp(aggregate: Aggregate | string) {\n  return `Unaggregated domain not applicable for \"${aggregate}\" since it produces values outside the origin domain of the source data.`;\n}\n\nexport function unaggregatedDomainWithLogScale(fieldDef: TypedFieldDef<string>) {\n  return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;\n}\n\nexport function cannotApplySizeToNonOrientedMark(mark: Mark) {\n  return `Cannot apply size to non-oriented mark \"${mark}\".`;\n}\n\nexport function scaleTypeNotWorkWithChannel(channel: Channel, scaleType: ScaleType, defaultScaleType: ScaleType) {\n  return `Channel \"${channel}\" does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\n\nexport function scaleTypeNotWorkWithFieldDef(scaleType: ScaleType, defaultScaleType: ScaleType) {\n  return `FieldDef does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\n\nexport function scalePropertyNotWorkWithScaleType(scaleType: ScaleType, propName: string, channel: Channel) {\n  return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n}\n\nexport function scaleTypeNotWorkWithMark(mark: Mark, scaleType: ScaleType) {\n  return `Scale type \"${scaleType}\" does not work with mark \"${mark}\".`;\n}\n\nexport function stepDropped(channel: 'width' | 'height') {\n  return `The step for \"${channel}\" is dropped because the ${channel === 'width' ? 'x' : 'y'} is continuous.`;\n}\n\nexport function mergeConflictingProperty<T>(\n  property: string | number | symbol,\n  propertyOf: SplitParentProperty,\n  v1: T,\n  v2: T\n) {\n  return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(\n    v2\n  )}). Using ${stringify(v1)}.`;\n}\n\nexport function mergeConflictingDomainProperty<T>(property: 'domains', propertyOf: SplitParentProperty, v1: T, v2: T) {\n  return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(\n    v2\n  )}). Using the union of the two domains.`;\n}\n\nexport function independentScaleMeansIndependentGuide(channel: Channel) {\n  return `Setting the scale to be independent for \"${channel}\" means we also have to set the guide (axis or legend) to be independent.`;\n}\n\nexport function domainSortDropped(sort: VgSortField) {\n  return `Dropping sort property ${stringify(\n    sort\n  )} as unioned domains only support boolean or op \"count\", \"min\", and \"max\".`;\n}\n\nexport const UNABLE_TO_MERGE_DOMAINS = 'Unable to merge domains.';\n\nexport const MORE_THAN_ONE_SORT =\n  'Domains that should be unioned has conflicting sort properties. Sort will be set to true.';\n\n// AXIS\nexport const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n\n// STACK\nexport function cannotStackRangedMark(channel: Channel) {\n  return `Cannot stack \"${channel}\" if there is already \"${channel}2\".`;\n}\n\nexport function cannotStackNonLinearScale(scaleType: ScaleType) {\n  return `Cannot stack non-linear scale (${scaleType}).`;\n}\n\nexport function stackNonSummativeAggregate(aggregate: Aggregate | string) {\n  return `Stacking is applied even though the aggregate function is non-summative (\"${aggregate}\").`;\n}\n\n// TIMEUNIT\nexport function invalidTimeUnit(unitName: string, value: string | number) {\n  return `Invalid ${unitName}: ${stringify(value)}.`;\n}\n\nexport function dayReplacedWithDate(fullTimeUnit: string) {\n  return `Time unit \"${fullTimeUnit}\" is not supported. We are replacing it with ${replaceAll(\n    fullTimeUnit,\n    'day',\n    'date'\n  )}.`;\n}\n\nexport function droppedDay(d: DateTime | DateTimeExpr) {\n  return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;\n}\n\nexport function errorBarCenterAndExtentAreNotNeeded(center: ErrorBarCenter, extent: ErrorBarExtent) {\n  return `${extent ? 'extent ' : ''}${extent && center ? 'and ' : ''}${center ? 'center ' : ''}${\n    extent && center ? 'are ' : 'is '\n  }not needed when data are aggregated.`;\n}\n\nexport function errorBarCenterIsUsedWithWrongExtent(\n  center: ErrorBarCenter,\n  extent: ErrorBarExtent,\n  mark: 'errorbar' | 'errorband'\n) {\n  return `${center} is not usually used with ${extent} for ${mark}.`;\n}\n\nexport function errorBarContinuousAxisHasCustomizedAggregate(\n  aggregate: Aggregate | string,\n  compositeMark: CompositeMark\n) {\n  return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;\n}\n\nexport function errorBarCenterIsNotNeeded(extent: ErrorBarExtent, mark: 'errorbar' | 'errorband') {\n  return `Center is not needed to be specified in ${mark} when extent is ${extent}.`;\n}\n\nexport function errorBand1DNotSupport(property: 'interpolate' | 'tension') {\n  return `1D error band does not support ${property}.`;\n}\n\n// CHANNEL\nexport function channelRequiredForBinned(channel: Channel) {\n  return `Channel ${channel} is required for \"binned\" bin.`;\n}\n\nexport function domainRequiredForThresholdScale(channel: Channel) {\n  return `Domain for ${channel} is required for threshold scale.`;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}