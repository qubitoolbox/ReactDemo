{"ast":null,"code":"import { isUrlData } from '../../data';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { PivotTransformNode } from './pivot';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\n\nfunction makeWalkTree(data) {\n  // to name datasources\n  let datasetIndex = 0;\n  /**\n   * Recursively walk down the tree.\n   */\n\n  function walkTree(node, dataSource) {\n    var _a;\n\n    if (node instanceof SourceNode) {\n      // If the source is a named data source or a data source with values, we need\n      // to put it in a different data source. Otherwise, Vega may override the data.\n      if (!node.isGenerator && !isUrlData(node.data)) {\n        data.push(dataSource);\n        const newData = {\n          name: null,\n          source: dataSource.name,\n          transform: []\n        };\n        dataSource = newData;\n      }\n    }\n\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source) {\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = Object.assign(Object.assign({}, (_a = dataSource.format, _a !== null && _a !== void 0 ? _a : {})), {\n          parse: node.assembleFormatParse()\n        }); // add calculates for all nested fields\n\n        dataSource.transform.push(...node.assembleTransforms(true));\n      } else {\n        // Otherwise use Vega expression to parse\n        dataSource.transform.push(...node.assembleTransforms());\n      }\n    }\n\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = `data_${datasetIndex++}`;\n      }\n\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n\n      node.assemble().forEach(d => data.push(d)); // break here because the rest of the tree has to be taken care of by the facet.\n\n      return;\n    }\n\n    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof GeoJSONNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode) {\n      dataSource.transform.push(node.assemble());\n    }\n\n    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode) {\n      dataSource.transform.push(...node.assemble());\n    }\n\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.setSource(dataSource.source);\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.setSource(dataSource.name);\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        } // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n\n\n        node.setSource(dataSource.name); // if this node has more than one child, we will add a datasource automatically\n\n        if (node.numChildren() === 1) {\n          data.push(dataSource);\n          const newData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = newData;\n        }\n      }\n    }\n\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n\n        break;\n\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n\n      default:\n        {\n          if (!dataSource.name) {\n            dataSource.name = `data_${datasetIndex++}`;\n          }\n\n          let source = dataSource.name;\n\n          if (!dataSource.source || dataSource.transform.length > 0) {\n            data.push(dataSource);\n          } else {\n            source = dataSource.source;\n          }\n\n          node.children.forEach(child => {\n            const newData = {\n              name: null,\n              source: source,\n              transform: []\n            };\n            walkTree(child, newData);\n          });\n          break;\n        }\n    }\n  }\n\n  return walkTree;\n}\n/**\n * Assemble data sources that are derived from faceted data.\n */\n\n\nexport function assembleFacetData(root) {\n  const data = [];\n  const walkTree = makeWalkTree(data);\n  root.children.forEach(child => walkTree(child, {\n    source: root.name,\n    name: null,\n    transform: []\n  }));\n  return data;\n}\n/**\n * Create Vega Data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\n\nexport function assembleRootData(dataComponent, datasets) {\n  var _a, _b;\n\n  const data = []; // dataComponent.sources.forEach(debug);\n  // draw(dataComponent.sources);\n\n  const walkTree = makeWalkTree(data);\n  let sourceIndex = 0;\n  dataComponent.sources.forEach(root => {\n    // assign a name if the source does not have a name yet\n    if (!root.hasName()) {\n      root.dataName = `source_${sourceIndex++}`;\n    }\n\n    const newData = root.assemble();\n    walkTree(root, newData);\n  }); // remove empty transform arrays for cleaner output\n\n  data.forEach(d => {\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  }); // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n\n  let whereTo = 0;\n\n  for (const [i, d] of data.entries()) {\n    if ((_a = d.transform, _a !== null && _a !== void 0 ? _a : []).length === 0 && !d.source) {\n      data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n    }\n  } // now fix the from references in lookup transforms\n\n\n  for (const d of data) {\n    for (const t of (_b = d.transform, _b !== null && _b !== void 0 ? _b : [])) {\n      if (t.type === 'lookup') {\n        t.from = dataComponent.outputNodes[t.from].getSource();\n      }\n    }\n  } // inline values for datasets that are in the datastore\n\n\n  for (const d of data) {\n    if (d.name in datasets) {\n      d.values = datasets[d.name];\n    }\n  }\n\n  return data;\n}","map":{"version":3,"sources":["../../../../src/compile/data/assemble.ts"],"names":[],"mappings":"AAAA,SAAuB,SAAvB,QAAuC,YAAvC;AAIA,SAAQ,aAAR,QAA4B,aAA5B;AACA,SAAQ,OAAR,QAAsB,OAAtB;AACA,SAAQ,aAAR,QAA4B,aAA5B;AACA,SAAsB,UAAtB,QAAuC,YAAvC;AACA,SAAQ,oBAAR,QAAmC,WAAnC;AACA,SAAQ,SAAR,QAAwB,SAAxB;AACA,SAAQ,UAAR,QAAyB,UAAzB;AACA,SAAQ,iBAAR,QAAgC,iBAAhC;AACA,SAAQ,oBAAR,QAAmC,WAAnC;AACA,SAAQ,iBAAR,QAAgC,QAAhC;AACA,SAAQ,SAAR,QAAwB,eAAxB;AACA,SAAQ,WAAR,QAA0B,WAA1B;AACA,SAAQ,YAAR,QAA2B,YAA3B;AACA,SAAQ,aAAR,QAA4B,aAA5B;AACA,SAAQ,cAAR,QAA6B,cAA7B;AACA,SAAQ,UAAR,QAAyB,UAAzB;AACA,SAAQ,0BAAR,QAAyC,iBAAzC;AACA,SAAQ,kBAAR,QAAiC,SAAjC;AACA,SAAQ,UAAR,QAAyB,UAAzB;AACA,SAAQ,qBAAR,QAAoC,YAApC;AACA,SAAQ,uBAAR,QAAsC,cAAtC;AACA,SAAQ,kBAAR,QAAiC,SAAjC;AACA,SAAQ,mBAAR,QAAkC,UAAlC;AACA,SAAQ,YAAR,QAA2B,YAA3B;AACA,SAAQ,UAAR,QAAyB,UAAzB;AACA,SAAQ,SAAR,QAAwB,SAAxB;AACA,SAAQ,YAAR,QAA2B,YAA3B;AACA,SAAQ,mBAAR,QAAkC,UAAlC;;AAEA,SAAS,YAAT,CAAsB,IAAtB,EAAoC;AAClC;AACA,MAAI,YAAY,GAAG,CAAnB;AAEA;;;;AAGA,WAAS,QAAT,CAAkB,IAAlB,EAAsC,UAAtC,EAAwD;;;AACtD,QAAI,IAAI,YAAY,UAApB,EAAgC;AAC9B;AACA;AACA,UAAI,CAAC,IAAI,CAAC,WAAN,IAAqB,CAAC,SAAS,CAAC,IAAI,CAAC,IAAN,CAAnC,EAAgD;AAC9C,QAAA,IAAI,CAAC,IAAL,CAAU,UAAV;AACA,cAAM,OAAO,GAAW;AACtB,UAAA,IAAI,EAAE,IADgB;AAEtB,UAAA,MAAM,EAAE,UAAU,CAAC,IAFG;AAGtB,UAAA,SAAS,EAAE;AAHW,SAAxB;AAKA,QAAA,UAAU,GAAG,OAAb;AACD;AACF;;AAED,QAAI,IAAI,YAAY,SAApB,EAA+B;AAC7B,UAAI,IAAI,CAAC,MAAL,YAAuB,UAAvB,IAAqC,CAAC,UAAU,CAAC,MAArD,EAA6D;AAC3D;AACA,QAAA,UAAU,CAAC,MAAX,GAAiB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,GACZ,EAAA,GAAC,UAAU,CAAC,MAAZ,EAAkB,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EADV,EAAA,EACa;AAC5B,UAAA,KAAK,EAAE,IAAI,CAAC,mBAAL;AADqB,SADb,CAAjB,CAF2D,CAO3D;;AACA,QAAA,UAAU,CAAC,SAAX,CAAqB,IAArB,CAA0B,GAAG,IAAI,CAAC,kBAAL,CAAwB,IAAxB,CAA7B;AACD,OATD,MASO;AACL;AACA,QAAA,UAAU,CAAC,SAAX,CAAqB,IAArB,CAA0B,GAAG,IAAI,CAAC,kBAAL,EAA7B;AACD;AACF;;AAED,QAAI,IAAI,YAAY,SAApB,EAA+B;AAC7B,UAAI,CAAC,UAAU,CAAC,IAAhB,EAAsB;AACpB,QAAA,UAAU,CAAC,IAAX,GAAkB,QAAQ,YAAY,EAAE,EAAxC;AACD;;AAED,UAAI,CAAC,UAAU,CAAC,MAAZ,IAAsB,UAAU,CAAC,SAAX,CAAqB,MAArB,GAA8B,CAAxD,EAA2D;AACzD,QAAA,IAAI,CAAC,IAAL,CAAU,UAAV;AACA,QAAA,IAAI,CAAC,IAAL,GAAY,UAAU,CAAC,IAAvB;AACD,OAHD,MAGO;AACL,QAAA,IAAI,CAAC,IAAL,GAAY,UAAU,CAAC,MAAvB;AACD;;AAED,MAAA,IAAI,CAAC,QAAL,GAAgB,OAAhB,CAAwB,CAAC,IAAI,IAAI,CAAC,IAAL,CAAU,CAAV,CAA7B,EAZ6B,CAc7B;;AACA;AACD;;AAED,QACE,IAAI,YAAY,aAAhB,IACA,IAAI,YAAY,YADhB,IAEA,IAAI,YAAY,iBAFhB,IAGA,IAAI,YAAY,UAHhB,IAIA,IAAI,YAAY,aAJhB,IAKA,IAAI,YAAY,YALhB,IAMA,IAAI,YAAY,WANhB,IAOA,IAAI,YAAY,aAPhB,IAQA,IAAI,YAAY,UARhB,IASA,IAAI,YAAY,mBAThB,IAUA,IAAI,YAAY,0BAVhB,IAWA,IAAI,YAAY,iBAXhB,IAYA,IAAI,YAAY,oBAZhB,IAaA,IAAI,YAAY,oBAbhB,IAcA,IAAI,YAAY,kBAdhB,IAeA,IAAI,YAAY,qBAfhB,IAgBA,IAAI,YAAY,uBAhBhB,IAiBA,IAAI,YAAY,cAjBhB,IAkBA,IAAI,YAAY,mBAlBhB,IAmBA,IAAI,YAAY,kBApBlB,EAqBE;AACA,MAAA,UAAU,CAAC,SAAX,CAAqB,IAArB,CAA0B,IAAI,CAAC,QAAL,EAA1B;AACD;;AAED,QACE,IAAI,YAAY,OAAhB,IACA,IAAI,YAAY,YADhB,IAEA,IAAI,YAAY,UAFhB,IAGA,IAAI,YAAY,SAJlB,EAKE;AACA,MAAA,UAAU,CAAC,SAAX,CAAqB,IAArB,CAA0B,GAAG,IAAI,CAAC,QAAL,EAA7B;AACD;;AAED,QAAI,IAAI,YAAY,UAApB,EAAgC;AAC9B,UAAI,UAAU,CAAC,MAAX,IAAqB,UAAU,CAAC,SAAX,CAAqB,MAArB,KAAgC,CAAzD,EAA4D;AAC1D,QAAA,IAAI,CAAC,SAAL,CAAe,UAAU,CAAC,MAA1B;AACD,OAFD,MAEO,IAAI,IAAI,CAAC,MAAL,YAAuB,UAA3B,EAAuC;AAC5C;AACA;AACA,QAAA,IAAI,CAAC,SAAL,CAAe,UAAU,CAAC,IAA1B;AACD,OAJM,MAIA;AACL,YAAI,CAAC,UAAU,CAAC,IAAhB,EAAsB;AACpB,UAAA,UAAU,CAAC,IAAX,GAAkB,QAAQ,YAAY,EAAE,EAAxC;AACD,SAHI,CAKL;AACA;;;AACA,QAAA,IAAI,CAAC,SAAL,CAAe,UAAU,CAAC,IAA1B,EAPK,CASL;;AACA,YAAI,IAAI,CAAC,WAAL,OAAuB,CAA3B,EAA8B;AAC5B,UAAA,IAAI,CAAC,IAAL,CAAU,UAAV;AACA,gBAAM,OAAO,GAAW;AACtB,YAAA,IAAI,EAAE,IADgB;AAEtB,YAAA,MAAM,EAAE,UAAU,CAAC,IAFG;AAGtB,YAAA,SAAS,EAAE;AAHW,WAAxB;AAKA,UAAA,UAAU,GAAG,OAAb;AACD;AACF;AACF;;AAED,YAAQ,IAAI,CAAC,WAAL,EAAR;AACE,WAAK,CAAL;AACE;AACA,YAAI,IAAI,YAAY,UAAhB,KAA+B,CAAC,UAAU,CAAC,MAAZ,IAAsB,UAAU,CAAC,SAAX,CAAqB,MAArB,GAA8B,CAAnF,CAAJ,EAA2F;AACzF;AACA,UAAA,IAAI,CAAC,IAAL,CAAU,UAAV;AACD;;AACD;;AACF,WAAK,CAAL;AACE,QAAA,QAAQ,CAAC,IAAI,CAAC,QAAL,CAAc,CAAd,CAAD,EAAmB,UAAnB,CAAR;AACA;;AACF;AAAS;AACP,cAAI,CAAC,UAAU,CAAC,IAAhB,EAAsB;AACpB,YAAA,UAAU,CAAC,IAAX,GAAkB,QAAQ,YAAY,EAAE,EAAxC;AACD;;AAED,cAAI,MAAM,GAAG,UAAU,CAAC,IAAxB;;AACA,cAAI,CAAC,UAAU,CAAC,MAAZ,IAAsB,UAAU,CAAC,SAAX,CAAqB,MAArB,GAA8B,CAAxD,EAA2D;AACzD,YAAA,IAAI,CAAC,IAAL,CAAU,UAAV;AACD,WAFD,MAEO;AACL,YAAA,MAAM,GAAG,UAAU,CAAC,MAApB;AACD;;AAED,UAAA,IAAI,CAAC,QAAL,CAAc,OAAd,CAAsB,KAAK,IAAG;AAC5B,kBAAM,OAAO,GAAW;AACtB,cAAA,IAAI,EAAE,IADgB;AAEtB,cAAA,MAAM,EAAE,MAFc;AAGtB,cAAA,SAAS,EAAE;AAHW,aAAxB;AAKA,YAAA,QAAQ,CAAC,KAAD,EAAQ,OAAR,CAAR;AACD,WAPD;AAQA;AACD;AAhCH;AAkCD;;AAED,SAAO,QAAP;AACD;AAED;;;;;AAGA,OAAM,SAAU,iBAAV,CAA4B,IAA5B,EAA2C;AAC/C,QAAM,IAAI,GAAa,EAAvB;AACA,QAAM,QAAQ,GAAG,YAAY,CAAC,IAAD,CAA7B;AAEA,EAAA,IAAI,CAAC,QAAL,CAAc,OAAd,CAAsB,KAAK,IACzB,QAAQ,CAAC,KAAD,EAAQ;AACd,IAAA,MAAM,EAAE,IAAI,CAAC,IADC;AAEd,IAAA,IAAI,EAAE,IAFQ;AAGd,IAAA,SAAS,EAAE;AAHG,GAAR,CADV;AAQA,SAAO,IAAP;AACD;AAED;;;;;;;;AAOA,OAAM,SAAU,gBAAV,CAA2B,aAA3B,EAAyD,QAAzD,EAAsF;;;AAC1F,QAAM,IAAI,GAAa,EAAvB,CAD0F,CAG1F;AACA;;AAEA,QAAM,QAAQ,GAAG,YAAY,CAAC,IAAD,CAA7B;AAEA,MAAI,WAAW,GAAG,CAAlB;AAEA,EAAA,aAAa,CAAC,OAAd,CAAsB,OAAtB,CAA8B,IAAI,IAAG;AACnC;AACA,QAAI,CAAC,IAAI,CAAC,OAAL,EAAL,EAAqB;AACnB,MAAA,IAAI,CAAC,QAAL,GAAgB,UAAU,WAAW,EAAE,EAAvC;AACD;;AAED,UAAM,OAAO,GAAW,IAAI,CAAC,QAAL,EAAxB;AAEA,IAAA,QAAQ,CAAC,IAAD,EAAO,OAAP,CAAR;AACD,GATD,EAV0F,CAqB1F;;AACA,EAAA,IAAI,CAAC,OAAL,CAAa,CAAC,IAAG;AACf,QAAI,CAAC,CAAC,SAAF,CAAY,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,aAAO,CAAC,CAAC,SAAT;AACD;AACF,GAJD,EAtB0F,CA4B1F;;AACA,MAAI,OAAO,GAAG,CAAd;;AACA,OAAK,MAAM,CAAC,CAAD,EAAI,CAAJ,CAAX,IAAqB,IAAI,CAAC,OAAL,EAArB,EAAqC;AACnC,QAAI,CAAA,EAAA,GAAC,CAAC,CAAC,SAAH,EAAY,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAhB,EAAoB,MAApB,KAA+B,CAA/B,IAAoC,CAAC,CAAC,CAAC,MAA3C,EAAmD;AACjD,MAAA,IAAI,CAAC,MAAL,CAAY,OAAO,EAAnB,EAAuB,CAAvB,EAA0B,IAAI,CAAC,MAAL,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAA1B;AACD;AACF,GAlCyF,CAoC1F;;;AACA,OAAK,MAAM,CAAX,IAAgB,IAAhB,EAAsB;AACpB,SAAK,MAAM,CAAX,KAAY,EAAA,GAAI,CAAC,CAAC,SAAN,EAAe,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAA/B,GAAmC;AACjC,UAAI,CAAC,CAAC,IAAF,KAAW,QAAf,EAAyB;AACvB,QAAA,CAAC,CAAC,IAAF,GAAS,aAAa,CAAC,WAAd,CAA0B,CAAC,CAAC,IAA5B,EAAkC,SAAlC,EAAT;AACD;AACF;AACF,GA3CyF,CA6C1F;;;AACA,OAAK,MAAM,CAAX,IAAgB,IAAhB,EAAsB;AACpB,QAAI,CAAC,CAAC,IAAF,IAAU,QAAd,EAAwB;AACtB,MAAA,CAAC,CAAC,MAAF,GAAW,QAAQ,CAAC,CAAC,CAAC,IAAH,CAAnB;AACD;AACF;;AAED,SAAO,IAAP;AACD","sourcesContent":["import {InlineDataset, isUrlData} from '../../data';\nimport {Dict} from '../../util';\nimport {VgData} from '../../vega.schema';\nimport {DataComponent} from './';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {CalculateNode} from './calculate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {DensityTransformNode} from './density';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {FilterInvalidNode} from './filterinvalid';\nimport {FlattenTransformNode} from './flatten';\nimport {FoldTransformNode} from './fold';\nimport {ParseNode} from './formatparse';\nimport {GeoJSONNode} from './geojson';\nimport {GeoPointNode} from './geopoint';\nimport {GraticuleNode} from './graticule';\nimport {IdentifierNode} from './identifier';\nimport {ImputeNode} from './impute';\nimport {JoinAggregateTransformNode} from './joinaggregate';\nimport {LoessTransformNode} from './loess';\nimport {LookupNode} from './lookup';\nimport {QuantileTransformNode} from './quantile';\nimport {RegressionTransformNode} from './regression';\nimport {PivotTransformNode} from './pivot';\nimport {SampleTransformNode} from './sample';\nimport {SequenceNode} from './sequence';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\nfunction makeWalkTree(data: VgData[]) {\n  // to name datasources\n  let datasetIndex = 0;\n\n  /**\n   * Recursively walk down the tree.\n   */\n  function walkTree(node: DataFlowNode, dataSource: VgData) {\n    if (node instanceof SourceNode) {\n      // If the source is a named data source or a data source with values, we need\n      // to put it in a different data source. Otherwise, Vega may override the data.\n      if (!node.isGenerator && !isUrlData(node.data)) {\n        data.push(dataSource);\n        const newData: VgData = {\n          name: null,\n          source: dataSource.name,\n          transform: []\n        };\n        dataSource = newData;\n      }\n    }\n\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source) {\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = {\n          ...(dataSource.format ?? {}),\n          parse: node.assembleFormatParse()\n        };\n\n        // add calculates for all nested fields\n        dataSource.transform.push(...node.assembleTransforms(true));\n      } else {\n        // Otherwise use Vega expression to parse\n        dataSource.transform.push(...node.assembleTransforms());\n      }\n    }\n\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = `data_${datasetIndex++}`;\n      }\n\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n\n      node.assemble().forEach(d => data.push(d));\n\n      // break here because the rest of the tree has to be taken care of by the facet.\n      return;\n    }\n\n    if (\n      node instanceof GraticuleNode ||\n      node instanceof SequenceNode ||\n      node instanceof FilterInvalidNode ||\n      node instanceof FilterNode ||\n      node instanceof CalculateNode ||\n      node instanceof GeoPointNode ||\n      node instanceof GeoJSONNode ||\n      node instanceof AggregateNode ||\n      node instanceof LookupNode ||\n      node instanceof WindowTransformNode ||\n      node instanceof JoinAggregateTransformNode ||\n      node instanceof FoldTransformNode ||\n      node instanceof FlattenTransformNode ||\n      node instanceof DensityTransformNode ||\n      node instanceof LoessTransformNode ||\n      node instanceof QuantileTransformNode ||\n      node instanceof RegressionTransformNode ||\n      node instanceof IdentifierNode ||\n      node instanceof SampleTransformNode ||\n      node instanceof PivotTransformNode\n    ) {\n      dataSource.transform.push(node.assemble());\n    }\n\n    if (\n      node instanceof BinNode ||\n      node instanceof TimeUnitNode ||\n      node instanceof ImputeNode ||\n      node instanceof StackNode\n    ) {\n      dataSource.transform.push(...node.assemble());\n    }\n\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.setSource(dataSource.source);\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.setSource(dataSource.name);\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        }\n\n        // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n        node.setSource(dataSource.name);\n\n        // if this node has more than one child, we will add a datasource automatically\n        if (node.numChildren() === 1) {\n          data.push(dataSource);\n          const newData: VgData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = newData;\n        }\n      }\n    }\n\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n        break;\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n      default: {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        }\n\n        let source = dataSource.name;\n        if (!dataSource.source || dataSource.transform.length > 0) {\n          data.push(dataSource);\n        } else {\n          source = dataSource.source;\n        }\n\n        node.children.forEach(child => {\n          const newData: VgData = {\n            name: null,\n            source: source,\n            transform: []\n          };\n          walkTree(child, newData);\n        });\n        break;\n      }\n    }\n  }\n\n  return walkTree;\n}\n\n/**\n * Assemble data sources that are derived from faceted data.\n */\nexport function assembleFacetData(root: FacetNode): VgData[] {\n  const data: VgData[] = [];\n  const walkTree = makeWalkTree(data);\n\n  root.children.forEach(child =>\n    walkTree(child, {\n      source: root.name,\n      name: null,\n      transform: []\n    })\n  );\n\n  return data;\n}\n\n/**\n * Create Vega Data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleRootData(dataComponent: DataComponent, datasets: Dict<InlineDataset>): VgData[] {\n  const data: VgData[] = [];\n\n  // dataComponent.sources.forEach(debug);\n  // draw(dataComponent.sources);\n\n  const walkTree = makeWalkTree(data);\n\n  let sourceIndex = 0;\n\n  dataComponent.sources.forEach(root => {\n    // assign a name if the source does not have a name yet\n    if (!root.hasName()) {\n      root.dataName = `source_${sourceIndex++}`;\n    }\n\n    const newData: VgData = root.assemble();\n\n    walkTree(root, newData);\n  });\n\n  // remove empty transform arrays for cleaner output\n  data.forEach(d => {\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  });\n\n  // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n  let whereTo = 0;\n  for (const [i, d] of data.entries()) {\n    if ((d.transform ?? []).length === 0 && !d.source) {\n      data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n    }\n  }\n\n  // now fix the from references in lookup transforms\n  for (const d of data) {\n    for (const t of d.transform ?? []) {\n      if (t.type === 'lookup') {\n        t.from = dataComponent.outputNodes[t.from].getSource();\n      }\n    }\n  }\n\n  // inline values for datasets that are in the datastore\n  for (const d of data) {\n    if (d.name in datasets) {\n      d.values = datasets[d.name];\n    }\n  }\n\n  return data;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}