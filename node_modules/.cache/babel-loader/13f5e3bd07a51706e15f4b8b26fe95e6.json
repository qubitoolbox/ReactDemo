{"ast":null,"code":"import { isTimeFormatFieldDef } from '../../channeldef';\nimport { ScaleType } from '../../scale';\nimport { keys } from '../../util';\nimport { timeFormatExpression } from '../common';\nexport function labels(model, channel, specifiedLabelsSpec) {\n  var _a;\n\n  const fieldDef = (_a = model.fieldDef(channel), _a !== null && _a !== void 0 ? _a : channel === 'x' ? model.fieldDef('x2') : channel === 'y' ? model.fieldDef('y2') : undefined);\n  const axis = model.axis(channel);\n  let labelsSpec = {}; // We use a label encoding instead of setting the `format` property because Vega does not let us determine how the format should be interpreted.\n\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n    const expr = timeFormatExpression('datum.value', fieldDef.timeUnit, axis.format, null, isUTCScale);\n\n    if (expr) {\n      labelsSpec.text = {\n        signal: expr\n      };\n    }\n  }\n\n  labelsSpec = Object.assign(Object.assign({}, labelsSpec), specifiedLabelsSpec);\n  return keys(labelsSpec).length === 0 ? undefined : labelsSpec;\n}","map":{"version":3,"sources":["../../../../src/compile/axis/encode.ts"],"names":[],"mappings":"AACA,SAAQ,oBAAR,QAAmC,kBAAnC;AACA,SAAQ,SAAR,QAAwB,aAAxB;AACA,SAAQ,IAAR,QAAmB,YAAnB;AACA,SAAQ,oBAAR,QAAmC,WAAnC;AAGA,OAAM,SAAU,MAAV,CAAiB,KAAjB,EAAmC,OAAnC,EAAkE,mBAAlE,EAA0F;;;AAC9F,QAAM,QAAQ,IAAA,EAAA,GACZ,KAAK,CAAC,QAAN,CAAe,OAAf,CADY,EACW,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GACtB,OAAO,KAAK,GAAZ,GAAkB,KAAK,CAAC,QAAN,CAAe,IAAf,CAAlB,GAAyC,OAAO,KAAK,GAAZ,GAAkB,KAAK,CAAC,QAAN,CAAe,IAAf,CAAlB,GAAyC,SAFvE,CAAd;AAGA,QAAM,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,OAAX,CAAb;AAEA,MAAI,UAAU,GAAQ,EAAtB,CAN8F,CAQ9F;;AACA,MAAI,oBAAoB,CAAC,QAAD,CAAxB,EAAoC;AAClC,UAAM,UAAU,GAAG,KAAK,CAAC,iBAAN,CAAwB,OAAxB,EAAiC,GAAjC,CAAqC,MAArC,MAAiD,SAAS,CAAC,GAA9E;AAEA,UAAM,IAAI,GAAG,oBAAoB,CAAC,aAAD,EAAgB,QAAQ,CAAC,QAAzB,EAAmC,IAAI,CAAC,MAAxC,EAAgD,IAAhD,EAAsD,UAAtD,CAAjC;;AAEA,QAAI,IAAJ,EAAU;AACR,MAAA,UAAU,CAAC,IAAX,GAAkB;AAAC,QAAA,MAAM,EAAE;AAAT,OAAlB;AACD;AACF;;AAED,EAAA,UAAU,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACL,UADK,CAAA,EAEL,mBAFK,CAAV;AAKA,SAAO,IAAI,CAAC,UAAD,CAAJ,CAAiB,MAAjB,KAA4B,CAA5B,GAAgC,SAAhC,GAA4C,UAAnD;AACD","sourcesContent":["import {PositionScaleChannel} from '../../channel';\nimport {isTimeFormatFieldDef} from '../../channeldef';\nimport {ScaleType} from '../../scale';\nimport {keys} from '../../util';\nimport {timeFormatExpression} from '../common';\nimport {UnitModel} from '../unit';\n\nexport function labels(model: UnitModel, channel: PositionScaleChannel, specifiedLabelsSpec: any) {\n  const fieldDef =\n    model.fieldDef(channel) ??\n    (channel === 'x' ? model.fieldDef('x2') : channel === 'y' ? model.fieldDef('y2') : undefined);\n  const axis = model.axis(channel);\n\n  let labelsSpec: any = {};\n\n  // We use a label encoding instead of setting the `format` property because Vega does not let us determine how the format should be interpreted.\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n\n    const expr = timeFormatExpression('datum.value', fieldDef.timeUnit, axis.format, null, isUTCScale);\n\n    if (expr) {\n      labelsSpec.text = {signal: expr};\n    }\n  }\n\n  labelsSpec = {\n    ...labelsSpec,\n    ...specifiedLabelsSpec\n  };\n\n  return keys(labelsSpec).length === 0 ? undefined : labelsSpec;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}