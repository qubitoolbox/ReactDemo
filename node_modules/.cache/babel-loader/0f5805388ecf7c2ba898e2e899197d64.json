{"ast":null,"code":"import { hasOwnProperty, stringValue } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { SELECTION_ID } from '../../selection';\nimport { isFacetModel } from '../model';\nimport interval from './interval';\nimport multi from './multi';\nimport single from './single';\nexport const STORE = '_store';\nexport const TUPLE = '_tuple';\nexport const MODIFY = '_modify';\nexport const SELECTION_DOMAIN = '_selection_domain_';\nexport const VL_SELECTION_RESOLVE = 'vlSelectionResolve';\nconst compilers = {\n  single,\n  multi,\n  interval\n};\nexport function forEachSelection(model, cb) {\n  const selections = model.component.selection;\n\n  if (selections) {\n    for (const name in selections) {\n      if (hasOwnProperty(selections, name)) {\n        const sel = selections[name];\n        const success = cb(sel, compilers[sel.type]);\n        if (success === true) break;\n      }\n    }\n  }\n}\n\nfunction getFacetModel(model) {\n  let parent = model.parent;\n\n  while (parent) {\n    if (isFacetModel(parent)) {\n      break;\n    }\n\n    parent = parent.parent;\n  }\n\n  return parent;\n}\n\nexport function unitName(model, {\n  escape\n} = {\n  escape: true\n}) {\n  let name = escape ? stringValue(model.name) : model.name;\n  const facetModel = getFacetModel(model);\n\n  if (facetModel) {\n    const {\n      facet\n    } = facetModel;\n\n    for (const channel of FACET_CHANNELS) {\n      if (facet[channel]) {\n        name += ` + '__facet_${channel}_' + (facet[${stringValue(facetModel.vgField(channel))}])`;\n      }\n    }\n  }\n\n  return name;\n}\nexport function requiresSelectionId(model) {\n  let identifier = false;\n  forEachSelection(model, selCmpt => {\n    identifier = identifier || selCmpt.project.items.some(proj => proj.field === SELECTION_ID);\n  });\n  return identifier;\n}","map":{"version":3,"sources":["../../../../src/compile/selection/index.ts"],"names":[],"mappings":"AACA,SAAQ,cAAR,EAAwB,WAAxB,QAA0C,WAA1C;AACA,SAAQ,cAAR,QAA6B,eAA7B;AACA,SAME,YANF,QAQO,iBARP;AAWA,SAAQ,YAAR,QAAkC,UAAlC;AAEA,OAAO,QAAP,MAAqB,YAArB;AACA,OAAO,KAAP,MAAkB,SAAlB;AACA,OAAO,MAAP,MAAmB,UAAnB;AAIA,OAAO,MAAM,KAAK,GAAG,QAAd;AACP,OAAO,MAAM,KAAK,GAAG,QAAd;AACP,OAAO,MAAM,MAAM,GAAG,SAAf;AACP,OAAO,MAAM,gBAAgB,GAAG,oBAAzB;AACP,OAAO,MAAM,oBAAoB,GAAG,oBAA7B;AAqCP,MAAM,SAAS,GAA4B;AAAC,EAAA,MAAD;AAAS,EAAA,KAAT;AAAgB,EAAA;AAAhB,CAA3C;AAEA,OAAM,SAAU,gBAAV,CACJ,KADI,EAEJ,EAFI,EAE+E;AAEnF,QAAM,UAAU,GAAG,KAAK,CAAC,SAAN,CAAgB,SAAnC;;AACA,MAAI,UAAJ,EAAgB;AACd,SAAK,MAAM,IAAX,IAAmB,UAAnB,EAA+B;AAC7B,UAAI,cAAc,CAAC,UAAD,EAAa,IAAb,CAAlB,EAAsC;AACpC,cAAM,GAAG,GAAG,UAAU,CAAC,IAAD,CAAtB;AACA,cAAM,OAAO,GAAG,EAAE,CAAC,GAAD,EAAM,SAAS,CAAC,GAAG,CAAC,IAAL,CAAf,CAAlB;AACA,YAAI,OAAO,KAAK,IAAhB,EAAsB;AACvB;AACF;AACF;AACF;;AAED,SAAS,aAAT,CAAuB,KAAvB,EAAmC;AACjC,MAAI,MAAM,GAAG,KAAK,CAAC,MAAnB;;AACA,SAAO,MAAP,EAAe;AACb,QAAI,YAAY,CAAC,MAAD,CAAhB,EAA0B;AACxB;AACD;;AACD,IAAA,MAAM,GAAG,MAAM,CAAC,MAAhB;AACD;;AAED,SAAO,MAAP;AACD;;AAED,OAAM,SAAU,QAAV,CAAmB,KAAnB,EAAiC;AAAC,EAAA;AAAD,IAAW;AAAC,EAAA,MAAM,EAAE;AAAT,CAA5C,EAA0D;AAC9D,MAAI,IAAI,GAAG,MAAM,GAAG,WAAW,CAAC,KAAK,CAAC,IAAP,CAAd,GAA6B,KAAK,CAAC,IAApD;AACA,QAAM,UAAU,GAAG,aAAa,CAAC,KAAD,CAAhC;;AACA,MAAI,UAAJ,EAAgB;AACd,UAAM;AAAC,MAAA;AAAD,QAAU,UAAhB;;AACA,SAAK,MAAM,OAAX,IAAsB,cAAtB,EAAsC;AACpC,UAAI,KAAK,CAAC,OAAD,CAAT,EAAoB;AAClB,QAAA,IAAI,IAAI,eAAe,OAAO,eAAe,WAAW,CAAC,UAAU,CAAC,OAAX,CAAmB,OAAnB,CAAD,CAA6B,IAArF;AACD;AACF;AACF;;AACD,SAAO,IAAP;AACD;AAED,OAAM,SAAU,mBAAV,CAA8B,KAA9B,EAA0C;AAC9C,MAAI,UAAU,GAAG,KAAjB;AACA,EAAA,gBAAgB,CAAC,KAAD,EAAQ,OAAO,IAAG;AAChC,IAAA,UAAU,GAAG,UAAU,IAAI,OAAO,CAAC,OAAR,CAAgB,KAAhB,CAAsB,IAAtB,CAA2B,IAAI,IAAI,IAAI,CAAC,KAAL,KAAe,YAAlD,CAA3B;AACD,GAFe,CAAhB;AAGA,SAAO,UAAP;AACD","sourcesContent":["import {Binding, NewSignal, Stream} from 'vega';\nimport {hasOwnProperty, stringValue} from 'vega-util';\nimport {FACET_CHANNELS} from '../../channel';\nimport {\n  BrushConfig,\n  SelectionInit,\n  SelectionInitInterval,\n  SelectionResolution,\n  SelectionType,\n  SELECTION_ID,\n  LegendBinding\n} from '../../selection';\nimport {Dict} from '../../util';\nimport {FacetModel} from '../facet';\nimport {isFacetModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport interval from './interval';\nimport multi from './multi';\nimport single from './single';\nimport {SelectionProjection, SelectionProjectionComponent} from './transforms/project';\nimport {OutputNode} from '../data/dataflow';\n\nexport const STORE = '_store';\nexport const TUPLE = '_tuple';\nexport const MODIFY = '_modify';\nexport const SELECTION_DOMAIN = '_selection_domain_';\nexport const VL_SELECTION_RESOLVE = 'vlSelectionResolve';\n\nexport interface SelectionComponent<T extends SelectionType = SelectionType> {\n  name: string;\n  type: T;\n  // Use conditional types for stricter type of init (as the type of init depends on selection type).\n  init?: (T extends 'interval'\n    ? SelectionInitInterval\n    : T extends 'single'\n    ? SelectionInit\n    : T extends 'multi'\n    ? SelectionInit | SelectionInit[]\n    : never)[];\n  events: Stream[];\n  materialized: OutputNode;\n  bind?: 'scales' | Binding | Dict<Binding> | LegendBinding;\n  resolve: SelectionResolution;\n  empty: 'all' | 'none';\n  mark?: BrushConfig;\n\n  // Transforms\n  project?: SelectionProjectionComponent;\n  scales?: SelectionProjection[];\n  toggle?: any;\n  translate?: any;\n  zoom?: any;\n  nearest?: any;\n  clear?: any;\n}\n\nexport interface SelectionCompiler<T extends SelectionType = SelectionType> {\n  signals: (model: UnitModel, selCmpt: SelectionComponent<T>) => NewSignal[];\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent<T>, signals: NewSignal[]) => NewSignal[];\n  modifyExpr: (model: UnitModel, selCmpt: SelectionComponent<T>) => string;\n  marks?: (model: UnitModel, selCmpt: SelectionComponent<T>, marks: any[]) => any[];\n}\n\nconst compilers: Dict<SelectionCompiler> = {single, multi, interval};\n\nexport function forEachSelection(\n  model: Model,\n  cb: (selCmpt: SelectionComponent, selCompiler: SelectionCompiler) => void | boolean\n) {\n  const selections = model.component.selection;\n  if (selections) {\n    for (const name in selections) {\n      if (hasOwnProperty(selections, name)) {\n        const sel = selections[name];\n        const success = cb(sel, compilers[sel.type]);\n        if (success === true) break;\n      }\n    }\n  }\n}\n\nfunction getFacetModel(model: Model): FacetModel {\n  let parent = model.parent;\n  while (parent) {\n    if (isFacetModel(parent)) {\n      break;\n    }\n    parent = parent.parent;\n  }\n\n  return parent as FacetModel;\n}\n\nexport function unitName(model: Model, {escape} = {escape: true}) {\n  let name = escape ? stringValue(model.name) : model.name;\n  const facetModel = getFacetModel(model);\n  if (facetModel) {\n    const {facet} = facetModel;\n    for (const channel of FACET_CHANNELS) {\n      if (facet[channel]) {\n        name += ` + '__facet_${channel}_' + (facet[${stringValue(facetModel.vgField(channel))}])`;\n      }\n    }\n  }\n  return name;\n}\n\nexport function requiresSelectionId(model: Model) {\n  let identifier = false;\n  forEachSelection(model, selCmpt => {\n    identifier = identifier || selCmpt.project.items.some(proj => proj.field === SELECTION_ID);\n  });\n  return identifier;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}