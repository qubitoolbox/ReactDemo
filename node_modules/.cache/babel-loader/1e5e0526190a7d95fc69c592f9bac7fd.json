{"ast":null,"code":"import { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class ImputeNode extends DataFlowNode {\n  constructor(parent, transform) {\n    super(parent);\n    this.transform = transform;\n  }\n\n  clone() {\n    return new ImputeNode(null, duplicate(this.transform));\n  }\n\n  dependentFields() {\n    var _a;\n\n    return new Set([this.transform.impute, this.transform.key, ...(_a = this.transform.groupby, _a !== null && _a !== void 0 ? _a : [])]);\n  }\n\n  producedFields() {\n    return new Set([this.transform.impute]);\n  }\n\n  processSequence(keyvals) {\n    const {\n      start = 0,\n      stop,\n      step\n    } = keyvals;\n    const result = [start, stop, ...(step ? [step] : [])].join(',');\n    return {\n      signal: `sequence(${result})`\n    };\n  }\n\n  static makeFromTransform(parent, imputeTransform) {\n    return new ImputeNode(parent, imputeTransform);\n  }\n\n  static makeFromEncoding(parent, model) {\n    const encoding = model.encoding;\n    const xDef = encoding.x;\n    const yDef = encoding.y;\n\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n\n      if (imputedChannel === undefined) {\n        return undefined;\n      }\n\n      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n      const {\n        method,\n        value,\n        frame,\n        keyvals\n      } = imputedChannel.impute;\n      const groupbyFields = pathGroupingFields(model.mark, encoding);\n      return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        impute: imputedChannel.field,\n        key: keyChannel.field\n      }, method ? {\n        method\n      } : {}), value !== undefined ? {\n        value\n      } : {}), frame ? {\n        frame\n      } : {}), keyvals !== undefined ? {\n        keyvals\n      } : {}), groupbyFields.length ? {\n        groupby: groupbyFields\n      } : {}));\n    }\n\n    return null;\n  }\n\n  hash() {\n    return `Impute ${hash(this.transform)}`;\n  }\n\n  assemble() {\n    const {\n      impute,\n      key,\n      keyvals,\n      method,\n      groupby,\n      value,\n      frame = [null, null]\n    } = this.transform;\n    const initialImpute = Object.assign(Object.assign(Object.assign(Object.assign({\n      type: 'impute',\n      field: impute,\n      key\n    }, keyvals ? {\n      keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals\n    } : {}), {\n      method: 'value'\n    }), groupby ? {\n      groupby\n    } : {}), {\n      value: null\n    });\n    let setImputedField;\n\n    if (method && method !== 'value') {\n      const deriveNewField = Object.assign({\n        type: 'window',\n        as: [`imputed_${impute}_value`],\n        ops: [method],\n        fields: [impute],\n        frame,\n        ignorePeers: false\n      }, groupby ? {\n        groupby\n      } : {});\n      const replaceOriginal = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n        as: impute\n      };\n      setImputedField = [deriveNewField, replaceOriginal];\n    } else {\n      const replaceWithValue = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? ${value} : datum.${impute}`,\n        as: impute\n      };\n      setImputedField = [replaceWithValue];\n    }\n\n    return [initialImpute, ...setImputedField];\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/impute.ts"],"names":[],"mappings":"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","sourcesContent":["import {FormulaTransform as VgFormulaTransform, SignalRef} from 'vega';\nimport {isFieldDef} from '../../channeldef';\nimport {pathGroupingFields} from '../../encoding';\nimport {ImputeSequence, ImputeTransform, isImputeSequence} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {ImputeTransform as VgImputeTransform} from 'vega';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\nimport {WindowTransform as VgWindowTransform} from 'vega';\n\nexport class ImputeNode extends DataFlowNode {\n  public clone() {\n    return new ImputeNode(null, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private readonly transform: ImputeTransform) {\n    super(parent);\n  }\n\n  public dependentFields() {\n    return new Set([this.transform.impute, this.transform.key, ...(this.transform.groupby ?? [])]);\n  }\n\n  public producedFields() {\n    return new Set([this.transform.impute]);\n  }\n\n  private processSequence(keyvals: ImputeSequence): SignalRef {\n    const {start = 0, stop, step} = keyvals;\n    const result = [start, stop, ...(step ? [step] : [])].join(',');\n\n    return {signal: `sequence(${result})`};\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, imputeTransform: ImputeTransform): ImputeNode {\n    return new ImputeNode(parent, imputeTransform);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel) {\n    const encoding = model.encoding;\n    const xDef = encoding.x;\n    const yDef = encoding.y;\n\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n      if (imputedChannel === undefined) {\n        return undefined;\n      }\n      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n      const {method, value, frame, keyvals} = imputedChannel.impute;\n      const groupbyFields = pathGroupingFields(model.mark, encoding);\n\n      return new ImputeNode(parent, {\n        impute: imputedChannel.field,\n        key: keyChannel.field,\n        ...(method ? {method} : {}),\n        ...(value !== undefined ? {value} : {}),\n        ...(frame ? {frame} : {}),\n        ...(keyvals !== undefined ? {keyvals} : {}),\n        ...(groupbyFields.length ? {groupby: groupbyFields} : {})\n      });\n    }\n    return null;\n  }\n\n  public hash() {\n    return `Impute ${hash(this.transform)}`;\n  }\n\n  public assemble() {\n    const {impute, key, keyvals, method, groupby, value, frame = [null, null] as [null, null]} = this.transform;\n\n    const initialImpute: VgImputeTransform = {\n      type: 'impute',\n      field: impute,\n      key,\n      ...(keyvals ? {keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals} : {}),\n      method: 'value',\n      ...(groupby ? {groupby} : {}),\n      value: null\n    };\n    let setImputedField;\n    if (method && method !== 'value') {\n      const deriveNewField: VgWindowTransform = {\n        type: 'window',\n        as: [`imputed_${impute}_value`],\n        ops: [method],\n        fields: [impute],\n        frame,\n        ignorePeers: false,\n        ...(groupby ? {groupby} : {})\n      };\n      const replaceOriginal: VgFormulaTransform = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n        as: impute\n      };\n      setImputedField = [deriveNewField, replaceOriginal];\n    } else {\n      const replaceWithValue: VgFormulaTransform = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? ${value} : datum.${impute}`,\n        as: impute\n      };\n      setImputedField = [replaceWithValue];\n    }\n\n    return [initialImpute, ...setImputedField];\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}