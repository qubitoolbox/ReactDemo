{"ast":null,"code":"import { isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isTimeFormatFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { ScaleType } from '../../scale';\nimport { getFirstDefined, keys, varName } from '../../util';\nimport { applyMarkConfig, timeFormatExpression } from '../common';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nimport { defaultType } from './properties';\n\nfunction type(legendCmp, model, channel) {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  return getFirstDefined(legendCmp.get('type'), defaultType({\n    channel,\n    scaleType,\n    alwaysReturn: true\n  }));\n}\n\nexport function symbols(fieldDef, symbolsSpec, model, channel, legendCmp) {\n  var _a, _b, _c, _d, _e;\n\n  if (type(legendCmp, model, channel) !== 'symbol') {\n    return undefined;\n  }\n\n  let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), mixins.color(model)); // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  const {\n    markDef,\n    encoding,\n    config\n  } = model;\n  const filled = markDef.filled;\n  const opacity = (_a = getMaxValue(encoding.opacity), _a !== null && _a !== void 0 ? _a : markDef.opacity);\n  const condition = selectedCondition(model, legendCmp, fieldDef);\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || filled && channel === COLOR) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (legendCmp.get('symbolFillColor')) {\n          delete out.fill;\n        } else {\n          out.fill = {\n            value: (_b = config.legend.symbolBaseFillColor, _b !== null && _b !== void 0 ? _b : 'black')\n          };\n          out.fillOpacity = {\n            value: opacity !== null && opacity !== void 0 ? opacity : 1\n          };\n        }\n      } else if (isArray(out.fill)) {\n        const fill = (_e = (_d = getFirstConditionValue((_c = encoding.fill, _c !== null && _c !== void 0 ? _c : encoding.color)), _d !== null && _d !== void 0 ? _d : markDef.fill), _e !== null && _e !== void 0 ? _e : filled && markDef.color);\n\n        if (fill) {\n          out.fill = {\n            value: fill\n          };\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || !filled && channel === COLOR) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field']) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n\n        if (stroke) {\n          out.stroke = {\n            value: stroke\n          };\n        }\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    if (condition) {\n      out.opacity = [{\n        test: condition,\n        value: opacity !== null && opacity !== void 0 ? opacity : 1\n      }, {\n        value: config.legend.unselectedOpacity\n      }];\n    } else if (opacity) {\n      out.opacity = {\n        value: opacity\n      };\n    }\n  }\n\n  out = Object.assign(Object.assign({}, out), symbolsSpec);\n  return keys(out).length > 0 ? out : undefined;\n}\nexport function gradient(fieldDef, gradientSpec, model, channel, legendCmp) {\n  if (type(legendCmp, model, channel) !== 'gradient') {\n    return undefined;\n  }\n\n  let out = {};\n  const opacity = getMaxValue(model.encoding.opacity) || model.markDef.opacity;\n\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = {\n      value: opacity\n    };\n  }\n\n  out = Object.assign(Object.assign({}, out), gradientSpec);\n  return keys(out).length > 0 ? out : undefined;\n}\nexport function labels(fieldDef, labelsSpec, model, channel, legendCmp) {\n  const legend = model.legend(channel);\n  const config = model.config;\n  const condition = selectedCondition(model, legendCmp, fieldDef);\n  let out = {};\n\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n    const expr = timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.timeFormat, isUTCScale);\n    labelsSpec = Object.assign(Object.assign({}, expr ? {\n      text: {\n        signal: expr\n      }\n    } : {}), labelsSpec);\n  }\n\n  if (condition) {\n    labelsSpec.opacity = [{\n      test: condition,\n      value: 1\n    }, {\n      value: config.legend.unselectedOpacity\n    }];\n  }\n\n  out = Object.assign(Object.assign({}, out), labelsSpec);\n  return keys(out).length > 0 ? out : undefined;\n}\nexport function entries(fieldDef, entriesSpec, model, channel, legendCmp) {\n  var _a;\n\n  const selections = legendCmp.get('selections');\n  return ((_a = selections) === null || _a === void 0 ? void 0 : _a.length) ? {\n    fill: {\n      value: 'transparent'\n    }\n  } : undefined;\n}\n\nfunction getMaxValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));\n}\n\nexport function getFirstConditionValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => {\n    return getFirstDefined(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue(channelDef, reducer) {\n  if (hasConditionalValueDef(channelDef)) {\n    return (isArray(channelDef.condition) ? channelDef.condition : [channelDef.condition]).reduce(reducer, channelDef.value);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value;\n  }\n\n  return undefined;\n}\n\nfunction selectedCondition(model, legendCmp, fieldDef) {\n  var _a;\n\n  const selections = legendCmp.get('selections');\n  if (!((_a = selections) === null || _a === void 0 ? void 0 : _a.length)) return undefined;\n  const field = stringValue(fieldDef.field);\n  return selections.map(name => {\n    const store = stringValue(varName(name) + STORE);\n    return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n  }).join(' || ');\n}","map":{"version":3,"sources":["../../../../src/compile/legend/encode.ts"],"names":[],"mappings":"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","sourcesContent":["import {ColorValueRef, SymbolEncodeEntry} from 'vega';\nimport {isArray, stringValue} from 'vega-util';\nimport {COLOR, NonPositionScaleChannel, OPACITY} from '../../channel';\nimport {\n  Conditional,\n  FieldDefWithCondition,\n  Gradient,\n  hasConditionalValueDef,\n  isTimeFormatFieldDef,\n  isValueDef,\n  MarkPropFieldDef,\n  TypedFieldDef,\n  Value,\n  ValueDef,\n  ValueDefWithCondition\n} from '../../channeldef';\nimport {FILL_STROKE_CONFIG} from '../../mark';\nimport {ScaleType} from '../../scale';\nimport {getFirstDefined, keys, varName} from '../../util';\nimport {applyMarkConfig, timeFormatExpression} from '../common';\nimport * as mixins from '../mark/encode';\nimport {STORE} from '../selection';\nimport {UnitModel} from '../unit';\nimport {ScaleChannel} from './../../channel';\nimport {LegendComponent} from './component';\nimport {defaultType} from './properties';\n\nfunction type(legendCmp: LegendComponent, model: UnitModel, channel: ScaleChannel) {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  return getFirstDefined(legendCmp.get('type'), defaultType({channel, scaleType, alwaysReturn: true}));\n}\n\nexport function symbols(\n  fieldDef: TypedFieldDef<string>,\n  symbolsSpec: any,\n  model: UnitModel,\n  channel: ScaleChannel,\n  legendCmp: LegendComponent\n): SymbolEncodeEntry {\n  if (type(legendCmp, model, channel) !== 'symbol') {\n    return undefined;\n  }\n\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model)\n  } as SymbolEncodeEntry; // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  const {markDef, encoding, config} = model;\n  const filled = markDef.filled;\n\n  const opacity = getMaxValue(encoding.opacity) ?? markDef.opacity;\n  const condition = selectedCondition(model, legendCmp, fieldDef);\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || (filled && channel === COLOR)) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (legendCmp.get('symbolFillColor')) {\n          delete out.fill;\n        } else {\n          out.fill = {value: config.legend.symbolBaseFillColor ?? 'black'};\n          out.fillOpacity = {value: opacity ?? 1};\n        }\n      } else if (isArray(out.fill)) {\n        const fill =\n          getFirstConditionValue(encoding.fill ?? encoding.color) ?? markDef.fill ?? (filled && markDef.color);\n        if (fill) {\n          out.fill = {value: fill} as ColorValueRef;\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || (!filled && channel === COLOR)) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field']) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstDefined(\n          getFirstConditionValue(encoding.stroke || encoding.color),\n          markDef.stroke,\n          filled ? markDef.color : undefined\n        );\n        if (stroke) {\n          out.stroke = {value: stroke} as ColorValueRef;\n        }\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    if (condition) {\n      out.opacity = [{test: condition, value: opacity ?? 1}, {value: config.legend.unselectedOpacity}];\n    } else if (opacity) {\n      out.opacity = {value: opacity};\n    }\n  }\n\n  out = {...out, ...symbolsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function gradient(\n  fieldDef: TypedFieldDef<string>,\n  gradientSpec: any,\n  model: UnitModel,\n  channel: ScaleChannel,\n  legendCmp: LegendComponent\n) {\n  if (type(legendCmp, model, channel) !== 'gradient') {\n    return undefined;\n  }\n\n  let out: SymbolEncodeEntry = {};\n\n  const opacity = getMaxValue(model.encoding.opacity) || model.markDef.opacity;\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = {value: opacity};\n  }\n\n  out = {...out, ...gradientSpec};\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function labels(\n  fieldDef: TypedFieldDef<string>,\n  labelsSpec: any,\n  model: UnitModel,\n  channel: NonPositionScaleChannel,\n  legendCmp: LegendComponent\n) {\n  const legend = model.legend(channel);\n  const config = model.config;\n  const condition = selectedCondition(model, legendCmp, fieldDef);\n\n  let out: SymbolEncodeEntry = {};\n\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n    const expr = timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.timeFormat, isUTCScale);\n    labelsSpec = {\n      ...(expr ? {text: {signal: expr}} : {}),\n      ...labelsSpec\n    };\n  }\n\n  if (condition) {\n    labelsSpec.opacity = [{test: condition, value: 1}, {value: config.legend.unselectedOpacity}];\n  }\n\n  out = {...out, ...labelsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function entries(\n  fieldDef: TypedFieldDef<string>,\n  entriesSpec: any,\n  model: UnitModel,\n  channel: NonPositionScaleChannel,\n  legendCmp: LegendComponent\n) {\n  const selections = legendCmp.get('selections');\n  return selections?.length ? {fill: {value: 'transparent'}} : undefined;\n}\n\nfunction getMaxValue(\n  channelDef:\n    | FieldDefWithCondition<MarkPropFieldDef<string>, number>\n    | ValueDefWithCondition<MarkPropFieldDef<string>, number>\n) {\n  return getConditionValue<number>(channelDef, (v: number, conditionalDef) => Math.max(v, conditionalDef.value as any));\n}\n\nexport function getFirstConditionValue<V extends Value | Gradient>(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>, V> | ValueDefWithCondition<MarkPropFieldDef<string>, V>\n): V {\n  return getConditionValue(channelDef, (v: V, conditionalDef: Conditional<ValueDef<V>>) => {\n    return getFirstDefined<V>(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue<V extends Value | Gradient>(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>, V> | ValueDefWithCondition<MarkPropFieldDef<string>, V>,\n  reducer: (val: V, conditionalDef: Conditional<ValueDef<V>>) => V\n): V {\n  if (hasConditionalValueDef(channelDef)) {\n    return (isArray(channelDef.condition) ? channelDef.condition : [channelDef.condition]).reduce(\n      reducer,\n      channelDef.value as any\n    );\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value as any;\n  }\n  return undefined;\n}\n\nfunction selectedCondition(model: UnitModel, legendCmp: LegendComponent, fieldDef: TypedFieldDef<string>) {\n  const selections = legendCmp.get('selections');\n  if (!selections?.length) return undefined;\n\n  const field = stringValue(fieldDef.field);\n  return selections\n    .map(name => {\n      const store = stringValue(varName(name) + STORE);\n      return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n    })\n    .join(' || ');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}