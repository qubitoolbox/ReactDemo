{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\n\nconst jpeg = __importStar(require(\"jpeg-js\"));\n\nvar ImageType;\n\n(function (ImageType) {\n  ImageType[\"JPEG\"] = \"jpeg\";\n  ImageType[\"PNG\"] = \"png\";\n  ImageType[\"GIF\"] = \"gif\";\n  ImageType[\"BMP\"] = \"BMP\";\n})(ImageType || (ImageType = {}));\n/**\n * Decode a JPEG-encoded image to a 3D Tensor of dtype `int32`.\n *\n * ```js\n * const image = require('path/to/img.jpg');\n * const imageAssetPath = Image.resolveAssetSource(image);\n * const response = await fetch(imageAssetPath.uri, {}, { isBinary: true });\n * const rawImageData = await response.arrayBuffer();\n * const imageTensor = decodeJpeg(rawImageData);\n * ```\n *\n * @param contents The JPEG-encoded image in an Uint8Array.\n * @param channels An optional int. Defaults to 3. Accepted values are\n *     0: use the number of channels in the JPG-encoded image.\n *     1: output a grayscale image.\n *     3: output an RGB image.\n * @returns A 3D Tensor of dtype `int32` with shape [height, width, 1/3].\n */\n\n/** @doc {heading: 'Media', subheading: 'Images'} */\n\n\nfunction decodeJpeg(contents, channels = 3) {\n  tfjs_core_1.util.assert(getImageType(contents) === ImageType.JPEG, () => 'The passed contents are not a valid JPEG image');\n  tfjs_core_1.util.assert(channels === 3, () => 'Only 3 channels is supported at this time');\n  const TO_UINT8ARRAY = true;\n  const {\n    width,\n    height,\n    data\n  } = jpeg.decode(contents, TO_UINT8ARRAY); // Drop the alpha channel info because jpeg.decode always returns a typedArray\n  // with 255\n\n  const buffer = new Uint8Array(width * height * 3);\n  let offset = 0; // offset into original data\n\n  for (let i = 0; i < buffer.length; i += 3) {\n    buffer[i] = data[offset];\n    buffer[i + 1] = data[offset + 1];\n    buffer[i + 2] = data[offset + 2];\n    offset += 4;\n  }\n\n  return tfjs_core_1.tensor3d(buffer, [height, width, channels]);\n}\n\nexports.decodeJpeg = decodeJpeg;\n/**\n * Helper function to get image type based on starting bytes of the image file.\n */\n\nfunction getImageType(content) {\n  // Classify the contents of a file based on starting bytes (aka magic number:\n  // tslint:disable-next-line:max-line-length\n  // https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files)\n  // This aligns with TensorFlow Core code:\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/4213d5c1bd921f8d5b7b2dc4bbf1eea78d0b5258/tensorflow/core/kernels/decode_image_op.cc#L44\n  if (content.length > 3 && content[0] === 255 && content[1] === 216 && content[2] === 255) {\n    // JPEG byte chunk starts with `ff d8 ff`\n    return ImageType.JPEG;\n  } else if (content.length > 4 && content[0] === 71 && content[1] === 73 && content[2] === 70 && content[3] === 56) {\n    // GIF byte chunk starts with `47 49 46 38`\n    return ImageType.GIF;\n  } else if (content.length > 8 && content[0] === 137 && content[1] === 80 && content[2] === 78 && content[3] === 71 && content[4] === 13 && content[5] === 10 && content[6] === 26 && content[7] === 10) {\n    // PNG byte chunk starts with `\\211 P N G \\r \\n \\032 \\n (89 50 4E 47 0D 0A\n    // 1A 0A)`\n    return ImageType.PNG;\n  } else if (content.length > 3 && content[0] === 66 && content[1] === 77) {\n    // BMP byte chunk starts with `42 4d`\n    return ImageType.BMP;\n  } else {\n    throw new Error('Expected image (JPEG, PNG, or GIF), but got unsupported image type');\n  }\n}","map":{"version":3,"sources":["../src/decode_image.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\nconst jpeg = __importStar(require(\"jpeg-js\"));\nvar ImageType;\n(function (ImageType) {\n    ImageType[\"JPEG\"] = \"jpeg\";\n    ImageType[\"PNG\"] = \"png\";\n    ImageType[\"GIF\"] = \"gif\";\n    ImageType[\"BMP\"] = \"BMP\";\n})(ImageType || (ImageType = {}));\n/**\n * Decode a JPEG-encoded image to a 3D Tensor of dtype `int32`.\n *\n * ```js\n * const image = require('path/to/img.jpg');\n * const imageAssetPath = Image.resolveAssetSource(image);\n * const response = await fetch(imageAssetPath.uri, {}, { isBinary: true });\n * const rawImageData = await response.arrayBuffer();\n * const imageTensor = decodeJpeg(rawImageData);\n * ```\n *\n * @param contents The JPEG-encoded image in an Uint8Array.\n * @param channels An optional int. Defaults to 3. Accepted values are\n *     0: use the number of channels in the JPG-encoded image.\n *     1: output a grayscale image.\n *     3: output an RGB image.\n * @returns A 3D Tensor of dtype `int32` with shape [height, width, 1/3].\n */\n/** @doc {heading: 'Media', subheading: 'Images'} */\nfunction decodeJpeg(contents, channels = 3) {\n    tfjs_core_1.util.assert(getImageType(contents) === ImageType.JPEG, () => 'The passed contents are not a valid JPEG image');\n    tfjs_core_1.util.assert(channels === 3, () => 'Only 3 channels is supported at this time');\n    const TO_UINT8ARRAY = true;\n    const { width, height, data } = jpeg.decode(contents, TO_UINT8ARRAY);\n    // Drop the alpha channel info because jpeg.decode always returns a typedArray\n    // with 255\n    const buffer = new Uint8Array(width * height * 3);\n    let offset = 0; // offset into original data\n    for (let i = 0; i < buffer.length; i += 3) {\n        buffer[i] = data[offset];\n        buffer[i + 1] = data[offset + 1];\n        buffer[i + 2] = data[offset + 2];\n        offset += 4;\n    }\n    return tfjs_core_1.tensor3d(buffer, [height, width, channels]);\n}\nexports.decodeJpeg = decodeJpeg;\n/**\n * Helper function to get image type based on starting bytes of the image file.\n */\nfunction getImageType(content) {\n    // Classify the contents of a file based on starting bytes (aka magic number:\n    // tslint:disable-next-line:max-line-length\n    // https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files)\n    // This aligns with TensorFlow Core code:\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/4213d5c1bd921f8d5b7b2dc4bbf1eea78d0b5258/tensorflow/core/kernels/decode_image_op.cc#L44\n    if (content.length > 3 && content[0] === 255 && content[1] === 216 &&\n        content[2] === 255) {\n        // JPEG byte chunk starts with `ff d8 ff`\n        return ImageType.JPEG;\n    }\n    else if (content.length > 4 && content[0] === 71 && content[1] === 73 &&\n        content[2] === 70 && content[3] === 56) {\n        // GIF byte chunk starts with `47 49 46 38`\n        return ImageType.GIF;\n    }\n    else if (content.length > 8 && content[0] === 137 && content[1] === 80 &&\n        content[2] === 78 && content[3] === 71 && content[4] === 13 &&\n        content[5] === 10 && content[6] === 26 && content[7] === 10) {\n        // PNG byte chunk starts with `\\211 P N G \\r \\n \\032 \\n (89 50 4E 47 0D 0A\n        // 1A 0A)`\n        return ImageType.PNG;\n    }\n    else if (content.length > 3 && content[0] === 66 && content[1] === 77) {\n        // BMP byte chunk starts with `42 4d`\n        return ImageType.BMP;\n    }\n    else {\n        throw new Error('Expected image (JPEG, PNG, or GIF), but got unsupported image type');\n    }\n}\n//# sourceMappingURL=decode_image.js.map"]},"metadata":{},"sourceType":"script"}