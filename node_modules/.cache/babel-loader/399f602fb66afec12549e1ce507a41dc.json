{"ast":null,"code":"import { All, Each, Flush, Column, X, Y, Row, Middle, End, Group, AxisRole, LegendRole, TitleRole, RowHeader, RowFooter, RowTitle, ColHeader, ColFooter, ColTitle } from '../constants';\nimport { tempBounds } from './util';\nimport { Bounds } from 'vega-scenegraph';\nimport { isObject } from 'vega-util';\n\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n      n = groups.length,\n      i = 0,\n      mark,\n      items;\n  var views = {\n    marks: [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  }; // layout axes, gather legends, collect bounds\n\n  for (; i < n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n\n        case RowHeader:\n          views.rowheaders.push(...items);\n          break;\n\n        case RowFooter:\n          views.rowfooters.push(...items);\n          break;\n\n        case ColHeader:\n          views.colheaders.push(...items);\n          break;\n\n        case ColFooter:\n          views.colfooters.push(...items);\n          break;\n\n        case RowTitle:\n          views.rowtitle = items[0];\n          break;\n\n        case ColTitle:\n          views.coltitle = items[0];\n          break;\n\n        default:\n          views.marks.push(...items);\n      }\n    }\n  }\n\n  return views;\n}\n\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\n\nfunction bboxFull(item) {\n  var b = item.bounds.clone();\n  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));\n}\n\nfunction get(opt, key, d) {\n  var v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : d !== undefined ? d : 0;\n}\n\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\n\nexport function gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n      bounds = tempBounds.set(0, 0, 0, 0),\n      alignCol = get(opt.align, Column),\n      alignRow = get(opt.align, Row),\n      padCol = get(opt.padding, Column),\n      padRow = get(opt.padding, Row),\n      ncols = opt.columns || groups.length,\n      nrows = ncols < 0 ? 1 : Math.ceil(groups.length / ncols),\n      n = groups.length,\n      xOffset = Array(n),\n      xExtent = Array(ncols),\n      xMax = 0,\n      yOffset = Array(n),\n      yExtent = Array(nrows),\n      yMax = 0,\n      dx = Array(n),\n      dy = Array(n),\n      boxes = Array(n),\n      m,\n      i,\n      c,\n      r,\n      b,\n      g,\n      px,\n      py,\n      x,\n      y,\n      offset;\n\n  for (i = 0; i < ncols; ++i) xExtent[i] = 0;\n\n  for (i = 0; i < nrows; ++i) yExtent[i] = 0; // determine offsets for each group\n\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0;\n    dx[i] = 0;\n    g.y = g.y || 0;\n    dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  } // set initial alignment offsets\n\n\n  for (i = 0; i < n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  } // enforce column alignment constraints\n\n\n  if (alignCol === Each) {\n    for (c = 1; c < ncols; ++c) {\n      for (offset = 0, i = c; i < n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] = offset + xExtent[c - 1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset = 0, i = 0; i < n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n\n    for (i = 0; i < n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol = false, c = 1; c < ncols; ++c) {\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] += xExtent[c - 1];\n      }\n    }\n  } // enforce row alignment constraints\n\n\n  if (alignRow === Each) {\n    for (r = 1; r < nrows; ++r) {\n      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n\n      for (i = r * ncols; i < m; ++i) {\n        yOffset[i] = offset + yExtent[r - 1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset = 0, i = ncols; i < n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n\n    for (i = ncols; i < n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow = false, r = 1; r < nrows; ++r) {\n      for (i = r * ncols, m = i + ncols; i < m; ++i) {\n        yOffset[i] += yExtent[r - 1];\n      }\n    }\n  } // perform horizontal grid layout\n\n\n  for (x = 0, i = 0; i < n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  } // perform vertical grid layout\n\n\n  for (c = 0; c < ncols; ++c) {\n    for (y = 0, i = c; i < n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  } // perform horizontal centering\n\n\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  } // perform vertical centering\n\n\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  } // position grid relative to anchor\n\n\n  for (i = 0; i < n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n\n  switch (get(opt.anchor, Column)) {\n    case End:\n      x -= bounds.width();\n      break;\n\n    case Middle:\n      x -= bounds.width() / 2;\n  }\n\n  switch (get(opt.anchor, Row)) {\n    case End:\n      y -= bounds.height();\n      break;\n\n    case Middle:\n      y -= bounds.height() / 2;\n  }\n\n  x = Math.round(x);\n  y = Math.round(y); // update mark positions, bounds, dirty\n\n  bounds.clear();\n\n  for (i = 0; i < n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    g.x += dx[i] += x;\n    g.y += dy[i] += y;\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n\n  return bounds;\n}\nexport function trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n      groups = views.marks,\n      bbox = opt.bounds === Flush ? boundFlush : boundFull,\n      off = opt.offset,\n      ncols = opt.columns || groups.length,\n      nrows = ncols < 0 ? 1 : Math.ceil(groups.length / ncols),\n      cells = nrows * ncols,\n      x,\n      y,\n      x2,\n      y2,\n      anchor,\n      band,\n      offset; // -- initial grid layout\n\n  const bounds = gridLayout(view, groups, opt); // -- layout grid headers and footers --\n  // perform row header layout\n\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  } // perform column header layout\n\n\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  } // perform row footer layout\n\n\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);\n  } // perform column footer layout\n\n\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);\n  } // perform row title layout\n\n\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  } // perform column title layout\n\n\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\n\nfunction boundFlush(item, field) {\n  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;\n}\n\nfunction boundFull(item, field) {\n  return item.bounds[field];\n} // aggregation functions for grid margin determination\n\n\nfunction min(a, b) {\n  return Math.floor(Math.min(a, b));\n}\n\nfunction max(a, b) {\n  return Math.ceil(Math.max(a, b));\n}\n\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n      init = 0,\n      edge = 0,\n      i,\n      j,\n      k,\n      m,\n      b,\n      h,\n      g,\n      x,\n      y; // if no groups, early exit and return 0\n\n  if (!n) return init; // compute margin\n\n  for (i = start; i < n; i += stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  } // if no headers, return margin calculation\n\n\n  if (!headers.length) return init; // check if number of headers exceeds number of rows or columns\n\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  } // apply offset\n\n\n  init += offset; // clear mark bounds for all headers\n\n  for (j = 0, m = headers.length; j < m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  } // layout each header\n\n\n  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {\n    h = headers[j];\n    b = h.mark.bounds; // search for nearest group to align to\n    // necessary if table has empty cells\n\n    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back); // assign coordinates and update bounds\n\n\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h); // update current edge of layout bounds\n\n    edge = agg(edge, b[bf]);\n  }\n\n  return edge;\n}\n\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g); // compute title coordinates\n\n  var x = offset,\n      y = offset;\n  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height()); // assign coordinates and update bounds\n\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y; // queue title for redraw\n\n  view.dirty(g);\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-view-transforms/src/layout/grid.js"],"names":["All","Each","Flush","Column","X","Y","Row","Middle","End","Group","AxisRole","LegendRole","TitleRole","RowHeader","RowFooter","RowTitle","ColHeader","ColFooter","ColTitle","tempBounds","Bounds","isObject","gridLayoutGroups","group","groups","items","n","length","i","mark","views","marks","rowheaders","rowfooters","colheaders","colfooters","rowtitle","coltitle","marktype","role","push","bboxFlush","item","set","width","height","bboxFull","b","bounds","clone","empty","translate","x","y","get","opt","key","d","v","undefined","offsetValue","Math","ceil","gridLayout","view","dirty","nodirty","bbox","alignCol","align","alignRow","padCol","padding","padRow","ncols","columns","nrows","xOffset","Array","xExtent","xMax","yOffset","yExtent","yMax","dx","dy","boxes","m","c","r","g","px","py","offset","max","x2","y2","x1","y1","center","union","anchor","round","clear","trellisLayout","boundFlush","boundFull","off","cells","band","headerBand","layoutHeaders","min","footerBand","titleAnchor","titleBand","layoutTitle","field","a","floor","headers","limit","agg","isX","bound","bf","start","stride","back","init","edge","j","k","h","warn","slice"],"mappings":"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","sourcesContent":["import {\n  All, Each, Flush, Column, X, Y, Row, Middle, End,\n  Group, AxisRole, LegendRole, TitleRole,\n  RowHeader, RowFooter, RowTitle,\n  ColHeader, ColFooter, ColTitle\n} from '../constants';\nimport {tempBounds} from './util';\nimport {Bounds} from 'vega-scenegraph';\nimport {isObject} from 'vega-util';\n\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n      n = groups.length,\n      i = 0, mark, items;\n\n  var views = {\n    marks:      [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  };\n\n  // layout axes, gather legends, collect bounds\n  for (; i<n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n        case RowHeader: views.rowheaders.push(...items); break;\n        case RowFooter: views.rowfooters.push(...items); break;\n        case ColHeader: views.colheaders.push(...items); break;\n        case ColFooter: views.colfooters.push(...items); break;\n        case RowTitle:  views.rowtitle = items[0]; break;\n        case ColTitle:  views.coltitle = items[0]; break;\n        default:        views.marks.push(...items);\n      }\n    }\n  }\n\n  return views;\n}\n\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\n\nfunction bboxFull(item) {\n  var b = item.bounds.clone();\n  return b.empty()\n    ? b.set(0, 0, 0, 0)\n    : b.translate(-(item.x || 0), -(item.y || 0));\n}\n\nfunction get(opt, key, d) {\n  var v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : (d !== undefined ? d : 0);\n}\n\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\n\nexport function gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n      bounds = tempBounds.set(0, 0, 0, 0),\n      alignCol = get(opt.align, Column),\n      alignRow = get(opt.align, Row),\n      padCol = get(opt.padding, Column),\n      padRow = get(opt.padding, Row),\n      ncols = opt.columns || groups.length,\n      nrows = ncols < 0 ? 1 : Math.ceil(groups.length / ncols),\n      n = groups.length,\n      xOffset = Array(n), xExtent = Array(ncols), xMax = 0,\n      yOffset = Array(n), yExtent = Array(nrows), yMax = 0,\n      dx = Array(n), dy = Array(n), boxes = Array(n),\n      m, i, c, r, b, g, px, py, x, y, offset;\n\n  for (i=0; i<ncols; ++i) xExtent[i] = 0;\n  for (i=0; i<nrows; ++i) yExtent[i] = 0;\n\n  // determine offsets for each group\n  for (i=0; i<n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0; dx[i] = 0;\n    g.y = g.y || 0; dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  }\n\n  // set initial alignment offsets\n  for (i=0; i<n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  }\n\n  // enforce column alignment constraints\n  if (alignCol === Each) {\n    for (c=1; c<ncols; ++c) {\n      for (offset=0, i=c; i<n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n      for (i=c; i<n; i += ncols) {\n        xOffset[i] = offset + xExtent[c-1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset=0, i=0; i<n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n    for (i=0; i<n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol=false, c=1; c<ncols; ++c) {\n      for (i=c; i<n; i += ncols) {\n        xOffset[i] += xExtent[c-1];\n      }\n    }\n  }\n\n  // enforce row alignment constraints\n  if (alignRow === Each) {\n    for (r=1; r<nrows; ++r) {\n      for (offset=0, i=r*ncols, m=i+ncols; i<m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n      for (i=r*ncols; i<m; ++i) {\n        yOffset[i] = offset + yExtent[r-1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset=0, i=ncols; i<n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n    for (i=ncols; i<n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow=false, r=1; r<nrows; ++r) {\n      for (i=r*ncols, m=i+ncols; i<m; ++i) {\n        yOffset[i] += yExtent[r-1];\n      }\n    }\n  }\n\n  // perform horizontal grid layout\n  for (x=0, i=0; i<n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  }\n\n  // perform vertical grid layout\n  for (c=0; c<ncols; ++c) {\n    for (y=0, i=c; i<n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  }\n\n  // perform horizontal centering\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i=0; i<n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  }\n\n  // perform vertical centering\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i=0; i<n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  }\n\n  // position grid relative to anchor\n  for (i=0; i<n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n  switch (get(opt.anchor, Column)) {\n    case End:    x -= bounds.width(); break;\n    case Middle: x -= bounds.width() / 2;\n  }\n  switch (get(opt.anchor, Row)) {\n    case End:    y -= bounds.height(); break;\n    case Middle: y -= bounds.height() / 2;\n  }\n  x = Math.round(x);\n  y = Math.round(y);\n\n  // update mark positions, bounds, dirty\n  bounds.clear();\n  for (i=0; i<n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n  for (i=0; i<n; ++i) {\n    g = groups[i];\n    g.x += (dx[i] += x);\n    g.y += (dy[i] += y);\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n\n  return bounds;\n}\n\nexport function trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n      groups = views.marks,\n      bbox = opt.bounds === Flush ? boundFlush : boundFull,\n      off = opt.offset,\n      ncols = opt.columns || groups.length,\n      nrows = ncols < 0 ? 1 : Math.ceil(groups.length / ncols),\n      cells = nrows * ncols,\n      x, y, x2, y2, anchor, band, offset;\n\n  // -- initial grid layout\n  const bounds = gridLayout(view, groups, opt);\n\n  // -- layout grid headers and footers --\n\n  // perform row header layout\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  }\n\n  // perform column header layout\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  }\n\n  // perform row footer layout\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows,  get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols-1, ncols, 1, band);\n  }\n\n  // perform column footer layout\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols,  get(off, 'columnFooter'), max, 1, bbox, 'y2', cells-ncols, 1, ncols, band);\n  }\n\n  // perform row title layout\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  }\n\n  // perform column title layout\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\n\nfunction boundFlush(item, field) {\n  return field === 'x1' ? (item.x || 0)\n    : field === 'y1' ? (item.y || 0)\n    : field === 'x2' ? (item.x || 0) + (item.width || 0)\n    : field === 'y2' ? (item.y || 0) + (item.height || 0)\n    : undefined;\n}\n\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\n\n// aggregation functions for grid margin determination\nfunction min(a, b) { return Math.floor(Math.min(a, b)); }\nfunction max(a, b) { return Math.ceil(Math.max(a, b)); }\n\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n      init = 0,\n      edge = 0,\n      i, j, k, m, b, h, g, x, y;\n\n  // if no groups, early exit and return 0\n  if (!n) return init;\n\n  // compute margin\n  for (i=start; i<n; i+=stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  }\n\n  // if no headers, return margin calculation\n  if (!headers.length) return init;\n\n  // check if number of headers exceeds number of rows or columns\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  }\n\n  // apply offset\n  init += offset;\n\n  // clear mark bounds for all headers\n  for (j=0, m=headers.length; j<m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  }\n\n  // layout each header\n  for (i=start, j=0, m=headers.length; j<m; ++j, i+=stride) {\n    h = headers[j];\n    b = h.mark.bounds;\n\n    // search for nearest group to align to\n    // necessary if table has empty cells\n    for (k=i; k >= 0 && (g = groups[k]) == null; k-=back);\n\n    // assign coordinates and update bounds\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h);\n\n    // update current edge of layout bounds\n    edge = agg(edge, b[bf]);\n  }\n\n  return edge;\n}\n\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g);\n\n  // compute title coordinates\n  var x = offset, y = offset;\n  isX\n    ? (x = Math.round(bounds.x1 + band * bounds.width()))\n    : (y = Math.round(bounds.y1 + band * bounds.height()));\n\n  // assign coordinates and update bounds\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y;\n\n  // queue title for redraw\n  view.dirty(g);\n}\n"]},"metadata":{},"sourceType":"module"}