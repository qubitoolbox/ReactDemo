{"ast":null,"code":"import parseExpression from './expression';\nimport { entry, fieldRef, isSignal, ref } from '../util';\nimport { Params } from '../transforms';\nimport { definition } from 'vega-dataflow';\nimport { error, extend, isArray, isString, stringValue } from 'vega-util';\n/**\n * Parse a data transform specification.\n */\n\nexport default function (spec, scope) {\n  var def = definition(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  var t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n/**\n * Parse all parameters of a data transform.\n */\n\nfunction parseParameters(def, spec, scope) {\n  var params = {},\n      pdef,\n      i,\n      n;\n\n  for (i = 0, n = def.params.length; i < n; ++i) {\n    pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n\n  return params;\n}\n/**\n * Parse a data transform parameter.\n */\n\n\nfunction parseParameter(def, spec, scope) {\n  var type = def.type,\n      value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value) ? value.map(function (v) {\n    return parameterValue(def, v, scope);\n  }) : parameterValue(def, value, scope);\n}\n/**\n * Parse a single parameter value.\n */\n\n\nfunction parameterValue(def, value, scope) {\n  var type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    var expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef(value.field, value.as) : isExpr(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n/**\n * Parse parameter for accessing an index of another data set.\n */\n\n\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\n\n\nfunction parseSubParameters(def, spec, scope) {\n  var value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n\n    return value.map(function (v) {\n      return parseSubParameter(def, v, scope);\n    });\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n/**\n * Parse a sub-parameter object.\n */\n\n\nfunction parseSubParameter(def, value, scope) {\n  var params, pdef, k, i, n; // loop over defs to find matching key\n\n  for (i = 0, n = def.params.length; i < n; ++i) {\n    pdef = def.params[i];\n\n    for (k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n\n    if (pdef) break;\n  } // raise error if matching key not found\n\n\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value)); // parse params, create Params transform, return ref\n\n  params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n} // -- Utilities -----\n\n\nexport function outerExpr(_) {\n  return _ && _.expr;\n}\nexport function outerField(_) {\n  return _ && _.field;\n}\nexport function isData(_) {\n  return _ === 'data';\n}\nexport function isExpr(_) {\n  return _ === 'expr';\n}\nexport function isField(_) {\n  return _ === 'field';\n}\nexport function isCompare(_) {\n  return _ === 'compare';\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/transform.js"],"names":["parseExpression","entry","fieldRef","isSignal","ref","Params","definition","error","extend","isArray","isString","stringValue","spec","scope","def","type","t","toLowerCase","parseParameters","signal","addSignal","proxy","metadata","params","pdef","i","n","length","name","parseParameter","value","parseIndexParameter","undefined","required","parseSubParameters","projectionRef","array","map","v","parameterValue","isExpr","isField","isCompare","compareRef","signalRef","expr","outerExpr","exprRef","as","outerField","field","isData","getData","values","from","lookupRef","key","parseSubParameter","k","add","_"],"mappings":"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","sourcesContent":["import parseExpression from './expression';\nimport {entry, fieldRef, isSignal, ref} from '../util';\nimport {Params} from '../transforms';\nimport {definition} from 'vega-dataflow';\nimport {error, extend, isArray, isString, stringValue} from 'vega-util';\n\n/**\n * Parse a data transform specification.\n */\nexport default function(spec, scope) {\n  var def = definition(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n\n  var t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n\n  return t;\n}\n\n/**\n * Parse all parameters of a data transform.\n */\nfunction parseParameters(def, spec, scope) {\n  var params = {}, pdef, i, n;\n  for (i=0, n=def.params.length; i<n; ++i) {\n    pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n  return params;\n}\n\n/**\n * Parse a data transform parameter.\n */\nfunction parseParameter(def, spec, scope) {\n  var type = def.type,\n      value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type)\n          + ' parameter: ' + stringValue(def.name));\n    }\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value)\n    ? value.map(function(v) { return parameterValue(def, v, scope); })\n    : parameterValue(def, value, scope);\n}\n\n/**\n * Parse a single parameter value.\n */\nfunction parameterValue(def, value, scope) {\n  var type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.')\n         : isField(type) ? scope.fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : scope.signalRef(value.signal);\n  } else {\n    var expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as)\n         : expr && outerField(value) ? fieldRef(value.field, value.as)\n         : isExpr(type) ? parseExpression(value, scope)\n         : isData(type) ? ref(scope.getData(value).values)\n         : isField(type) ? fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : value;\n  }\n}\n\n/**\n * Parse parameter for accessing an index of another data set.\n */\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\nfunction parseSubParameters(def, spec, scope) {\n  var value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) { // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n    return value.map(function(v) {\n      return parseSubParameter(def, v, scope);\n    });\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n\n/**\n * Parse a sub-parameter object.\n */\nfunction parseSubParameter(def, value, scope) {\n  var params, pdef, k, i, n;\n\n  // loop over defs to find matching key\n  for (i=0, n=def.params.length; i<n; ++i) {\n    pdef = def.params[i];\n    for (k in pdef.key) {\n      if (pdef.key[k] !== value[k]) { pdef = null; break; }\n    }\n    if (pdef) break;\n  }\n  // raise error if matching key not found\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value));\n\n  // parse params, create Params transform, return ref\n  params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n}\n\n// -- Utilities -----\n\nexport function outerExpr(_) {\n  return _ && _.expr;\n}\n\nexport function outerField(_) {\n  return _ && _.field;\n}\n\nexport function isData(_) {\n  return _ === 'data';\n}\n\nexport function isExpr(_) {\n  return _ === 'expr';\n}\n\nexport function isField(_) {\n  return _ === 'field';\n}\n\nexport function isCompare(_) {\n  return _ === 'compare'\n}\n"]},"metadata":{},"sourceType":"module"}