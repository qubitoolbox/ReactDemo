{"ast":null,"code":"import { isArray, isNumber } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLOR, FILL, FILLOPACITY, OPACITY, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEOPACITY, STROKEWIDTH, X, Y } from '../../channel';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { isStep } from '../../spec/base';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nexport const RANGE_PROPERTIES = ['range', 'scheme'];\n\nfunction getSizeType(channel) {\n  return channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n}\n\nexport function parseUnitScaleRange(model) {\n  const localScaleComponents = model.component.scales; // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n\n  SCALE_CHANNELS.forEach(channel => {\n    const localScaleCmpt = localScaleComponents[channel];\n\n    if (!localScaleCmpt) {\n      return;\n    }\n\n    const rangeWithExplicit = parseRangeForChannel(channel, model);\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  });\n}\n\nfunction getBinStepSignal(model, channel) {\n  const fieldDef = model.fieldDef(channel);\n\n  if (fieldDef && fieldDef.bin && isBinning(fieldDef.bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, fieldDef.bin); // TODO: extract this to be range step signal\n\n    const sizeType = getSizeType(channel);\n    const sizeSignal = model.getName(sizeType);\n    return new SignalRefWrapper(() => {\n      const updatedName = model.getSignalName(binSignal);\n      const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n      return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n    });\n  }\n\n  return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\n\n\nexport function parseRangeForChannel(channel, model) {\n  const specifiedScale = model.specifiedScales[channel];\n  const {\n    size\n  } = model;\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type'); // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            return makeExplicit(specifiedScale[property]);\n\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n        }\n      }\n    }\n  }\n\n  if (channel === X || channel === Y) {\n    const sizeChannel = channel === X ? 'width' : 'height';\n    const sizeValue = size[sizeChannel];\n\n    if (isStep(sizeValue)) {\n      if (hasDiscreteDomain(scaleType)) {\n        return makeExplicit({\n          step: sizeValue.step\n        });\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    }\n  }\n\n  return makeImplicit(defaultRange(channel, model));\n}\n\nfunction parseScheme(scheme) {\n  if (isExtendedScheme(scheme)) {\n    return Object.assign({\n      scheme: scheme.name\n    }, util.omit(scheme, ['name']));\n  }\n\n  return {\n    scheme: scheme\n  };\n}\n\nfunction defaultRange(channel, model) {\n  const {\n    size,\n    config,\n    mark\n  } = model;\n  const getSignalName = model.getSignalName.bind(model);\n  const {\n    type\n  } = model.fieldDef(channel);\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n  const {\n    domain\n  } = model.specifiedScales[channel];\n\n  switch (channel) {\n    case X:\n    case Y:\n      {\n        // If there is no explicit width/height for discrete x/y scales\n        if (util.contains(['point', 'band'], scaleType)) {\n          if (channel === X && !size.width) {\n            const w = getViewConfigDiscreteSize(config.view, 'width');\n\n            if (isStep(w)) {\n              return w;\n            }\n          } else if (channel === Y && !size.height) {\n            const h = getViewConfigDiscreteSize(config.view, 'height');\n\n            if (isStep(h)) {\n              return h;\n            }\n          }\n        } // If step is null, use zero to width or height.\n        // Note that these range signals are temporary\n        // as they can be merged and renamed.\n        // (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)\n        // We will later replace these temporary names with\n        // the final name in assembleScaleRange()\n\n\n        const sizeType = getSizeType(channel);\n        const sizeSignal = model.getName(sizeType);\n\n        if (channel === Y && hasContinuousDomain(scaleType)) {\n          // For y continuous scale, we have to start from the height as the bottom part has the max value.\n          return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n        } else {\n          return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n        }\n      }\n\n    case SIZE:\n      {\n        // TODO: support custom rangeMin, rangeMax\n        const zero = model.component.scales[channel].get('zero');\n        const rangeMin = sizeRangeMin(mark, zero, config);\n        const rangeMax = sizeRangeMax(mark, size, model, config);\n\n        if (isContinuousToDiscrete(scaleType)) {\n          return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n        } else {\n          return [rangeMin, rangeMax];\n        }\n      }\n\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n\n    case SHAPE:\n      return 'symbol';\n\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n      }\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n  /* istanbul ignore next: should never reach here */\n\n\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n\n    case 'quantize':\n      return config.scale.quantizeCount;\n\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel)); // default threshold boundaries for threshold scale since domain has cardinality of 2\n\n        return 3;\n      }\n\n  }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\n\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n  // always return a signal since it's better to compute the sequence in Vega later\n  const f = () => {\n    const rMax = isSignalRef(rangeMax) ? rangeMax.signal : rangeMax;\n    const step = `(${rMax} - ${rangeMin}) / (${cardinality} - 1)`;\n    return `sequence(${rangeMin}, ${rangeMax} + ${step}, ${step})`;\n  };\n\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {\n      signal: f()\n    };\n  }\n}\n\nfunction sizeRangeMin(mark, zero, config) {\n  if (zero) {\n    return 0;\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n\n    case 'text':\n      return config.scale.minFontSize;\n\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n\n\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\n\nfunction sizeRangeMax(mark, size, model, config) {\n  const xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      {\n        if (config.scale.maxBandSize !== undefined) {\n          return config.scale.maxBandSize;\n        }\n\n        const min = minXYStep(size, xyStepSignals, config.view);\n\n        if (isNumber(min)) {\n          return min - 1;\n        } else {\n          return new SignalRefWrapper(() => `${min.signal} - 1`);\n        }\n      }\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n\n    case 'text':\n      return config.scale.maxFontSize;\n\n    case 'point':\n    case 'square':\n    case 'circle':\n      {\n        if (config.scale.maxSize) {\n          return config.scale.maxSize;\n        }\n\n        const pointStep = minXYStep(size, xyStepSignals, config.view);\n\n        if (isNumber(pointStep)) {\n          return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n        } else {\n          return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n        }\n      }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n\n\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\n\n\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(() => {\n      const exprs = [xyStepSignals.x ? xyStepSignals.x.signal : widthStep, xyStepSignals.y ? xyStepSignals.y.signal : heightStep];\n      return `min(${exprs.join(', ')})`;\n    });\n  }\n\n  return Math.min(widthStep, heightStep);\n}","map":{"version":3,"sources":["../../../../src/compile/scale/range.ts"],"names":[],"mappings":"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","sourcesContent":["import {RangeScheme, SignalRef} from 'vega';\nimport {isArray, isNumber} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {\n  Channel,\n  COLOR,\n  FILL,\n  FILLOPACITY,\n  OPACITY,\n  ScaleChannel,\n  SCALE_CHANNELS,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEOPACITY,\n  STROKEWIDTH,\n  X,\n  Y\n} from '../../channel';\nimport {Config, getViewConfigDiscreteSize, getViewConfigDiscreteStep, ViewConfig} from '../../config';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  hasDiscreteDomain,\n  isContinuousToDiscrete,\n  isExtendedScheme,\n  Scale,\n  scaleTypeSupportProperty,\n  Scheme\n} from '../../scale';\nimport {isStep, LayoutSizeMixins} from '../../spec/base';\nimport * as util from '../../util';\nimport {isSignalRef, VgRange} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {SignalRefWrapper} from '../signal';\nimport {Explicit, makeExplicit, makeImplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\n\nexport const RANGE_PROPERTIES: (keyof Scale)[] = ['range', 'scheme'];\n\nfunction getSizeType(channel: ScaleChannel) {\n  return channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n}\n\nexport function parseUnitScaleRange(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  SCALE_CHANNELS.forEach((channel: ScaleChannel) => {\n    const localScaleCmpt = localScaleComponents[channel];\n    if (!localScaleCmpt) {\n      return;\n    }\n\n    const rangeWithExplicit = parseRangeForChannel(channel, model);\n\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  });\n}\n\nfunction getBinStepSignal(model: UnitModel, channel: 'x' | 'y'): SignalRefWrapper {\n  const fieldDef = model.fieldDef(channel);\n\n  if (fieldDef && fieldDef.bin && isBinning(fieldDef.bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, fieldDef.bin);\n\n    // TODO: extract this to be range step signal\n    const sizeType = getSizeType(channel);\n    const sizeSignal = model.getName(sizeType);\n    return new SignalRefWrapper(() => {\n      const updatedName = model.getSignalName(binSignal);\n      const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n      return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n    });\n  }\n  return undefined;\n}\n\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\nexport function parseRangeForChannel(channel: ScaleChannel, model: UnitModel): Explicit<VgRange> {\n  const specifiedScale = model.specifiedScales[channel];\n  const {size} = model;\n\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            return makeExplicit(specifiedScale[property]);\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n        }\n      }\n    }\n  }\n\n  if (channel === X || channel === Y) {\n    const sizeChannel = channel === X ? 'width' : 'height';\n    const sizeValue = size[sizeChannel];\n    if (isStep(sizeValue)) {\n      if (hasDiscreteDomain(scaleType)) {\n        return makeExplicit({step: sizeValue.step});\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    }\n  }\n\n  return makeImplicit(defaultRange(channel, model));\n}\n\nfunction parseScheme(scheme: Scheme): RangeScheme {\n  if (isExtendedScheme(scheme)) {\n    return {\n      scheme: scheme.name,\n      ...util.omit(scheme, ['name'])\n    };\n  }\n  return {scheme: scheme};\n}\n\nfunction defaultRange(channel: ScaleChannel, model: UnitModel): VgRange {\n  const {size, config, mark} = model;\n\n  const getSignalName = model.getSignalName.bind(model);\n\n  const {type} = model.fieldDef(channel);\n\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n\n  const {domain} = model.specifiedScales[channel];\n\n  switch (channel) {\n    case X:\n    case Y: {\n      // If there is no explicit width/height for discrete x/y scales\n      if (util.contains(['point', 'band'], scaleType)) {\n        if (channel === X && !size.width) {\n          const w = getViewConfigDiscreteSize(config.view, 'width');\n          if (isStep(w)) {\n            return w;\n          }\n        } else if (channel === Y && !size.height) {\n          const h = getViewConfigDiscreteSize(config.view, 'height');\n          if (isStep(h)) {\n            return h;\n          }\n        }\n      }\n\n      // If step is null, use zero to width or height.\n      // Note that these range signals are temporary\n      // as they can be merged and renamed.\n      // (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)\n      // We will later replace these temporary names with\n      // the final name in assembleScaleRange()\n\n      const sizeType = getSizeType(channel);\n      const sizeSignal = model.getName(sizeType);\n\n      if (channel === Y && hasContinuousDomain(scaleType)) {\n        // For y continuous scale, we have to start from the height as the bottom part has the max value.\n        return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n      } else {\n        return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n      }\n    }\n    case SIZE: {\n      // TODO: support custom rangeMin, rangeMax\n      const zero = model.component.scales[channel].get('zero');\n      const rangeMin = sizeRangeMin(mark, zero, config);\n      const rangeMax = sizeRangeMax(mark, size, model, config);\n      if (isContinuousToDiscrete(scaleType)) {\n        return interpolateRange(\n          rangeMin,\n          rangeMax,\n          defaultContinuousToDiscreteCount(scaleType, config, domain, channel)\n        );\n      } else {\n        return [rangeMin, rangeMax];\n      }\n    }\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n      }\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n  /* istanbul ignore next: should never reach here */\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nexport function defaultContinuousToDiscreteCount(\n  scaleType: 'quantile' | 'quantize' | 'threshold',\n  config: Config,\n  domain: Domain,\n  channel: Channel\n) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n    case 'quantize':\n      return config.scale.quantizeCount;\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel));\n        // default threshold boundaries for threshold scale since domain has cardinality of 2\n        return 3;\n      }\n  }\n}\n\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin: number, rangeMax: number | SignalRef, cardinality: number): SignalRef {\n  // always return a signal since it's better to compute the sequence in Vega later\n  const f = () => {\n    const rMax = isSignalRef(rangeMax) ? rangeMax.signal : rangeMax;\n    const step = `(${rMax} - ${rangeMin}) / (${cardinality} - 1)`;\n    return `sequence(${rangeMin}, ${rangeMax} + ${step}, ${step})`;\n  };\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {signal: f()};\n  }\n}\n\nfunction sizeRangeMin(mark: Mark, zero: boolean, config: Config) {\n  if (zero) {\n    return 0;\n  }\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\n\nfunction sizeRangeMax(mark: Mark, size: LayoutSizeMixins, model: UnitModel, config: Config): number | SignalRef {\n  const xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n\n  switch (mark) {\n    case 'bar':\n    case 'tick': {\n      if (config.scale.maxBandSize !== undefined) {\n        return config.scale.maxBandSize;\n      }\n      const min = minXYStep(size, xyStepSignals, config.view);\n\n      if (isNumber(min)) {\n        return min - 1;\n      } else {\n        return new SignalRefWrapper(() => `${min.signal} - 1`);\n      }\n    }\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle': {\n      if (config.scale.maxSize) {\n        return config.scale.maxSize;\n      }\n\n      const pointStep = minXYStep(size, xyStepSignals, config.view);\n      if (isNumber(pointStep)) {\n        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n      } else {\n        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n      }\n    }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYStep(\n  size: LayoutSizeMixins,\n  xyStepSignals: {x?: SignalRefWrapper; y?: SignalRefWrapper},\n  viewConfig: ViewConfig\n): number | SignalRef {\n  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(() => {\n      const exprs = [\n        xyStepSignals.x ? xyStepSignals.x.signal : widthStep,\n        xyStepSignals.y ? xyStepSignals.y.signal : heightStep\n      ];\n      return `min(${exprs.join(', ')})`;\n    });\n  }\n\n  return Math.min(widthStep, heightStep);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}