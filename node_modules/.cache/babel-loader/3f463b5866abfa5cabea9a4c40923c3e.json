{"ast":null,"code":"import { getDataRef } from './data';\nimport parseSpec from '../spec';\nimport DataScope from '../../DataScope';\nimport { ref } from '../../util';\nimport { Collect, Facet, PreFacet, Sieve } from '../../transforms';\nimport { error, stringValue } from 'vega-util';\nexport default function (spec, scope, group) {\n  var facet = spec.from.facet,\n      name = facet.name,\n      data = getDataRef(facet, scope),\n      subscope,\n      source,\n      values,\n      op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  } // initialize facet subscope\n\n\n  subscope = scope.fork();\n  source = subscope.add(Collect());\n  values = subscope.add(Sieve({\n    pulse: ref(source)\n  }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null); // parse faceted subflow\n\n  op.params.subflow = {\n    $subflow: parseSpec(spec, subscope).toRuntime()\n  };\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/marks/facet.js"],"names":["getDataRef","parseSpec","DataScope","ref","Collect","Facet","PreFacet","Sieve","error","stringValue","spec","scope","group","facet","from","name","data","subscope","source","values","op","field","add","fieldRef","pulse","groupby","key","keyRef","proxy","parent","fork","addData","addSignal","params","subflow","$subflow","toRuntime"],"mappings":"AAAA,SAAQA,UAAR,QAAyB,QAAzB;AACA,OAAOC,SAAP,MAAsB,SAAtB;AACA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,SAAQC,GAAR,QAAkB,YAAlB;AACA,SAAQC,OAAR,EAAiBC,KAAjB,EAAwBC,QAAxB,EAAkCC,KAAlC,QAA8C,kBAA9C;AACA,SAAQC,KAAR,EAAeC,WAAf,QAAiC,WAAjC;AAEA,eAAe,UAASC,IAAT,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AAC1C,MAAIC,KAAK,GAAGH,IAAI,CAACI,IAAL,CAAUD,KAAtB;AAAA,MACIE,IAAI,GAAGF,KAAK,CAACE,IADjB;AAAA,MAEIC,IAAI,GAAGhB,UAAU,CAACa,KAAD,EAAQF,KAAR,CAFrB;AAAA,MAGIM,QAHJ;AAAA,MAGcC,MAHd;AAAA,MAGsBC,MAHtB;AAAA,MAG8BC,EAH9B;;AAKA,MAAI,CAACP,KAAK,CAACE,IAAX,EAAiB;AACfP,IAAAA,KAAK,CAAC,6BAA6BC,WAAW,CAACI,KAAD,CAAzC,CAAL;AACD;;AACD,MAAI,CAACA,KAAK,CAACG,IAAX,EAAiB;AACfR,IAAAA,KAAK,CAAC,sCAAsCC,WAAW,CAACI,KAAD,CAAlD,CAAL;AACD;;AAED,MAAIA,KAAK,CAACQ,KAAV,EAAiB;AACfD,IAAAA,EAAE,GAAGT,KAAK,CAACW,GAAN,CAAUhB,QAAQ,CAAC;AACtBe,MAAAA,KAAK,EAAEV,KAAK,CAACY,QAAN,CAAeV,KAAK,CAACQ,KAArB,CADe;AAEtBG,MAAAA,KAAK,EAAER;AAFe,KAAD,CAAlB,CAAL;AAID,GALD,MAKO,IAAIH,KAAK,CAACY,OAAV,EAAmB;AACxBL,IAAAA,EAAE,GAAGT,KAAK,CAACW,GAAN,CAAUjB,KAAK,CAAC;AACnBqB,MAAAA,GAAG,EAAIf,KAAK,CAACgB,MAAN,CAAad,KAAK,CAACY,OAAnB,CADY;AAEnBb,MAAAA,KAAK,EAAET,GAAG,CAACQ,KAAK,CAACiB,KAAN,CAAYhB,KAAK,CAACiB,MAAlB,CAAD,CAFS;AAGnBL,MAAAA,KAAK,EAAER;AAHY,KAAD,CAAf,CAAL;AAKD,GANM,MAMA;AACLR,IAAAA,KAAK,CAAC,0CAA0CC,WAAW,CAACI,KAAD,CAAtD,CAAL;AACD,GA1ByC,CA4B1C;;;AACAI,EAAAA,QAAQ,GAAGN,KAAK,CAACmB,IAAN,EAAX;AACAZ,EAAAA,MAAM,GAAGD,QAAQ,CAACK,GAAT,CAAalB,OAAO,EAApB,CAAT;AACAe,EAAAA,MAAM,GAAGF,QAAQ,CAACK,GAAT,CAAaf,KAAK,CAAC;AAACiB,IAAAA,KAAK,EAAErB,GAAG,CAACe,MAAD;AAAX,GAAD,CAAlB,CAAT;AACAD,EAAAA,QAAQ,CAACc,OAAT,CAAiBhB,IAAjB,EAAuB,IAAIb,SAAJ,CAAce,QAAd,EAAwBC,MAAxB,EAAgCA,MAAhC,EAAwCC,MAAxC,CAAvB;AACAF,EAAAA,QAAQ,CAACe,SAAT,CAAmB,QAAnB,EAA6B,IAA7B,EAjC0C,CAmC1C;;AACAZ,EAAAA,EAAE,CAACa,MAAH,CAAUC,OAAV,GAAoB;AAClBC,IAAAA,QAAQ,EAAElC,SAAS,CAACS,IAAD,EAAOO,QAAP,CAAT,CAA0BmB,SAA1B;AADQ,GAApB;AAGD","sourcesContent":["import {getDataRef} from './data';\nimport parseSpec from '../spec';\nimport DataScope from '../../DataScope';\nimport {ref} from '../../util';\nimport {Collect, Facet, PreFacet, Sieve} from '../../transforms';\nimport {error, stringValue} from 'vega-util';\n\nexport default function(spec, scope, group) {\n  var facet = spec.from.facet,\n      name = facet.name,\n      data = getDataRef(facet, scope),\n      subscope, source, values, op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key:   scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  }\n\n  // initialize facet subscope\n  subscope = scope.fork();\n  source = subscope.add(Collect());\n  values = subscope.add(Sieve({pulse: ref(source)}));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null);\n\n  // parse faceted subflow\n  op.params.subflow = {\n    $subflow: parseSpec(spec, subscope).toRuntime()\n  };\n}\n"]},"metadata":{},"sourceType":"module"}