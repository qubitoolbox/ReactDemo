{"ast":null,"code":"import { COLOR, FILL, FILLOPACITY, OPACITY, SHAPE, SIZE, STROKE, STROKEOPACITY, STROKEWIDTH } from '../../channel';\nimport { getTypedFieldDef, isFieldDef, isTimeFormatFieldDef, title as fieldDefTitle } from '../../channeldef';\nimport { GEOJSON } from '../../type';\nimport { deleteNestedProperty, getFirstDefined, keys } from '../../util';\nimport { mergeTitleComponent, numberFormat } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { isUnitModel } from '../model';\nimport { parseGuideResolve } from '../resolve';\nimport { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';\nimport { LegendComponent, LEGEND_COMPONENT_PROPERTIES } from './component';\nimport * as encode from './encode';\nimport * as properties from './properties';\nimport { direction, type } from './properties';\nimport { parseInteractiveLegend } from '../selection/transforms/legends';\nexport function parseLegend(model) {\n  if (isUnitModel(model)) {\n    model.component.legends = parseUnitLegend(model);\n  } else {\n    model.component.legends = parseNonUnitLegend(model);\n  }\n}\n\nfunction parseUnitLegend(model) {\n  const {\n    encoding\n  } = model;\n  return [COLOR, FILL, STROKE, STROKEWIDTH, SIZE, SHAPE, OPACITY, FILLOPACITY, STROKEOPACITY].reduce((legendComponent, channel) => {\n    const def = encoding[channel];\n\n    if (model.legend(channel) && model.getScaleComponent(channel) && !(isFieldDef(def) && channel === SHAPE && def.type === GEOJSON)) {\n      legendComponent[channel] = parseLegendForChannel(model, channel);\n    }\n\n    return legendComponent;\n  }, {});\n}\n\nfunction getLegendDefWithScale(model, channel) {\n  const scale = model.scaleName(COLOR);\n\n  if (channel === 'color') {\n    return model.markDef.filled ? {\n      fill: scale\n    } : {\n      stroke: scale\n    };\n  }\n\n  return {\n    [channel]: model.scaleName(channel)\n  };\n}\n\nfunction isExplicit(value, property, legend, fieldDef) {\n  switch (property) {\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!legend.values;\n\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === fieldDef.title) {\n        return true;\n      }\n\n  } // Otherwise, things are explicit if the returned value matches the specified property\n\n\n  return value === legend[property];\n}\n\nexport function parseLegendForChannel(model, channel) {\n  var _a;\n\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n  parseInteractiveLegend(model, channel, legendCmpt);\n\n  for (const property of LEGEND_COMPONENT_PROPERTIES) {\n    const value = getProperty(property, legend, channel, model);\n\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, legend, fieldDef);\n\n      if (explicit || model.config.legend[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  }\n\n  const legendEncoding = (_a = legend.encoding, _a !== null && _a !== void 0 ? _a : {});\n  const selections = legendCmpt.get('selections');\n  const legendEncode = ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries'].reduce((e, part) => {\n    var _a, _b, _c;\n\n    const legendEncodingPart = guideEncodeEntry((_a = legendEncoding[part], _a !== null && _a !== void 0 ? _a : {}), model);\n    const value = encode[part] ? encode[part](fieldDef, legendEncodingPart, model, channel, legendCmpt) // apply rule\n    : legendEncodingPart; // no rule -- just default values\n\n    if (value !== undefined && keys(value).length > 0) {\n      e[part] = Object.assign(Object.assign(Object.assign({}, ((_b = selections) === null || _b === void 0 ? void 0 : _b.length) ? {\n        name: `${fieldDef.field}_legend_${part}`\n      } : {}), ((_c = selections) === null || _c === void 0 ? void 0 : _c.length) ? {\n        interactive: !!selections\n      } : {}), {\n        update: value\n      });\n    }\n\n    return e;\n  }, {});\n\n  if (keys(legendEncode).length > 0) {\n    legendCmpt.set('encode', legendEncode, !!legend.encoding);\n  }\n\n  return legendCmpt;\n}\n\nfunction getProperty(property, legend, channel, model) {\n  const {\n    encoding,\n    mark\n  } = model;\n  const fieldDef = getTypedFieldDef(encoding[channel]);\n  const legendConfig = model.config.legend;\n  const {\n    timeUnit\n  } = fieldDef;\n  const scaleType = model.getScaleComponent(channel).get('type');\n\n  switch (property) {\n    // TODO: enable when https://github.com/vega/vega/issues/1351 is fixed\n    // case 'clipHeight':\n    //   return getFirstDefined(specifiedLegend.clipHeight, properties.clipHeight(properties.type(...)));\n    case 'direction':\n      return direction({\n        legend,\n        legendConfig,\n        timeUnit,\n        channel,\n        scaleType\n      });\n\n    case 'format':\n      // We don't include temporal field here as we apply format in encode block\n      if (isTimeFormatFieldDef(fieldDef)) {\n        return undefined;\n      }\n\n      return numberFormat(fieldDef, legend.format, model.config);\n\n    case 'formatType':\n      // As with format, we don't include temporal field here as we apply format in encode block\n      if (isTimeFormatFieldDef(fieldDef)) {\n        return undefined;\n      }\n\n      return legend.formatType;\n\n    case 'gradientLength':\n      return getFirstDefined( // do specified gradientLength first\n      legend.gradientLength, legendConfig.gradientLength, // Otherwise, use smart default based on plot height\n      properties.defaultGradientLength({\n        model,\n        legend,\n        legendConfig,\n        channel,\n        scaleType\n      }));\n\n    case 'labelOverlap':\n      return getFirstDefined(legend.labelOverlap, properties.defaultLabelOverlap(scaleType));\n\n    case 'symbolType':\n      return getFirstDefined(legend.symbolType, properties.defaultSymbolType(mark, channel, encoding.shape, model.markDef.shape));\n\n    case 'title':\n      return fieldDefTitle(fieldDef, model.config, {\n        allowDisabling: true\n      }) || undefined;\n\n    case 'type':\n      return type({\n        legend,\n        channel,\n        timeUnit,\n        scaleType,\n        alwaysReturn: false\n      });\n\n    case 'values':\n      return properties.values(legend, fieldDef);\n  } // Otherwise, return specified property.\n\n\n  return legend[property];\n}\n\nfunction parseNonUnitLegend(model) {\n  const {\n    legends,\n    resolve\n  } = model.component;\n\n  for (const child of model.children) {\n    parseLegend(child);\n    keys(child.component.legends).forEach(channel => {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    });\n  }\n\n  keys(legends).forEach(channel => {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  });\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend, childLegend) {\n  var _a, _b, _c, _d, _e, _f;\n\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  let typeMerged = false; // Otherwise, let's merge\n\n  for (const prop of LEGEND_COMPONENT_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend', // Tie breaker function\n    (v1, v2) => {\n      switch (prop) {\n        case 'symbolType':\n          return mergeSymbolType(v1, v2);\n\n        case 'title':\n          return mergeTitleComponent(v1, v2);\n\n        case 'type':\n          // There are only two types. If we have different types, then prefer symbol over gradient.\n          typeMerged = true;\n          return makeImplicit('symbol');\n      }\n\n      return defaultTieBreaker(v1, v2, prop, 'legend');\n    });\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n\n  if (typeMerged) {\n    if (_c = (_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient, _c !== null && _c !== void 0 ? _c : {}) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n\n    if (_f = (_e = (_d = mergedLegend.explicit) === null || _d === void 0 ? void 0 : _d.encode) === null || _e === void 0 ? void 0 : _e.gradient, _f !== null && _f !== void 0 ? _f : {}) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n\nfunction mergeSymbolType(st1, st2) {\n  if (st2.value === 'circle') {\n    // prefer \"circle\" over \"stroke\"\n    return st2;\n  }\n\n  return st1;\n}","map":{"version":3,"sources":["../../../../src/compile/legend/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {Legend as VgLegend, LegendEncode, SignalRef} from 'vega';\nimport {\n  COLOR,\n  FILL,\n  FILLOPACITY,\n  NonPositionScaleChannel,\n  OPACITY,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEOPACITY,\n  STROKEWIDTH\n} from '../../channel';\nimport {\n  getTypedFieldDef,\n  isFieldDef,\n  isTimeFormatFieldDef,\n  title as fieldDefTitle,\n  TypedFieldDef\n} from '../../channeldef';\nimport {Legend} from '../../legend';\nimport {GEOJSON} from '../../type';\nimport {deleteNestedProperty, getFirstDefined, keys} from '../../util';\nimport {mergeTitleComponent, numberFormat} from '../common';\nimport {guideEncodeEntry} from '../guide';\nimport {isUnitModel, Model} from '../model';\nimport {parseGuideResolve} from '../resolve';\nimport {defaultTieBreaker, Explicit, makeImplicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {LegendComponent, LegendComponentIndex, LegendComponentProps, LEGEND_COMPONENT_PROPERTIES} from './component';\nimport * as encode from './encode';\nimport * as properties from './properties';\nimport {direction, type} from './properties';\nimport {parseInteractiveLegend} from '../selection/transforms/legends';\n\nexport function parseLegend(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.legends = parseUnitLegend(model);\n  } else {\n    model.component.legends = parseNonUnitLegend(model);\n  }\n}\n\nfunction parseUnitLegend(model: UnitModel): LegendComponentIndex {\n  const {encoding} = model;\n  return [COLOR, FILL, STROKE, STROKEWIDTH, SIZE, SHAPE, OPACITY, FILLOPACITY, STROKEOPACITY].reduce(\n    (legendComponent, channel) => {\n      const def = encoding[channel];\n      if (\n        model.legend(channel) &&\n        model.getScaleComponent(channel) &&\n        !(isFieldDef(def) && channel === SHAPE && def.type === GEOJSON)\n      ) {\n        legendComponent[channel] = parseLegendForChannel(model, channel);\n      }\n      return legendComponent;\n    },\n    {}\n  );\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: NonPositionScaleChannel): VgLegend {\n  const scale = model.scaleName(COLOR);\n  if (channel === 'color') {\n    return model.markDef.filled ? {fill: scale} : {stroke: scale};\n  }\n  return {[channel]: model.scaleName(channel)};\n}\n\nfunction isExplicit<T extends string | number | object | boolean>(\n  value: T,\n  property: keyof LegendComponentProps,\n  legend: Legend,\n  fieldDef: TypedFieldDef<string>\n) {\n  switch (property) {\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!legend.values;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === fieldDef.title) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === legend[property];\n}\n\nexport function parseLegendForChannel(model: UnitModel, channel: NonPositionScaleChannel): LegendComponent {\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n  parseInteractiveLegend(model, channel, legendCmpt);\n\n  for (const property of LEGEND_COMPONENT_PROPERTIES) {\n    const value = getProperty(property, legend, channel, model);\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, legend, fieldDef);\n      if (explicit || model.config.legend[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  }\n\n  const legendEncoding = legend.encoding ?? {};\n  const selections = legendCmpt.get('selections');\n  const legendEncode = (['labels', 'legend', 'title', 'symbols', 'gradient', 'entries'] as const).reduce(\n    (e: LegendEncode, part) => {\n      const legendEncodingPart = guideEncodeEntry(legendEncoding[part] ?? {}, model);\n      const value = encode[part]\n        ? encode[part](fieldDef, legendEncodingPart, model, channel, legendCmpt) // apply rule\n        : legendEncodingPart; // no rule -- just default values\n      if (value !== undefined && keys(value).length > 0) {\n        e[part] = {\n          ...(selections?.length ? {name: `${fieldDef.field}_legend_${part}`} : {}),\n          ...(selections?.length ? {interactive: !!selections} : {}),\n          update: value\n        };\n      }\n      return e;\n    },\n    {} as LegendEncode\n  );\n\n  if (keys(legendEncode).length > 0) {\n    legendCmpt.set('encode', legendEncode, !!legend.encoding);\n  }\n\n  return legendCmpt;\n}\n\nfunction getProperty<K extends keyof LegendComponentProps>(\n  property: K,\n  legend: Legend,\n  channel: NonPositionScaleChannel,\n  model: UnitModel\n): LegendComponentProps[K] {\n  const {encoding, mark} = model;\n  const fieldDef = getTypedFieldDef(encoding[channel]);\n  const legendConfig = model.config.legend;\n  const {timeUnit} = fieldDef;\n\n  const scaleType = model.getScaleComponent(channel).get('type');\n\n  switch (property) {\n    // TODO: enable when https://github.com/vega/vega/issues/1351 is fixed\n    // case 'clipHeight':\n    //   return getFirstDefined(specifiedLegend.clipHeight, properties.clipHeight(properties.type(...)));\n\n    case 'direction':\n      return direction({\n        legend,\n        legendConfig,\n        timeUnit,\n        channel,\n        scaleType\n      }) as LegendComponentProps[K];\n\n    case 'format':\n      // We don't include temporal field here as we apply format in encode block\n      if (isTimeFormatFieldDef(fieldDef)) {\n        return undefined;\n      }\n      return numberFormat(fieldDef, legend.format, model.config) as LegendComponentProps[K];\n\n    case 'formatType':\n      // As with format, we don't include temporal field here as we apply format in encode block\n      if (isTimeFormatFieldDef(fieldDef)) {\n        return undefined;\n      }\n      return legend.formatType as LegendComponentProps[K];\n\n    case 'gradientLength':\n      return getFirstDefined<number | SignalRef>(\n        // do specified gradientLength first\n        legend.gradientLength,\n        legendConfig.gradientLength,\n        // Otherwise, use smart default based on plot height\n        properties.defaultGradientLength({\n          model,\n          legend,\n          legendConfig,\n          channel,\n          scaleType\n        })\n      ) as LegendComponentProps[K];\n\n    case 'labelOverlap':\n      return getFirstDefined(legend.labelOverlap, properties.defaultLabelOverlap(scaleType)) as LegendComponentProps[K];\n\n    case 'symbolType':\n      return getFirstDefined(\n        legend.symbolType,\n        properties.defaultSymbolType(mark, channel, encoding.shape, model.markDef.shape)\n      ) as LegendComponentProps[K];\n\n    case 'title':\n      return (fieldDefTitle(fieldDef, model.config, {allowDisabling: true}) || undefined) as LegendComponentProps[K];\n\n    case 'type':\n      return type({legend, channel, timeUnit, scaleType, alwaysReturn: false}) as LegendComponentProps[K];\n\n    case 'values':\n      return properties.values(legend, fieldDef) as LegendComponentProps[K];\n  }\n\n  // Otherwise, return specified property.\n  return (legend as LegendComponentProps)[property];\n}\n\nfunction parseNonUnitLegend(model: Model) {\n  const {legends, resolve} = model.component;\n\n  for (const child of model.children) {\n    parseLegend(child);\n\n    keys(child.component.legends).forEach((channel: NonPositionScaleChannel) => {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    });\n  }\n\n  keys(legends).forEach((channel: NonPositionScaleChannel) => {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  });\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend: LegendComponent, childLegend: LegendComponent): LegendComponent {\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  let typeMerged = false;\n  // Otherwise, let's merge\n  for (const prop of LEGEND_COMPONENT_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit<LegendComponentProps, any>(\n      mergedLegend.getWithExplicit(prop),\n      childLegend.getWithExplicit(prop),\n      prop,\n      'legend',\n\n      // Tie breaker function\n      (v1: Explicit<any>, v2: Explicit<any>): any => {\n        switch (prop) {\n          case 'symbolType':\n            return mergeSymbolType(v1, v2);\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'type':\n            // There are only two types. If we have different types, then prefer symbol over gradient.\n            typeMerged = true;\n            return makeImplicit('symbol');\n        }\n        return defaultTieBreaker<LegendComponentProps, any>(v1, v2, prop, 'legend');\n      }\n    );\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  if (typeMerged) {\n    if (mergedLegend.implicit?.encode?.gradient ?? {}) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n    if (mergedLegend.explicit?.encode?.gradient ?? {}) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n\nfunction mergeSymbolType(st1: Explicit<string>, st2: Explicit<string>) {\n  if (st2.value === 'circle') {\n    // prefer \"circle\" over \"stroke\"\n    return st2;\n  }\n  return st1;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}