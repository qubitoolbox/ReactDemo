{"ast":null,"code":"import partition from './partition';\nimport { regressionLoess } from 'vega-statistics';\nimport { ingest, Transform } from 'vega-dataflow';\nimport { accessorName, inherits } from 'vega-util';\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\n\nexport default function Loess(params) {\n  Transform.call(this, null, params);\n}\nLoess.Definition = {\n  \"type\": \"Loess\",\n  \"metadata\": {\n    \"generates\": true\n  },\n  \"params\": [{\n    \"name\": \"x\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"y\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"groupby\",\n    \"type\": \"field\",\n    \"array\": true\n  }, {\n    \"name\": \"bandwidth\",\n    \"type\": \"number\",\n    \"default\": 0.3\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"array\": true\n  }]\n};\nvar prototype = inherits(Loess, Transform);\n\nprototype.transform = function (_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n  if (!this.value || pulse.changed() || _.modified()) {\n    const source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition(source, _.groupby),\n          names = (_.groupby || []).map(accessorName),\n          m = names.length,\n          as = _.as || [accessorName(_.x), accessorName(_.y)],\n          values = [];\n    groups.forEach(g => {\n      regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n        const t = {};\n\n        for (let i = 0; i < m; ++i) {\n          t[names[i]] = g.dims[i];\n        }\n\n        t[as[0]] = p[0];\n        t[as[1]] = p[1];\n        values.push(ingest(t));\n      });\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.add = out.source = values;\n  }\n\n  return out;\n};","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-regression/src/Loess.js"],"names":["partition","regressionLoess","ingest","Transform","accessorName","inherits","Loess","params","call","Definition","prototype","transform","_","pulse","out","fork","NO_SOURCE","NO_FIELDS","value","changed","modified","source","materialize","SOURCE","groups","groupby","names","map","m","length","as","x","y","values","forEach","g","bandwidth","p","t","i","dims","push","rem","add"],"mappings":"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","sourcesContent":["import partition from './partition';\nimport {regressionLoess} from 'vega-statistics';\nimport {ingest, Transform} from 'vega-dataflow';\nimport {accessorName, inherits} from 'vega-util';\n\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\nexport default function Loess(params) {\n  Transform.call(this, null, params);\n}\n\nLoess.Definition = {\n  \"type\": \"Loess\",\n  \"metadata\": {\"generates\": true},\n  \"params\": [\n    { \"name\": \"x\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"y\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"groupby\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"bandwidth\", \"type\": \"number\", \"default\": 0.3 },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true }\n  ]\n};\n\nvar prototype = inherits(Loess, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n  if (!this.value || pulse.changed() || _.modified()) {\n    const source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition(source, _.groupby),\n          names = (_.groupby || []).map(accessorName),\n          m = names.length,\n          as = _.as || [accessorName(_.x), accessorName(_.y)],\n          values = [];\n\n    groups.forEach(g => {\n      regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n        const t = {};\n        for (let i=0; i<m; ++i) {\n          t[names[i]] = g.dims[i];\n        }\n        t[as[0]] = p[0];\n        t[as[1]] = p[1];\n        values.push(ingest(t));\n      });\n    });\n\n    if (this.value) out.rem = this.value;\n    this.value = out.add = out.source = values;\n  }\n\n  return out;\n};\n"]},"metadata":{},"sourceType":"module"}