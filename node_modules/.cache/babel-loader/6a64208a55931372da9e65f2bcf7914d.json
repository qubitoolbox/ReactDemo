{"ast":null,"code":"import { Top, Bottom, Left, Right, Label, Value, GuideLabelStyle, zero, one } from './constants';\nimport guideMark from './guide-mark';\nimport { lookup } from './guide-util';\nimport { TextMark } from '../marks/marktypes';\nimport { AxisLabelRole } from '../marks/roles';\nimport { addEncoders, encoder } from '../encode/encode-util';\nimport { deref } from '../../util';\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nexport default function (spec, config, userEncode, dataRef, size, band) {\n  var _ = lookup(spec, config),\n      orient = spec.orient,\n      sign = orient === Left || orient === Top ? -1 : 1,\n      isXAxis = orient === Top || orient === Bottom,\n      scale = spec.scale,\n      flush = deref(_('labelFlush')),\n      flushOffset = deref(_('labelFlushOffset')),\n      flushOn = flush === 0 || !!flush,\n      labelAlign = _('labelAlign'),\n      labelBaseline = _('labelBaseline'),\n      encode,\n      enter,\n      tickSize,\n      tickPos,\n      align,\n      baseline,\n      offset,\n      bound,\n      overlap,\n      separation;\n\n  tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: band.offset\n  };\n\n  if (isXAxis) {\n    align = labelAlign || (flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : 'center');\n    baseline = labelBaseline || (orient === Top ? 'bottom' : 'top');\n    offset = !labelAlign;\n  } else {\n    align = labelAlign || (orient === Right ? 'left' : 'right');\n    baseline = labelBaseline || (flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : 'middle');\n    offset = !labelBaseline;\n  }\n\n  offset = offset && flushOn && flushOffset ? flushExpr(scale, flush, '-(' + flushOffset + ')', flushOffset, 0) : null;\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: isXAxis ? tickPos : tickSize,\n      y: isXAxis ? tickSize : tickPos\n    },\n    update: {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    [isXAxis ? 'dx' : 'dy']: offset,\n    align: align,\n    baseline: baseline,\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit')\n  });\n  bound = _('labelBound');\n  overlap = _('labelOverlap');\n  separation = _('labelSeparation');\n  spec = guideMark(TextMark, AxisLabelRole, GuideLabelStyle, Value, dataRef, encode, userEncode); // if overlap method or bound defined, request label overlap removal\n\n  if (overlap || bound) {\n    spec.overlap = {\n      separation: separation,\n      method: overlap,\n      order: 'datum.index',\n      bound: bound ? {\n        scale: scale,\n        orient: orient,\n        tolerance: bound\n      } : null\n    };\n  }\n\n  return spec;\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/guides/axis-labels.js"],"names":["Top","Bottom","Left","Right","Label","Value","GuideLabelStyle","zero","one","guideMark","lookup","TextMark","AxisLabelRole","addEncoders","encoder","deref","flushExpr","scale","threshold","a","b","c","signal","spec","config","userEncode","dataRef","size","band","_","orient","sign","isXAxis","flush","flushOffset","flushOn","labelAlign","labelBaseline","encode","enter","tickSize","tickPos","align","baseline","offset","bound","overlap","separation","mult","field","opacity","x","y","update","text","exit","angle","fill","fillOpacity","font","fontSize","fontWeight","fontStyle","limit","method","order","tolerance"],"mappings":"AAAA,SAAQA,GAAR,EAAaC,MAAb,EAAqBC,IAArB,EAA2BC,KAA3B,EAAkCC,KAAlC,EAAyCC,KAAzC,EAAgDC,eAAhD,EAAiEC,IAAjE,EAAuEC,GAAvE,QAAiF,aAAjF;AACA,OAAOC,SAAP,MAAsB,cAAtB;AACA,SAAQC,MAAR,QAAqB,cAArB;AACA,SAAQC,QAAR,QAAuB,oBAAvB;AACA,SAAQC,aAAR,QAA4B,gBAA5B;AACA,SAAQC,WAAR,EAAqBC,OAArB,QAAmC,uBAAnC;AACA,SAAQC,KAAR,QAAoB,YAApB;;AAEA,SAASC,SAAT,CAAmBC,KAAnB,EAA0BC,SAA1B,EAAqCC,CAArC,EAAwCC,CAAxC,EAA2CC,CAA3C,EAA8C;AAC5C,SAAO;AACLC,IAAAA,MAAM,EAAE,kBAAkBL,KAAlB,GAA0B,MAA1B,GACJ,SADI,GACQA,KADR,GACgB,mBADhB,GAEJC,SAFI,GAEQ,GAFR,GAEcC,CAFd,GAEkB,GAFlB,GAEwBC,CAFxB,GAE4B,GAF5B,GAEkCC,CAFlC,GAEsC;AAHzC,GAAP;AAKD;;AAED,eAAe,UAASE,IAAT,EAAeC,MAAf,EAAuBC,UAAvB,EAAmCC,OAAnC,EAA4CC,IAA5C,EAAkDC,IAAlD,EAAwD;AACrE,MAAIC,CAAC,GAAGnB,MAAM,CAACa,IAAD,EAAOC,MAAP,CAAd;AAAA,MACIM,MAAM,GAAGP,IAAI,CAACO,MADlB;AAAA,MAEIC,IAAI,GAAID,MAAM,KAAK5B,IAAX,IAAmB4B,MAAM,KAAK9B,GAA/B,GAAsC,CAAC,CAAvC,GAA2C,CAFtD;AAAA,MAGIgC,OAAO,GAAIF,MAAM,KAAK9B,GAAX,IAAkB8B,MAAM,KAAK7B,MAH5C;AAAA,MAIIgB,KAAK,GAAGM,IAAI,CAACN,KAJjB;AAAA,MAKIgB,KAAK,GAAGlB,KAAK,CAACc,CAAC,CAAC,YAAD,CAAF,CALjB;AAAA,MAMIK,WAAW,GAAGnB,KAAK,CAACc,CAAC,CAAC,kBAAD,CAAF,CANvB;AAAA,MAOIM,OAAO,GAAGF,KAAK,KAAK,CAAV,IAAe,CAAC,CAACA,KAP/B;AAAA,MAQIG,UAAU,GAAGP,CAAC,CAAC,YAAD,CARlB;AAAA,MASIQ,aAAa,GAAGR,CAAC,CAAC,eAAD,CATrB;AAAA,MAUIS,MAVJ;AAAA,MAUYC,KAVZ;AAAA,MAUmBC,QAVnB;AAAA,MAU6BC,OAV7B;AAAA,MAUsCC,KAVtC;AAAA,MAU6CC,QAV7C;AAAA,MAUuDC,MAVvD;AAAA,MAWIC,KAXJ;AAAA,MAWWC,OAXX;AAAA,MAWoBC,UAXpB;;AAaAP,EAAAA,QAAQ,GAAG1B,OAAO,CAACa,IAAD,CAAlB;AACAa,EAAAA,QAAQ,CAACQ,IAAT,GAAgBjB,IAAhB;AACAS,EAAAA,QAAQ,CAACI,MAAT,GAAkB9B,OAAO,CAACe,CAAC,CAAC,cAAD,CAAD,IAAqB,CAAtB,CAAzB;AACAW,EAAAA,QAAQ,CAACI,MAAT,CAAgBI,IAAhB,GAAuBjB,IAAvB;AAEAU,EAAAA,OAAO,GAAG;AACRxB,IAAAA,KAAK,EAAGA,KADA;AAERgC,IAAAA,KAAK,EAAG5C,KAFA;AAGRuB,IAAAA,IAAI,EAAI,GAHA;AAIRgB,IAAAA,MAAM,EAAEhB,IAAI,CAACgB;AAJL,GAAV;;AAOA,MAAIZ,OAAJ,EAAa;AACXU,IAAAA,KAAK,GAAGN,UAAU,KAAKD,OAAO,GAC1BnB,SAAS,CAACC,KAAD,EAAQgB,KAAR,EAAe,QAAf,EAAyB,SAAzB,EAAoC,UAApC,CADiB,GAE1B,QAFc,CAAlB;AAGAU,IAAAA,QAAQ,GAAGN,aAAa,KAAKP,MAAM,KAAK9B,GAAX,GAAiB,QAAjB,GAA4B,KAAjC,CAAxB;AACA4C,IAAAA,MAAM,GAAG,CAACR,UAAV;AACD,GAND,MAMO;AACLM,IAAAA,KAAK,GAAGN,UAAU,KAAKN,MAAM,KAAK3B,KAAX,GAAmB,MAAnB,GAA4B,OAAjC,CAAlB;AACAwC,IAAAA,QAAQ,GAAGN,aAAa,KAAKF,OAAO,GAChCnB,SAAS,CAACC,KAAD,EAAQgB,KAAR,EAAe,OAAf,EAAwB,UAAxB,EAAoC,UAApC,CADuB,GAEhC,QAFoB,CAAxB;AAGAW,IAAAA,MAAM,GAAG,CAACP,aAAV;AACD;;AAEDO,EAAAA,MAAM,GAAGA,MAAM,IAAIT,OAAV,IAAqBD,WAArB,GACLlB,SAAS,CAACC,KAAD,EAAQgB,KAAR,EAAe,OAAOC,WAAP,GAAqB,GAApC,EAAyCA,WAAzC,EAAsD,CAAtD,CADJ,GAEL,IAFJ;AAIAI,EAAAA,MAAM,GAAG;AACPC,IAAAA,KAAK,EAAEA,KAAK,GAAG;AACbW,MAAAA,OAAO,EAAE3C,IADI;AAEb4C,MAAAA,CAAC,EAAEnB,OAAO,GAAGS,OAAH,GAAaD,QAFV;AAGbY,MAAAA,CAAC,EAAEpB,OAAO,GAAGQ,QAAH,GAAcC;AAHX,KADR;AAMPY,IAAAA,MAAM,EAAE;AACNH,MAAAA,OAAO,EAAE1C,GADH;AAEN8C,MAAAA,IAAI,EAAE;AAACL,QAAAA,KAAK,EAAE7C;AAAR,OAFA;AAGN+C,MAAAA,CAAC,EAAEZ,KAAK,CAACY,CAHH;AAINC,MAAAA,CAAC,EAAEb,KAAK,CAACa;AAJH,KAND;AAYPG,IAAAA,IAAI,EAAE;AACJL,MAAAA,OAAO,EAAE3C,IADL;AAEJ4C,MAAAA,CAAC,EAAEZ,KAAK,CAACY,CAFL;AAGJC,MAAAA,CAAC,EAAEb,KAAK,CAACa;AAHL;AAZC,GAAT;AAmBAvC,EAAAA,WAAW,CAACyB,MAAD,EAAS;AAClB,KAACN,OAAO,GAAG,IAAH,GAAU,IAAlB,GAAyBY,MADP;AAElBF,IAAAA,KAAK,EAAQA,KAFK;AAGlBC,IAAAA,QAAQ,EAAKA,QAHK;AAIlBa,IAAAA,KAAK,EAAQ3B,CAAC,CAAC,YAAD,CAJI;AAKlB4B,IAAAA,IAAI,EAAS5B,CAAC,CAAC,YAAD,CALI;AAMlB6B,IAAAA,WAAW,EAAE7B,CAAC,CAAC,cAAD,CANI;AAOlB8B,IAAAA,IAAI,EAAS9B,CAAC,CAAC,WAAD,CAPI;AAQlB+B,IAAAA,QAAQ,EAAK/B,CAAC,CAAC,eAAD,CARI;AASlBgC,IAAAA,UAAU,EAAGhC,CAAC,CAAC,iBAAD,CATI;AAUlBiC,IAAAA,SAAS,EAAIjC,CAAC,CAAC,gBAAD,CAVI;AAWlBkC,IAAAA,KAAK,EAAQlC,CAAC,CAAC,YAAD;AAXI,GAAT,CAAX;AAcAgB,EAAAA,KAAK,GAAKhB,CAAC,CAAC,YAAD,CAAX;AACAiB,EAAAA,OAAO,GAAGjB,CAAC,CAAC,cAAD,CAAX;AACAkB,EAAAA,UAAU,GAAGlB,CAAC,CAAC,iBAAD,CAAd;AAEAN,EAAAA,IAAI,GAAGd,SAAS,CAACE,QAAD,EAAWC,aAAX,EAA0BN,eAA1B,EAA2CD,KAA3C,EAAkDqB,OAAlD,EAA2DY,MAA3D,EAAmEb,UAAnE,CAAhB,CAjFqE,CAmFrE;;AACA,MAAIqB,OAAO,IAAID,KAAf,EAAsB;AACpBtB,IAAAA,IAAI,CAACuB,OAAL,GAAe;AACbC,MAAAA,UAAU,EAAEA,UADC;AAEbiB,MAAAA,MAAM,EAAElB,OAFK;AAGbmB,MAAAA,KAAK,EAAE,aAHM;AAIbpB,MAAAA,KAAK,EAAEA,KAAK,GAAG;AAAC5B,QAAAA,KAAK,EAAEA,KAAR;AAAea,QAAAA,MAAM,EAAEA,MAAvB;AAA+BoC,QAAAA,SAAS,EAAErB;AAA1C,OAAH,GAAsD;AAJrD,KAAf;AAMD;;AAED,SAAOtB,IAAP;AACD","sourcesContent":["import {Top, Bottom, Left, Right, Label, Value, GuideLabelStyle, zero, one} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisLabelRole} from '../marks/roles';\nimport {addEncoders, encoder} from '../encode/encode-util';\nimport {deref} from '../../util';\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), '\n      + 'scale(\"' + scale + '\", datum.value), '\n      + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nexport default function(spec, config, userEncode, dataRef, size, band) {\n  var _ = lookup(spec, config),\n      orient = spec.orient,\n      sign = (orient === Left || orient === Top) ? -1 : 1,\n      isXAxis = (orient === Top || orient === Bottom),\n      scale = spec.scale,\n      flush = deref(_('labelFlush')),\n      flushOffset = deref(_('labelFlushOffset')),\n      flushOn = flush === 0 || !!flush,\n      labelAlign = _('labelAlign'),\n      labelBaseline = _('labelBaseline'),\n      encode, enter, tickSize, tickPos, align, baseline, offset,\n      bound, overlap, separation;\n\n  tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n\n  tickPos = {\n    scale:  scale,\n    field:  Value,\n    band:   0.5,\n    offset: band.offset\n  };\n\n  if (isXAxis) {\n    align = labelAlign || (flushOn\n      ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"')\n      : 'center');\n    baseline = labelBaseline || (orient === Top ? 'bottom' : 'top');\n    offset = !labelAlign;\n  } else {\n    align = labelAlign || (orient === Right ? 'left' : 'right');\n    baseline = labelBaseline || (flushOn\n      ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"')\n      : 'middle');\n    offset = !labelBaseline;\n  }\n\n  offset = offset && flushOn && flushOffset\n    ? flushExpr(scale, flush, '-(' + flushOffset + ')', flushOffset, 0)\n    : null;\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: isXAxis ? tickPos : tickSize,\n      y: isXAxis ? tickSize : tickPos\n    },\n    update: {\n      opacity: one,\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n\n  addEncoders(encode, {\n    [isXAxis ? 'dx' : 'dy']: offset,\n    align:       align,\n    baseline:    baseline,\n    angle:       _('labelAngle'),\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontWeight:  _('labelFontWeight'),\n    fontStyle:   _('labelFontStyle'),\n    limit:       _('labelLimit')\n  });\n\n  bound   = _('labelBound');\n  overlap = _('labelOverlap');\n  separation = _('labelSeparation');\n\n  spec = guideMark(TextMark, AxisLabelRole, GuideLabelStyle, Value, dataRef, encode, userEncode);\n\n  // if overlap method or bound defined, request label overlap removal\n  if (overlap || bound) {\n    spec.overlap = {\n      separation: separation,\n      method: overlap,\n      order: 'datum.index',\n      bound: bound ? {scale: scale, orient: orient, tolerance: bound} : null\n    };\n  }\n\n  return spec;\n}\n"]},"metadata":{},"sourceType":"module"}