{"ast":null,"code":"/* eslint-disable require-atomic-updates */\nimport { default as Pulse, StopPropagation } from '../Pulse';\nimport MultiPulse from '../MultiPulse';\nimport asyncCallback from '../util/asyncCallback';\nimport UniqueList from '../util/UniqueList';\nimport { id, isArray, Info, Debug } from 'vega-util';\n/**\n * Evaluates the dataflow and returns a Promise that resolves when pulse\n * propagation completes. This method will increment the current timestamp\n * and process all updated, pulsed and touched operators. When invoked for\n * the first time, all registered operators will be processed. This method\n * should not be invoked by third-party clients, use {@link runAsync} or\n * {@link run} instead.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode package.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Promise} - A promise that resolves to this dataflow after\n *   evaluation completes.\n */\n\nexport async function evaluate(encode, prerun, postrun) {\n  const df = this,\n        level = df.logLevel(),\n        async = []; // if the pulse value is set, this is a re-entrant call\n\n  if (df._pulse) return reentrant(df); // wait for pending datasets to load\n\n  if (df._pending) {\n    await df._pending;\n  } // invoke prerun function, if provided\n\n\n  if (prerun) await asyncCallback(df, prerun); // exit early if there are no updates\n\n  if (!df._touched.length) {\n    df.info('Dataflow invoked, but nothing to do.');\n    return df;\n  } // increment timestamp clock\n\n\n  let stamp = ++df._clock,\n      count = 0,\n      op,\n      next,\n      dt,\n      error; // set the current pulse\n\n  df._pulse = new Pulse(df, stamp, encode);\n\n  if (level >= Info) {\n    dt = Date.now();\n    df.debug('-- START PROPAGATION (' + stamp + ') -----');\n  } // initialize priority queue, reset touched operators\n\n\n  df._touched.forEach(op => df._enqueue(op, true));\n\n  df._touched = UniqueList(id);\n\n  try {\n    while (df._heap.size() > 0) {\n      // dequeue operator with highest priority\n      op = df._heap.pop(); // re-queue if rank changed\n\n      if (op.rank !== op.qrank) {\n        df._enqueue(op, true);\n\n        continue;\n      } // otherwise, evaluate the operator\n\n\n      next = op.run(df._getPulse(op, encode));\n\n      if (next.then) {\n        // await if operator returns a promise directly\n        next = await next;\n      } else if (next.async) {\n        // queue parallel asynchronous execution\n        async.push(next.async);\n        next = StopPropagation;\n      }\n\n      if (level >= Debug) {\n        df.debug(op.id, next === StopPropagation ? 'STOP' : next, op);\n      } // propagate evaluation, enqueue dependent operators\n\n\n      if (next !== StopPropagation) {\n        if (op._targets) op._targets.forEach(op => df._enqueue(op));\n      } // increment visit counter\n\n\n      ++count;\n    }\n  } catch (err) {\n    df._heap.clear();\n\n    error = err;\n  } // reset pulse map\n\n\n  df._input = {};\n  df._pulse = null;\n\n  if (level >= Info) {\n    dt = Date.now() - dt;\n    df.info('> Pulse ' + stamp + ': ' + count + ' operators; ' + dt + 'ms');\n  }\n\n  if (error) {\n    df._postrun = [];\n    df.error(error);\n  } // invoke callbacks queued via runAfter\n\n\n  if (df._postrun.length) {\n    const pr = df._postrun.sort((a, b) => b.priority - a.priority);\n\n    df._postrun = [];\n\n    for (let i = 0; i < pr.length; ++i) {\n      await asyncCallback(df, pr[i].callback);\n    }\n  } // invoke postrun function, if provided\n\n\n  if (postrun) await asyncCallback(df, postrun); // handle non-blocking asynchronous callbacks\n\n  if (async.length) {\n    Promise.all(async).then(cb => df.runAsync(null, () => {\n      cb.forEach(f => {\n        try {\n          f(df);\n        } catch (err) {\n          df.error(err);\n        }\n      });\n    }));\n  }\n\n  return df;\n}\n/**\n * Queues dataflow evaluation to run once any other queued evaluations have\n * completed and returns a Promise that resolves when the queued pulse\n * propagation completes. If provided, a callback function will be invoked\n * immediately before evaluation commences. This method will ensure a\n * separate evaluation is invoked for each time it is called.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode package.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Promise} - A promise that resolves to this dataflow after\n *   evaluation completes.\n */\n\nexport async function runAsync(encode, prerun, postrun) {\n  // await previously queued functions\n  while (this._running) await this._running; // run dataflow, manage running promise\n\n\n  const clear = () => this._running = null;\n\n  (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);\n  return this._running;\n}\n/**\n * Requests dataflow evaluation and the immediately returns this dataflow\n * instance. If there are pending data loading or other asynchronous\n * operations, the dataflow will evaluate asynchronously after this method\n * has been invoked. To track when dataflow evaluation completes, use the\n * {@link runAsync} method instead. This method will raise an error if\n * invoked while the dataflow is already in the midst of evaluation.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode module.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Dataflow} - This dataflow instance.\n */\n\nexport function run(encode, prerun, postrun) {\n  return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);\n}\n/**\n * Schedules a callback function to be invoked after the current pulse\n * propagation completes. If no propagation is currently occurring,\n * the function is invoked immediately. Callbacks scheduled via runAfter\n * are invoked immediately upon completion of the current cycle, before\n * any request queued via runAsync. This method is primarily intended for\n * internal use. Third-party callers using runAfter to schedule a callback\n * that invokes {@link run} or {@link runAsync} should not use this method,\n * but instead use {@link runAsync} with prerun or postrun arguments.\n * @param {function(Dataflow)} callback - The callback function to run.\n *   The callback will be invoked with this Dataflow instance as its\n *   sole argument.\n * @param {boolean} enqueue - A boolean flag indicating that the\n *   callback should be queued up to run after the next propagation\n *   cycle, suppressing immediate invocation when propagation is not\n *   currently occurring.\n * @param {number} [priority] - A priority value used to sort registered\n *   callbacks to determine execution order. This argument is intended\n *   for internal Vega use only.\n */\n\nexport function runAfter(callback, enqueue, priority) {\n  if (this._pulse || enqueue) {\n    // pulse propagation is currently running, queue to run after\n    this._postrun.push({\n      priority: priority || 0,\n      callback: callback\n    });\n  } else {\n    // pulse propagation already complete, invoke immediately\n    try {\n      callback(this);\n    } catch (err) {\n      this.error(err);\n    }\n  }\n}\n/**\n * Raise an error for re-entrant dataflow evaluation.\n */\n\nfunction reentrant(df) {\n  df.error('Dataflow already running. Use runAsync() to chain invocations.');\n  return df;\n}\n/**\n * Enqueue an operator into the priority queue for evaluation. The operator\n * will be enqueued if it has no registered pulse for the current cycle, or if\n * the force argument is true. Upon enqueue, this method also sets the\n * operator's qrank to the current rank value.\n * @param {Operator} op - The operator to enqueue.\n * @param {boolean} [force] - A flag indicating if the operator should be\n *   forceably added to the queue, even if it has already been previously\n *   enqueued during the current pulse propagation. This is useful when the\n *   dataflow graph is dynamically modified and the operator rank changes.\n */\n\n\nexport function enqueue(op, force) {\n  var q = op.stamp < this._clock;\n  if (q) op.stamp = this._clock;\n\n  if (q || force) {\n    op.qrank = op.rank;\n\n    this._heap.push(op);\n  }\n}\n/**\n * Provide a correct pulse for evaluating an operator. If the operator has an\n * explicit source operator, we will try to pull the pulse(s) from it.\n * If there is an array of source operators, we build a multi-pulse.\n * Otherwise, we return a current pulse with correct source data.\n * If the pulse is the pulse map has an explicit target set, we use that.\n * Else if the pulse on the upstream source operator is current, we use that.\n * Else we use the pulse from the pulse map, but copy the source tuple array.\n * @param {Operator} op - The operator for which to get an input pulse.\n * @param {string} [encode] - An (optional) encoding set name with which to\n *   annotate the returned pulse. See {@link run} for more information.\n */\n\nexport function getPulse(op, encode) {\n  var s = op.source,\n      stamp = this._clock;\n  return s && isArray(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\n}\n\nfunction singlePulse(p, s) {\n  if (s && s.stamp === p.stamp) {\n    return s;\n  }\n\n  p = p.fork();\n\n  if (s && s !== StopPropagation) {\n    p.source = s.source;\n  }\n\n  return p;\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-dataflow/src/dataflow/run.js"],"names":["default","Pulse","StopPropagation","MultiPulse","asyncCallback","UniqueList","id","isArray","Info","Debug","evaluate","encode","prerun","postrun","df","level","logLevel","async","_pulse","reentrant","_pending","_touched","length","info","stamp","_clock","count","op","next","dt","error","Date","now","debug","forEach","_enqueue","_heap","size","pop","rank","qrank","run","_getPulse","then","push","_targets","err","clear","_input","_postrun","pr","sort","a","b","priority","i","callback","Promise","all","cb","runAsync","f","_running","runAfter","enqueue","force","q","getPulse","s","source","map","_","pulse","singlePulse","p","fork"],"mappings":"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","sourcesContent":["/* eslint-disable require-atomic-updates */\nimport {default as Pulse, StopPropagation} from '../Pulse';\nimport MultiPulse from '../MultiPulse';\nimport asyncCallback from '../util/asyncCallback';\nimport UniqueList from '../util/UniqueList';\nimport {id, isArray, Info, Debug} from 'vega-util';\n\n/**\n * Evaluates the dataflow and returns a Promise that resolves when pulse\n * propagation completes. This method will increment the current timestamp\n * and process all updated, pulsed and touched operators. When invoked for\n * the first time, all registered operators will be processed. This method\n * should not be invoked by third-party clients, use {@link runAsync} or\n * {@link run} instead.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode package.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Promise} - A promise that resolves to this dataflow after\n *   evaluation completes.\n */\nexport async function evaluate(encode, prerun, postrun) {\n  const df = this,\n        level = df.logLevel(),\n        async = [];\n\n  // if the pulse value is set, this is a re-entrant call\n  if (df._pulse) return reentrant(df);\n\n  // wait for pending datasets to load\n  if (df._pending) {\n    await df._pending;\n  }\n\n  // invoke prerun function, if provided\n  if (prerun) await asyncCallback(df, prerun);\n\n  // exit early if there are no updates\n  if (!df._touched.length) {\n    df.info('Dataflow invoked, but nothing to do.');\n    return df;\n  }\n\n  // increment timestamp clock\n  let stamp = ++df._clock,\n      count = 0, op, next, dt, error;\n\n  // set the current pulse\n  df._pulse = new Pulse(df, stamp, encode);\n\n  if (level >= Info) {\n    dt = Date.now();\n    df.debug('-- START PROPAGATION (' + stamp + ') -----');\n  }\n\n  // initialize priority queue, reset touched operators\n  df._touched.forEach(op => df._enqueue(op, true));\n  df._touched = UniqueList(id);\n\n  try {\n    while (df._heap.size() > 0) {\n      // dequeue operator with highest priority\n      op = df._heap.pop();\n\n      // re-queue if rank changed\n      if (op.rank !== op.qrank) { df._enqueue(op, true); continue; }\n\n      // otherwise, evaluate the operator\n      next = op.run(df._getPulse(op, encode));\n\n      if (next.then) {\n        // await if operator returns a promise directly\n        next = await next;\n      } else if (next.async) {\n        // queue parallel asynchronous execution\n        async.push(next.async);\n        next = StopPropagation;\n      }\n\n      if (level >= Debug) {\n        df.debug(op.id, next === StopPropagation ? 'STOP' : next, op);\n      }\n\n      // propagate evaluation, enqueue dependent operators\n      if (next !== StopPropagation) {\n        if (op._targets) op._targets.forEach(op => df._enqueue(op));\n      }\n\n      // increment visit counter\n      ++count;\n    }\n  } catch (err) {\n    df._heap.clear();\n    error = err;\n  }\n\n  // reset pulse map\n  df._input = {};\n  df._pulse = null;\n\n  if (level >= Info) {\n    dt = Date.now() - dt;\n    df.info('> Pulse ' + stamp + ': ' + count + ' operators; ' + dt + 'ms');\n  }\n\n  if (error) {\n    df._postrun = [];\n    df.error(error);\n  }\n\n  // invoke callbacks queued via runAfter\n  if (df._postrun.length) {\n    const pr = df._postrun.sort((a, b) => b.priority - a.priority);\n    df._postrun = [];\n    for (let i=0; i<pr.length; ++i) {\n      await asyncCallback(df, pr[i].callback);\n    }\n  }\n\n  // invoke postrun function, if provided\n  if (postrun) await asyncCallback(df, postrun);\n\n  // handle non-blocking asynchronous callbacks\n  if (async.length) {\n    Promise.all(async).then(cb => df.runAsync(null, () => {\n      cb.forEach(f => { try { f(df); } catch (err) { df.error(err); } });\n    }));\n  }\n\n  return df;\n}\n\n/**\n * Queues dataflow evaluation to run once any other queued evaluations have\n * completed and returns a Promise that resolves when the queued pulse\n * propagation completes. If provided, a callback function will be invoked\n * immediately before evaluation commences. This method will ensure a\n * separate evaluation is invoked for each time it is called.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode package.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Promise} - A promise that resolves to this dataflow after\n *   evaluation completes.\n */\nexport async function runAsync(encode, prerun, postrun) {\n  // await previously queued functions\n  while (this._running) await this._running;\n\n  // run dataflow, manage running promise\n  const clear = () => this._running = null;\n  (this._running = this.evaluate(encode, prerun, postrun))\n    .then(clear, clear);\n\n  return this._running;\n}\n\n/**\n * Requests dataflow evaluation and the immediately returns this dataflow\n * instance. If there are pending data loading or other asynchronous\n * operations, the dataflow will evaluate asynchronously after this method\n * has been invoked. To track when dataflow evaluation completes, use the\n * {@link runAsync} method instead. This method will raise an error if\n * invoked while the dataflow is already in the midst of evaluation.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode module.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Dataflow} - This dataflow instance.\n */\nexport function run(encode, prerun, postrun) {\n  return this._pulse ? reentrant(this)\n    : (this.evaluate(encode, prerun, postrun), this);\n}\n\n/**\n * Schedules a callback function to be invoked after the current pulse\n * propagation completes. If no propagation is currently occurring,\n * the function is invoked immediately. Callbacks scheduled via runAfter\n * are invoked immediately upon completion of the current cycle, before\n * any request queued via runAsync. This method is primarily intended for\n * internal use. Third-party callers using runAfter to schedule a callback\n * that invokes {@link run} or {@link runAsync} should not use this method,\n * but instead use {@link runAsync} with prerun or postrun arguments.\n * @param {function(Dataflow)} callback - The callback function to run.\n *   The callback will be invoked with this Dataflow instance as its\n *   sole argument.\n * @param {boolean} enqueue - A boolean flag indicating that the\n *   callback should be queued up to run after the next propagation\n *   cycle, suppressing immediate invocation when propagation is not\n *   currently occurring.\n * @param {number} [priority] - A priority value used to sort registered\n *   callbacks to determine execution order. This argument is intended\n *   for internal Vega use only.\n */\nexport function runAfter(callback, enqueue, priority) {\n  if (this._pulse || enqueue) {\n    // pulse propagation is currently running, queue to run after\n    this._postrun.push({\n      priority: priority || 0,\n      callback: callback\n    });\n  } else {\n    // pulse propagation already complete, invoke immediately\n    try { callback(this); } catch (err) { this.error(err); }\n  }\n}\n\n/**\n * Raise an error for re-entrant dataflow evaluation.\n */\nfunction reentrant(df) {\n  df.error('Dataflow already running. Use runAsync() to chain invocations.');\n  return df;\n}\n\n/**\n * Enqueue an operator into the priority queue for evaluation. The operator\n * will be enqueued if it has no registered pulse for the current cycle, or if\n * the force argument is true. Upon enqueue, this method also sets the\n * operator's qrank to the current rank value.\n * @param {Operator} op - The operator to enqueue.\n * @param {boolean} [force] - A flag indicating if the operator should be\n *   forceably added to the queue, even if it has already been previously\n *   enqueued during the current pulse propagation. This is useful when the\n *   dataflow graph is dynamically modified and the operator rank changes.\n */\nexport function enqueue(op, force) {\n  var q = op.stamp < this._clock;\n  if (q) op.stamp = this._clock;\n  if (q || force) {\n    op.qrank = op.rank;\n    this._heap.push(op);\n  }\n}\n\n/**\n * Provide a correct pulse for evaluating an operator. If the operator has an\n * explicit source operator, we will try to pull the pulse(s) from it.\n * If there is an array of source operators, we build a multi-pulse.\n * Otherwise, we return a current pulse with correct source data.\n * If the pulse is the pulse map has an explicit target set, we use that.\n * Else if the pulse on the upstream source operator is current, we use that.\n * Else we use the pulse from the pulse map, but copy the source tuple array.\n * @param {Operator} op - The operator for which to get an input pulse.\n * @param {string} [encode] - An (optional) encoding set name with which to\n *   annotate the returned pulse. See {@link run} for more information.\n */\nexport function getPulse(op, encode) {\n  var s = op.source,\n      stamp = this._clock;\n\n  return s && isArray(s)\n    ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode)\n    : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\n}\n\nfunction singlePulse(p, s) {\n  if (s && s.stamp === p.stamp) {\n    return s;\n  }\n\n  p = p.fork();\n  if (s && s !== StopPropagation) {\n    p.source = s.source;\n  }\n  return p;\n}\n"]},"metadata":{},"sourceType":"module"}