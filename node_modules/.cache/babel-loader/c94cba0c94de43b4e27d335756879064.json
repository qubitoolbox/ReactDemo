{"ast":null,"code":"import { read, responseType } from 'vega-loader';\nimport { truthy } from 'vega-util';\nexport const parse = read;\n/**\n * Ingests new data into the dataflow. First parses the data using the\n * vega-loader read method, then pulses a changeset to the target operator.\n * @param {Operator} target - The Operator to target with ingested data,\n *   typically a Collect transform instance.\n * @param {*} data - The input data, prior to parsing. For JSON this may\n *   be a string or an object. For CSV, TSV, etc should be a string.\n * @param {object} format - The data format description for parsing\n *   loaded data. This object is passed to the vega-loader read method.\n * @returns {Dataflow}\n */\n\nexport function ingest(target, data, format) {\n  return this.pulse(target, this.changeset().insert(parse(data, format)));\n}\n/**\n * Request data from an external source, parse it, and return a Promise.\n * @param {string} url - The URL from which to load the data. This string\n *   is passed to the vega-loader load method.\n * @param {object} [format] - The data format description for parsing\n *   loaded data. This object is passed to the vega-loader read method.\n * @return {Promise} A Promise that resolves upon completion of the request.\n *   The resolved object contains the following properties:\n *   - data: an array of parsed data (or null upon error)\n *   - status: a code for success (0), load fail (-1), or parse fail (-2)\n */\n\nexport async function request(url, format) {\n  const df = this;\n  let status = 0,\n      data;\n\n  try {\n    data = await df.loader().load(url, {\n      context: 'dataflow',\n      response: responseType(format && format.type)\n    });\n\n    try {\n      data = parse(data, format);\n    } catch (err) {\n      status = -2;\n      df.warn('Data ingestion failed', url, err);\n    }\n  } catch (err) {\n    status = -1;\n    df.warn('Loading failed', url, err);\n  }\n\n  return {\n    data,\n    status\n  };\n}\nexport async function preload(target, url, format) {\n  const df = this,\n        pending = df._pending || loadPending(df);\n  pending.requests += 1;\n  const res = await df.request(url, format);\n  df.pulse(target, df.changeset().remove(truthy).insert(res.data || []));\n  pending.done();\n  return res;\n}\n\nfunction loadPending(df) {\n  var pending = new Promise(function (a) {\n    accept = a;\n  }),\n      accept;\n  pending.requests = 0;\n\n  pending.done = function () {\n    if (--pending.requests === 0) {\n      df._pending = null;\n      accept(df);\n    }\n  };\n\n  return df._pending = pending;\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-dataflow/src/dataflow/load.js"],"names":["read","responseType","truthy","parse","ingest","target","data","format","pulse","changeset","insert","request","url","df","status","loader","load","context","response","type","err","warn","preload","pending","_pending","loadPending","requests","res","remove","done","Promise","a","accept"],"mappings":"AAAA,SAAQA,IAAR,EAAcC,YAAd,QAAiC,aAAjC;AACA,SAAQC,MAAR,QAAqB,WAArB;AAEA,OAAO,MAAMC,KAAK,GAAGH,IAAd;AAEP;;;;;;;;;;;;AAWA,OAAO,SAASI,MAAT,CAAgBC,MAAhB,EAAwBC,IAAxB,EAA8BC,MAA9B,EAAsC;AAC3C,SAAO,KAAKC,KAAL,CAAWH,MAAX,EAAmB,KAAKI,SAAL,GAAiBC,MAAjB,CAAwBP,KAAK,CAACG,IAAD,EAAOC,MAAP,CAA7B,CAAnB,CAAP;AACD;AAED;;;;;;;;;;;;AAWA,OAAO,eAAeI,OAAf,CAAuBC,GAAvB,EAA4BL,MAA5B,EAAoC;AACzC,QAAMM,EAAE,GAAG,IAAX;AACA,MAAIC,MAAM,GAAG,CAAb;AAAA,MAAgBR,IAAhB;;AAEA,MAAI;AACFA,IAAAA,IAAI,GAAG,MAAMO,EAAE,CAACE,MAAH,GAAYC,IAAZ,CAAiBJ,GAAjB,EAAsB;AACjCK,MAAAA,OAAO,EAAE,UADwB;AAEjCC,MAAAA,QAAQ,EAAEjB,YAAY,CAACM,MAAM,IAAIA,MAAM,CAACY,IAAlB;AAFW,KAAtB,CAAb;;AAIA,QAAI;AACFb,MAAAA,IAAI,GAAGH,KAAK,CAACG,IAAD,EAAOC,MAAP,CAAZ;AACD,KAFD,CAEE,OAAOa,GAAP,EAAY;AACZN,MAAAA,MAAM,GAAG,CAAC,CAAV;AACAD,MAAAA,EAAE,CAACQ,IAAH,CAAQ,uBAAR,EAAiCT,GAAjC,EAAsCQ,GAAtC;AACD;AACF,GAXD,CAWE,OAAOA,GAAP,EAAY;AACZN,IAAAA,MAAM,GAAG,CAAC,CAAV;AACAD,IAAAA,EAAE,CAACQ,IAAH,CAAQ,gBAAR,EAA0BT,GAA1B,EAA+BQ,GAA/B;AACD;;AAED,SAAO;AAACd,IAAAA,IAAD;AAAOQ,IAAAA;AAAP,GAAP;AACD;AAED,OAAO,eAAeQ,OAAf,CAAuBjB,MAAvB,EAA+BO,GAA/B,EAAoCL,MAApC,EAA4C;AACjD,QAAMM,EAAE,GAAG,IAAX;AAAA,QACMU,OAAO,GAAGV,EAAE,CAACW,QAAH,IAAeC,WAAW,CAACZ,EAAD,CAD1C;AAGAU,EAAAA,OAAO,CAACG,QAAR,IAAoB,CAApB;AAEA,QAAMC,GAAG,GAAG,MAAMd,EAAE,CAACF,OAAH,CAAWC,GAAX,EAAgBL,MAAhB,CAAlB;AACAM,EAAAA,EAAE,CAACL,KAAH,CAASH,MAAT,EAAiBQ,EAAE,CAACJ,SAAH,GAAemB,MAAf,CAAsB1B,MAAtB,EAA8BQ,MAA9B,CAAqCiB,GAAG,CAACrB,IAAJ,IAAY,EAAjD,CAAjB;AAEAiB,EAAAA,OAAO,CAACM,IAAR;AACA,SAAOF,GAAP;AACD;;AAED,SAASF,WAAT,CAAqBZ,EAArB,EAAyB;AACvB,MAAIU,OAAO,GAAG,IAAIO,OAAJ,CAAY,UAASC,CAAT,EAAY;AAAEC,IAAAA,MAAM,GAAGD,CAAT;AAAa,GAAvC,CAAd;AAAA,MACIC,MADJ;AAGAT,EAAAA,OAAO,CAACG,QAAR,GAAmB,CAAnB;;AAEAH,EAAAA,OAAO,CAACM,IAAR,GAAe,YAAW;AACxB,QAAI,EAAEN,OAAO,CAACG,QAAV,KAAuB,CAA3B,EAA8B;AAC5Bb,MAAAA,EAAE,CAACW,QAAH,GAAc,IAAd;AACAQ,MAAAA,MAAM,CAACnB,EAAD,CAAN;AACD;AACF,GALD;;AAOA,SAAQA,EAAE,CAACW,QAAH,GAAcD,OAAtB;AACD","sourcesContent":["import {read, responseType} from 'vega-loader';\nimport {truthy} from 'vega-util';\n\nexport const parse = read;\n\n/**\n * Ingests new data into the dataflow. First parses the data using the\n * vega-loader read method, then pulses a changeset to the target operator.\n * @param {Operator} target - The Operator to target with ingested data,\n *   typically a Collect transform instance.\n * @param {*} data - The input data, prior to parsing. For JSON this may\n *   be a string or an object. For CSV, TSV, etc should be a string.\n * @param {object} format - The data format description for parsing\n *   loaded data. This object is passed to the vega-loader read method.\n * @returns {Dataflow}\n */\nexport function ingest(target, data, format) {\n  return this.pulse(target, this.changeset().insert(parse(data, format)));\n}\n\n/**\n * Request data from an external source, parse it, and return a Promise.\n * @param {string} url - The URL from which to load the data. This string\n *   is passed to the vega-loader load method.\n * @param {object} [format] - The data format description for parsing\n *   loaded data. This object is passed to the vega-loader read method.\n * @return {Promise} A Promise that resolves upon completion of the request.\n *   The resolved object contains the following properties:\n *   - data: an array of parsed data (or null upon error)\n *   - status: a code for success (0), load fail (-1), or parse fail (-2)\n */\nexport async function request(url, format) {\n  const df = this;\n  let status = 0, data;\n\n  try {\n    data = await df.loader().load(url, {\n      context: 'dataflow',\n      response: responseType(format && format.type)\n    });\n    try {\n      data = parse(data, format);\n    } catch (err) {\n      status = -2;\n      df.warn('Data ingestion failed', url, err);\n    }\n  } catch (err) {\n    status = -1;\n    df.warn('Loading failed', url, err);\n  }\n\n  return {data, status};\n}\n\nexport async function preload(target, url, format) {\n  const df = this,\n        pending = df._pending || loadPending(df);\n\n  pending.requests += 1;\n\n  const res = await df.request(url, format);\n  df.pulse(target, df.changeset().remove(truthy).insert(res.data || []));\n\n  pending.done();\n  return res;\n}\n\nfunction loadPending(df) {\n  var pending = new Promise(function(a) { accept = a; }),\n      accept;\n\n  pending.requests = 0;\n\n  pending.done = function() {\n    if (--pending.requests === 0) {\n      df._pending = null;\n      accept(df);\n    }\n  };\n\n  return (df._pending = pending);\n}\n"]},"metadata":{},"sourceType":"module"}