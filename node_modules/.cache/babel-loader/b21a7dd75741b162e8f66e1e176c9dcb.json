{"ast":null,"code":"import { getSecondaryRangeChannel } from '../../channel';\nimport { hasBand, vgField } from '../../channeldef';\nimport { getTimeUnitParts } from '../../timeunit';\nimport { duplicate, hash, keys, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\nexport class TimeUnitNode extends DataFlowNode {\n  constructor(parent, formula) {\n    super(parent);\n    this.formula = formula;\n  }\n\n  clone() {\n    return new TimeUnitNode(null, duplicate(this.formula));\n  }\n\n  static makeFromEncoding(parent, model) {\n    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef, channel) => {\n      const {\n        timeUnit,\n        field\n      } = fieldDef;\n      const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n      const band = isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.markDef, model.config);\n\n      if (timeUnit) {\n        const as = vgField(fieldDef, {\n          forAs: true\n        });\n        timeUnitComponent[hash({\n          as,\n          timeUnit,\n          field\n        })] = Object.assign({\n          as,\n          timeUnit,\n          field\n        }, band ? {\n          band: true\n        } : {});\n      }\n\n      return timeUnitComponent;\n    }, {});\n\n    if (keys(formula).length === 0) {\n      return null;\n    }\n\n    return new TimeUnitNode(parent, formula);\n  }\n\n  static makeFromTransform(parent, t) {\n    const component = Object.assign({}, t);\n    return new TimeUnitNode(parent, {\n      [hash(component)]: component\n    });\n  }\n  /**\n   * Merge together TimeUnitNodes assigning the children of `other` to `this`\n   * and removing `other`.\n   */\n\n\n  merge(other) {\n    this.formula = Object.assign({}, this.formula); // if the same hash happen twice, merge \"band\"\n\n    for (const key in other.formula) {\n      if (!this.formula[key] || other.formula[key].band) {\n        // copy if it's not a duplicate or if we need to include copy band over\n        this.formula[key] = other.formula[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n\n  producedFields() {\n    return new Set(vals(this.formula).map(f => f.as));\n  }\n\n  dependentFields() {\n    return new Set(vals(this.formula).map(f => f.field));\n  }\n\n  hash() {\n    return `TimeUnit ${hash(this.formula)}`;\n  }\n\n  assemble() {\n    const transforms = [];\n\n    for (const f of vals(this.formula)) {\n      const {\n        timeUnit,\n        field,\n        as\n      } = f;\n      transforms.push({\n        field,\n        type: 'timeunit',\n        units: getTimeUnitParts(timeUnit),\n        as: [as, `${as}_end`]\n      });\n    }\n\n    return transforms;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/timeunit.ts"],"names":[],"mappings":"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","sourcesContent":["import {TimeUnitTransform as VgTimeUnitTransform} from 'vega';\nimport {getSecondaryRangeChannel} from '../../channel';\nimport {hasBand, vgField} from '../../channeldef';\nimport {getTimeUnitParts} from '../../timeunit';\nimport {TimeUnitTransform} from '../../transform';\nimport {Dict, duplicate, hash, keys, vals} from '../../util';\nimport {isUnitModel, ModelWithField} from '../model';\nimport {DataFlowNode} from './dataflow';\n\nexport type TimeUnitComponent = TimeUnitTransform & {\n  /** whether to output time unit as a band (generate two formula including start and end) */\n  band?: boolean;\n};\n\nexport class TimeUnitNode extends DataFlowNode {\n  public clone() {\n    return new TimeUnitNode(null, duplicate(this.formula));\n  }\n\n  constructor(parent: DataFlowNode, private formula: Dict<TimeUnitComponent>) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: ModelWithField) {\n    const formula = model.reduceFieldDef((timeUnitComponent: TimeUnitComponent, fieldDef, channel) => {\n      const {timeUnit, field} = fieldDef;\n\n      const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n\n      const band = isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.markDef, model.config);\n\n      if (timeUnit) {\n        const as = vgField(fieldDef, {forAs: true});\n        timeUnitComponent[hash({as, timeUnit, field})] = {\n          as,\n          timeUnit,\n          field,\n          ...(band ? {band: true} : {})\n        };\n      }\n      return timeUnitComponent;\n    }, {} as Dict<TimeUnitComponent>);\n\n    if (keys(formula).length === 0) {\n      return null;\n    }\n\n    return new TimeUnitNode(parent, formula);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: TimeUnitTransform) {\n    const component = {...t};\n\n    return new TimeUnitNode(parent, {\n      [hash(component)]: component\n    });\n  }\n\n  /**\n   * Merge together TimeUnitNodes assigning the children of `other` to `this`\n   * and removing `other`.\n   */\n  public merge(other: TimeUnitNode) {\n    this.formula = {...this.formula};\n\n    // if the same hash happen twice, merge \"band\"\n    for (const key in other.formula) {\n      if (!this.formula[key] || other.formula[key].band) {\n        // copy if it's not a duplicate or if we need to include copy band over\n        this.formula[key] = other.formula[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n\n  public producedFields() {\n    return new Set(vals(this.formula).map(f => f.as));\n  }\n\n  public dependentFields() {\n    return new Set(vals(this.formula).map(f => f.field));\n  }\n\n  public hash() {\n    return `TimeUnit ${hash(this.formula)}`;\n  }\n\n  public assemble() {\n    const transforms: VgTimeUnitTransform[] = [];\n\n    for (const f of vals(this.formula)) {\n      const {timeUnit, field, as} = f;\n\n      transforms.push({\n        field,\n        type: 'timeunit',\n        units: getTimeUnitParts(timeUnit),\n        as: [as, `${as}_end`]\n      });\n    }\n\n    return transforms;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}