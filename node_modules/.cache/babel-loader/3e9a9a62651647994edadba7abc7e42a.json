{"ast":null,"code":"import density2D from './util/density2D';\nimport { ingest, Transform } from 'vega-dataflow';\nimport { accessorName, inherits } from 'vega-util';\n/**\n * Perform 2D kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The [width, height] extent (in\n *   units of input pixels) over which to perform density estimation.\n * @param {function(object): number} params.x - The x-coordinate accessor.\n * @param {function(object): number} params.y - The y-coordinate accessor.\n * @param {function(object): number} [params.weight] - The weight accessor.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n *   This parameter determines the level of spatial approximation. For example,\n *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.\n *   A value of 1 will result in an output raster grid whose dimensions exactly\n *   matches the size parameter.\n * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,\n *   in pixels. The input can be a two-element array specifying separate\n *   x and y bandwidths, or a single-element array specifying both. If the\n *   bandwidth is unspecified or less than zero, the bandwidth will be\n *   automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.as='grid'] - The output field in which to store\n *   the generated raster grid (default 'grid').\n */\n\nexport default function KDE2D(params) {\n  Transform.call(this, null, params);\n}\nKDE2D.Definition = {\n  \"type\": \"KDE2D\",\n  \"metadata\": {\n    \"generates\": true\n  },\n  \"params\": [{\n    \"name\": \"size\",\n    \"type\": \"number\",\n    \"array\": true,\n    \"length\": 2,\n    \"required\": true\n  }, {\n    \"name\": \"x\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"y\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"weight\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"groupby\",\n    \"type\": \"field\",\n    \"array\": true\n  }, {\n    \"name\": \"cellSize\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"bandwidth\",\n    \"type\": \"number\",\n    \"array\": true,\n    \"length\": 2\n  }, {\n    \"name\": \"counts\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"default\": \"grid\"\n  }]\n};\nvar prototype = inherits(KDE2D, Transform);\nconst PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\nexport function params(obj, _) {\n  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);\n  return obj;\n}\n\nprototype.transform = function (_, pulse) {\n  if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      groups = partition(source, _.groupby),\n      names = (_.groupby || []).map(accessorName),\n      kde = params(density2D(), _),\n      as = _.as || 'grid',\n      values = [];\n\n  function set(t, vals) {\n    for (let i = 0; i < names.length; ++i) t[names[i]] = vals[i];\n\n    return t;\n  } // generate density raster grids\n\n\n  values = groups.map(g => ingest(set({\n    [as]: kde(g, _.counts)\n  }, g.dims)));\n  if (this.value) out.rem = this.value;\n  this.value = out.source = out.add = values;\n  return out;\n};\n\nexport function partition(data, groupby) {\n  var groups = [],\n      get = f => f(t),\n      map,\n      i,\n      n,\n      t,\n      k,\n      g; // partition data points into groups\n\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  }\n\n  return groups;\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-geo/src/KDE2D.js"],"names":["density2D","ingest","Transform","accessorName","inherits","KDE2D","params","call","Definition","prototype","PARAMS","obj","_","forEach","param","transform","pulse","value","changed","modified","StopPropagation","out","fork","NO_SOURCE","NO_FIELDS","source","materialize","SOURCE","groups","partition","groupby","names","map","kde","as","values","set","t","vals","i","length","g","counts","dims","rem","add","data","get","f","n","k","push"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,kBAAtB;AACA,SAAQC,MAAR,EAAgBC,SAAhB,QAAgC,eAAhC;AACA,SAAQC,YAAR,EAAsBC,QAAtB,QAAqC,WAArC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,eAAe,SAASC,KAAT,CAAeC,MAAf,EAAuB;AACpCJ,EAAAA,SAAS,CAACK,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;AAEDD,KAAK,CAACG,UAAN,GAAmB;AACjB,UAAQ,OADS;AAEjB,cAAY;AAAC,iBAAa;AAAd,GAFK;AAGjB,YAAU,CACR;AAAE,YAAQ,MAAV;AAAkB,YAAQ,QAA1B;AAAoC,aAAS,IAA7C;AAAmD,cAAU,CAA7D;AAAgE,gBAAY;AAA5E,GADQ,EAER;AAAE,YAAQ,GAAV;AAAe,YAAQ,OAAvB;AAAgC,gBAAY;AAA5C,GAFQ,EAGR;AAAE,YAAQ,GAAV;AAAe,YAAQ,OAAvB;AAAgC,gBAAY;AAA5C,GAHQ,EAIR;AAAE,YAAQ,QAAV;AAAoB,YAAQ;AAA5B,GAJQ,EAKR;AAAE,YAAQ,SAAV;AAAqB,YAAQ,OAA7B;AAAsC,aAAS;AAA/C,GALQ,EAMR;AAAE,YAAQ,UAAV;AAAsB,YAAQ;AAA9B,GANQ,EAOR;AAAE,YAAQ,WAAV;AAAuB,YAAQ,QAA/B;AAAyC,aAAS,IAAlD;AAAwD,cAAU;AAAlE,GAPQ,EAQR;AAAE,YAAQ,QAAV;AAAoB,YAAQ,SAA5B;AAAuC,eAAW;AAAlD,GARQ,EASR;AAAE,YAAQ,IAAV;AAAgB,YAAQ,QAAxB;AAAkC,eAAW;AAA7C,GATQ;AAHO,CAAnB;AAgBA,IAAIC,SAAS,GAAGL,QAAQ,CAACC,KAAD,EAAQH,SAAR,CAAxB;AAEA,MAAMQ,MAAM,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,QAAX,EAAqB,MAArB,EAA6B,UAA7B,EAAyC,WAAzC,CAAf;AAEA,OAAO,SAASJ,MAAT,CAAgBK,GAAhB,EAAqBC,CAArB,EAAwB;AAC7BF,EAAAA,MAAM,CAACG,OAAP,CAAeC,KAAK,IAAIF,CAAC,CAACE,KAAD,CAAD,IAAY,IAAZ,GAAmBH,GAAG,CAACG,KAAD,CAAH,CAAWF,CAAC,CAACE,KAAD,CAAZ,CAAnB,GAA0C,CAAlE;AACA,SAAOH,GAAP;AACD;;AAEDF,SAAS,CAACM,SAAV,GAAsB,UAASH,CAAT,EAAYI,KAAZ,EAAmB;AACvC,MAAI,KAAKC,KAAL,IAAc,CAACD,KAAK,CAACE,OAAN,EAAf,IAAkC,CAACN,CAAC,CAACO,QAAF,EAAvC,EACE,OAAOH,KAAK,CAACI,eAAb;AAEF,MAAIC,GAAG,GAAGL,KAAK,CAACM,IAAN,CAAWN,KAAK,CAACO,SAAN,GAAkBP,KAAK,CAACQ,SAAnC,CAAV;AAAA,MACIC,MAAM,GAAGT,KAAK,CAACU,WAAN,CAAkBV,KAAK,CAACW,MAAxB,EAAgCF,MAD7C;AAAA,MAEIG,MAAM,GAAGC,SAAS,CAACJ,MAAD,EAASb,CAAC,CAACkB,OAAX,CAFtB;AAAA,MAGIC,KAAK,GAAG,CAACnB,CAAC,CAACkB,OAAF,IAAa,EAAd,EAAkBE,GAAlB,CAAsB7B,YAAtB,CAHZ;AAAA,MAII8B,GAAG,GAAG3B,MAAM,CAACN,SAAS,EAAV,EAAcY,CAAd,CAJhB;AAAA,MAKIsB,EAAE,GAAGtB,CAAC,CAACsB,EAAF,IAAQ,MALjB;AAAA,MAMIC,MAAM,GAAG,EANb;;AAQA,WAASC,GAAT,CAAaC,CAAb,EAAgBC,IAAhB,EAAsB;AACpB,SAAK,IAAIC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAACR,KAAK,CAACS,MAAtB,EAA8B,EAAED,CAAhC,EAAmCF,CAAC,CAACN,KAAK,CAACQ,CAAD,CAAN,CAAD,GAAcD,IAAI,CAACC,CAAD,CAAlB;;AACnC,WAAOF,CAAP;AACD,GAfsC,CAiBvC;;;AACAF,EAAAA,MAAM,GAAGP,MAAM,CAACI,GAAP,CAAWS,CAAC,IAAIxC,MAAM,CAC7BmC,GAAG,CAAC;AAAC,KAACF,EAAD,GAAMD,GAAG,CAACQ,CAAD,EAAI7B,CAAC,CAAC8B,MAAN;AAAV,GAAD,EAA2BD,CAAC,CAACE,IAA7B,CAD0B,CAAtB,CAAT;AAIA,MAAI,KAAK1B,KAAT,EAAgBI,GAAG,CAACuB,GAAJ,GAAU,KAAK3B,KAAf;AAChB,OAAKA,KAAL,GAAaI,GAAG,CAACI,MAAJ,GAAaJ,GAAG,CAACwB,GAAJ,GAAUV,MAApC;AAEA,SAAOd,GAAP;AACD,CA1BD;;AA4BA,OAAO,SAASQ,SAAT,CAAmBiB,IAAnB,EAAyBhB,OAAzB,EAAkC;AACvC,MAAIF,MAAM,GAAG,EAAb;AAAA,MACImB,GAAG,GAAGC,CAAC,IAAIA,CAAC,CAACX,CAAD,CADhB;AAAA,MAEIL,GAFJ;AAAA,MAESO,CAFT;AAAA,MAEYU,CAFZ;AAAA,MAEeZ,CAFf;AAAA,MAEkBa,CAFlB;AAAA,MAEqBT,CAFrB,CADuC,CAKvC;;;AACA,MAAIX,OAAO,IAAI,IAAf,EAAqB;AACnBF,IAAAA,MAAM,CAACuB,IAAP,CAAYL,IAAZ;AACD,GAFD,MAEO;AACL,SAAKd,GAAG,GAAC,EAAJ,EAAQO,CAAC,GAAC,CAAV,EAAaU,CAAC,GAACH,IAAI,CAACN,MAAzB,EAAiCD,CAAC,GAACU,CAAnC,EAAsC,EAAEV,CAAxC,EAA2C;AACzCF,MAAAA,CAAC,GAAGS,IAAI,CAACP,CAAD,CAAR;AACAW,MAAAA,CAAC,GAAGpB,OAAO,CAACE,GAAR,CAAYe,GAAZ,CAAJ;AACAN,MAAAA,CAAC,GAAGT,GAAG,CAACkB,CAAD,CAAP;;AACA,UAAI,CAACT,CAAL,EAAQ;AACNT,QAAAA,GAAG,CAACkB,CAAD,CAAH,GAAUT,CAAC,GAAG,EAAd;AACAA,QAAAA,CAAC,CAACE,IAAF,GAASO,CAAT;AACAtB,QAAAA,MAAM,CAACuB,IAAP,CAAYV,CAAZ;AACD;;AACDA,MAAAA,CAAC,CAACU,IAAF,CAAOd,CAAP;AACD;AACF;;AAED,SAAOT,MAAP;AACD","sourcesContent":["import density2D from './util/density2D';\nimport {ingest, Transform} from 'vega-dataflow';\nimport {accessorName, inherits} from 'vega-util';\n\n/**\n * Perform 2D kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The [width, height] extent (in\n *   units of input pixels) over which to perform density estimation.\n * @param {function(object): number} params.x - The x-coordinate accessor.\n * @param {function(object): number} params.y - The y-coordinate accessor.\n * @param {function(object): number} [params.weight] - The weight accessor.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n *   This parameter determines the level of spatial approximation. For example,\n *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.\n *   A value of 1 will result in an output raster grid whose dimensions exactly\n *   matches the size parameter.\n * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,\n *   in pixels. The input can be a two-element array specifying separate\n *   x and y bandwidths, or a single-element array specifying both. If the\n *   bandwidth is unspecified or less than zero, the bandwidth will be\n *   automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.as='grid'] - The output field in which to store\n *   the generated raster grid (default 'grid').\n */\nexport default function KDE2D(params) {\n  Transform.call(this, null, params);\n}\n\nKDE2D.Definition = {\n  \"type\": \"KDE2D\",\n  \"metadata\": {\"generates\": true},\n  \"params\": [\n    { \"name\": \"size\", \"type\": \"number\", \"array\": true, \"length\": 2, \"required\": true },\n    { \"name\": \"x\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"y\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"weight\", \"type\": \"field\" },\n    { \"name\": \"groupby\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"cellSize\", \"type\": \"number\" },\n    { \"name\": \"bandwidth\", \"type\": \"number\", \"array\": true, \"length\": 2 },\n    { \"name\": \"counts\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"as\", \"type\": \"string\", \"default\": \"grid\"}\n  ]\n};\n\nvar prototype = inherits(KDE2D, Transform);\n\nconst PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\n\nexport function params(obj, _) {\n  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);\n  return obj;\n}\n\nprototype.transform = function(_, pulse) {\n  if (this.value && !pulse.changed() && !_.modified())\n    return pulse.StopPropagation;\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      groups = partition(source, _.groupby),\n      names = (_.groupby || []).map(accessorName),\n      kde = params(density2D(), _),\n      as = _.as || 'grid',\n      values = [];\n\n  function set(t, vals) {\n    for (let i=0; i<names.length; ++i) t[names[i]] = vals[i];\n    return t;\n  }\n\n  // generate density raster grids\n  values = groups.map(g => ingest(\n    set({[as]: kde(g, _.counts)}, g.dims)\n  ));\n\n  if (this.value) out.rem = this.value;\n  this.value = out.source = out.add = values;\n\n  return out;\n};\n\nexport function partition(data, groupby) {\n  var groups = [],\n      get = f => f(t),\n      map, i, n, t, k, g;\n\n  // partition data points into groups\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map={}, i=0, n=data.length; i<n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = (g = []);\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n"]},"metadata":{},"sourceType":"module"}