{"ast":null,"code":"import { isNumber } from 'vega-util';\nimport { isBinned, isBinning } from '../../../bin';\nimport { X, X2, Y2 } from '../../../channel';\nimport { getBand, getTypedFieldDef, isFieldDef, isPositionFieldDef, isValueDef } from '../../../channeldef';\nimport { DEFAULT_STEP, getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { hasDiscreteDomain, ScaleType } from '../../../scale';\nimport { getFirstDefined } from '../../../util';\nimport { isVgRangeStep } from '../../../vega.schema';\nimport { getMarkConfig } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { alignedPositionChannel } from './position-align';\nimport { pointPosition } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel, mark) {\n  var _a, _b, _c, _d;\n\n  const {\n    config,\n    encoding,\n    markDef\n  } = model;\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  const fieldDef = encoding[channel];\n  const fieldDef2 = encoding[channel2];\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const scaleName = model.scaleName(channel);\n  const orient = markDef.orient;\n  const hasSizeDef = (_d = (_c = (_b = (_a = encoding[sizeChannel], _a !== null && _a !== void 0 ? _a : encoding.size), _b !== null && _b !== void 0 ? _b : markDef[sizeChannel]), _c !== null && _c !== void 0 ? _c : markDef.size), _d !== null && _d !== void 0 ? _d : getMarkConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  }));\n  const isBarBand = channel === 'x' ? orient === 'vertical' : orient === 'horizontal'; // x, x2, and width -- we must specify two of these in all conditions\n\n  if (isFieldDef(fieldDef) && (isBinning(fieldDef.bin) || isBinned(fieldDef.bin) || fieldDef.timeUnit && !fieldDef2) && !hasSizeDef && !hasDiscreteDomain(scaleType)) {\n    const band = getBand(channel, fieldDef, undefined, markDef, config);\n    return rectBinPosition({\n      fieldDef,\n      fieldDef2,\n      channel,\n      markDef,\n      scaleName,\n      band,\n      spacing: getFirstDefined(markDef.binSpacing, config[mark].binSpacing),\n      reverse: scale.get('reverse')\n    });\n  } else if ((isFieldDef(fieldDef) && hasDiscreteDomain(scaleType) || isBarBand) && !fieldDef2) {\n    // vertical\n    if (isFieldDef(fieldDef) && scaleType === ScaleType.BAND) {\n      const band = isPositionFieldDef(fieldDef) ? fieldDef.band : undefined;\n      return rectBandPosition(fieldDef, channel, model, defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config, band));\n    } // sized bin, normal point-ordinal axis, quantitative x-axis, or no x\n\n\n    return centeredPointPositionWithSize(channel, model, defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config));\n  } else {\n    return rangePosition(channel, model, {\n      defaultPos: 'zeroOrMax',\n      defaultPos2: 'zeroOrMin'\n    });\n  }\n}\n\nfunction centeredPointPositionWithSize(channel, model, sizeRef) {\n  const centerChannel = channel === 'x' ? 'xc' : 'yc';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return Object.assign(Object.assign({}, pointPosition(channel, model, {\n    defaultPos: 'mid',\n    vgChannel: centerChannel\n  })), nonPosition('size', model, {\n    defaultRef: sizeRef,\n    vgChannel: sizeChannel\n  }));\n}\n\nfunction defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config, band) {\n  const markPropOrConfig = getFirstDefined(markDef[sizeChannel], markDef.size, // TODO: deal with sizeChannel config\n  getMarkConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  }));\n\n  if (markPropOrConfig !== undefined) {\n    return {\n      value: markPropOrConfig\n    };\n  }\n\n  if (scale) {\n    const scaleType = scale.get('type');\n\n    if (scaleType === 'point' || scaleType === 'band') {\n      if (config[mark].discreteBandSize !== undefined) {\n        return {\n          value: config[mark].discreteBandSize\n        };\n      }\n\n      if (scaleType === ScaleType.POINT) {\n        const scaleRange = scale.get('range');\n\n        if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n          return {\n            value: scaleRange.step - 2\n          };\n        }\n\n        return {\n          value: DEFAULT_STEP - 2\n        };\n      } else {\n        // BAND\n        return bandRef(scaleName, band);\n      }\n    } else {\n      // continuous scale\n      return {\n        value: config[mark].continuousBandSize\n      };\n    }\n  } // No Scale\n\n\n  const step = getViewConfigDiscreteStep(config.view, sizeChannel);\n  const value = getFirstDefined( // No scale is like discrete bar (with one item)\n  config[mark].discreteBandSize, step - 2);\n  return {\n    value\n  };\n}\n\nfunction bandRef(scaleName, band = true) {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\nfunction rectBandPosition(fieldDef, channel, model, sizeRef) {\n  var _a;\n\n  const scaleName = model.scaleName(channel);\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  const {\n    markDef,\n    encoding,\n    config\n  } = model;\n  const vgChannel = alignedPositionChannel(channel, markDef, config);\n  const centeredBandPositionMixins = {\n    [vgChannel]: ref.fieldRef(fieldDef, scaleName, {}, {\n      band: 0.5\n    })\n  };\n\n  if (encoding.size || markDef.size !== null && markDef.size !== undefined) {\n    const orient = markDef.orient;\n\n    if (orient) {\n      if (getTypedFieldDef(encoding.size) || isValueDef(encoding.size)) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), nonPosition('size', model, {\n          vgChannel: sizeChannel\n        }));\n      } else if (markDef.size !== undefined) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), {\n          [sizeChannel]: {\n            value: markDef.size\n          }\n        });\n      }\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  }\n\n  if (((_a = sizeRef) === null || _a === void 0 ? void 0 : _a.value) !== undefined) {\n    return Object.assign(Object.assign({}, centeredBandPositionMixins), {\n      [sizeChannel]: sizeRef\n    });\n  }\n\n  const {\n    band = 1\n  } = fieldDef;\n  return {\n    // FIXME: make offset work correctly here when we support group bar (https://github.com/vega/vega-lite/issues/396)\n    [channel]: ref.fieldRef(fieldDef, scaleName, {\n      binSuffix: 'range'\n    }, {\n      band: (1 - band) / 2\n    }),\n    [sizeChannel]: sizeRef !== null && sizeRef !== void 0 ? sizeRef : bandRef(scaleName, band)\n  };\n}\n\nexport function rectBinPosition({\n  fieldDef,\n  fieldDef2,\n  channel,\n  band,\n  scaleName,\n  markDef,\n  spacing = 0,\n  reverse\n}) {\n  const binSpacing = {\n    x: reverse ? spacing : 0,\n    x2: reverse ? 0 : spacing,\n    y: reverse ? 0 : spacing,\n    y2: reverse ? spacing : 0\n  };\n  const channel2 = channel === X ? X2 : Y2;\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    return {\n      [channel2]: rectBinRef({\n        channel,\n        fieldDef,\n        scaleName,\n        markDef,\n        band: (1 - band) / 2,\n        offset: binSpacing[`${channel}2`]\n      }),\n      [channel]: rectBinRef({\n        channel,\n        fieldDef,\n        scaleName,\n        markDef,\n        band: 1 - (1 - band) / 2,\n        offset: binSpacing[channel]\n      })\n    };\n  } else if (isBinned(fieldDef.bin) && isFieldDef(fieldDef2)) {\n    return {\n      [channel2]: ref.fieldRef(fieldDef, scaleName, {}, {\n        offset: binSpacing[`${channel}2`]\n      }),\n      [channel]: ref.fieldRef(fieldDef2, scaleName, {}, {\n        offset: binSpacing[channel]\n      })\n    };\n  } else {\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n  }\n}\n/**\n * Value Ref for binned fields\n */\n\nexport function rectBinRef({\n  channel,\n  fieldDef,\n  scaleName,\n  markDef,\n  band,\n  offset\n}) {\n  const r = ref.interpolatedSignalRef({\n    scaleName,\n    fieldDef,\n    band,\n    offset\n  });\n  return ref.wrapPositionInvalidTest({\n    fieldDef,\n    channel,\n    markDef,\n    ref: r\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-rect.ts"],"names":[],"mappings":"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","sourcesContent":["import {isNumber} from 'vega-util';\nimport {isBinned, isBinning} from '../../../bin';\nimport {PositionChannel, X, X2, Y2} from '../../../channel';\nimport {\n  getBand,\n  getTypedFieldDef,\n  isFieldDef,\n  isPositionFieldDef,\n  isValueDef,\n  PositionFieldDef,\n  SecondaryFieldDef,\n  TypedFieldDef,\n  ValueDef\n} from '../../../channeldef';\nimport {Config, DEFAULT_STEP, getViewConfigDiscreteStep} from '../../../config';\nimport * as log from '../../../log';\nimport {Mark, MarkDef} from '../../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../../scale';\nimport {getFirstDefined} from '../../../util';\nimport {isVgRangeStep, VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getMarkConfig} from '../../common';\nimport {ScaleComponent} from '../../scale/component';\nimport {UnitModel} from '../../unit';\nimport {nonPosition} from './nonposition';\nimport {alignedPositionChannel} from './position-align';\nimport {pointPosition} from './position-point';\nimport {rangePosition} from './position-range';\nimport * as ref from './valueref';\n\nexport function rectPosition(model: UnitModel, channel: 'x' | 'y', mark: 'bar' | 'rect' | 'image'): VgEncodeEntry {\n  const {config, encoding, markDef} = model;\n\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  const fieldDef = encoding[channel];\n  const fieldDef2 = encoding[channel2];\n\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const scaleName = model.scaleName(channel);\n\n  const orient = markDef.orient;\n  const hasSizeDef =\n    encoding[sizeChannel] ??\n    encoding.size ??\n    markDef[sizeChannel] ??\n    markDef.size ??\n    getMarkConfig('size', markDef, config, {vgChannel: sizeChannel});\n\n  const isBarBand = channel === 'x' ? orient === 'vertical' : orient === 'horizontal';\n\n  // x, x2, and width -- we must specify two of these in all conditions\n  if (\n    isFieldDef(fieldDef) &&\n    (isBinning(fieldDef.bin) || isBinned(fieldDef.bin) || (fieldDef.timeUnit && !fieldDef2)) &&\n    !hasSizeDef &&\n    !hasDiscreteDomain(scaleType)\n  ) {\n    const band = getBand(channel, fieldDef, undefined, markDef, config);\n\n    return rectBinPosition({\n      fieldDef,\n      fieldDef2,\n      channel,\n      markDef,\n      scaleName,\n      band,\n      spacing: getFirstDefined(markDef.binSpacing, config[mark].binSpacing),\n      reverse: scale.get('reverse')\n    });\n  } else if (((isFieldDef(fieldDef) && hasDiscreteDomain(scaleType)) || isBarBand) && !fieldDef2) {\n    // vertical\n    if (isFieldDef(fieldDef) && scaleType === ScaleType.BAND) {\n      const band = isPositionFieldDef(fieldDef) ? fieldDef.band : undefined;\n      return rectBandPosition(\n        fieldDef,\n        channel,\n        model,\n        defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config, band)\n      );\n    }\n\n    // sized bin, normal point-ordinal axis, quantitative x-axis, or no x\n    return centeredPointPositionWithSize(\n      channel,\n      model,\n      defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config)\n    );\n  } else {\n    return rangePosition(channel, model, {defaultPos: 'zeroOrMax', defaultPos2: 'zeroOrMin'});\n  }\n}\n\nfunction centeredPointPositionWithSize(channel: 'x' | 'y', model: UnitModel, sizeRef: VgValueRef) {\n  const centerChannel: 'xc' | 'yc' = channel === 'x' ? 'xc' : 'yc';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return {\n    ...pointPosition(channel, model, {defaultPos: 'mid', vgChannel: centerChannel}),\n    ...nonPosition('size', model, {defaultRef: sizeRef, vgChannel: sizeChannel})\n  };\n}\n\nfunction defaultSizeRef(\n  mark: 'bar' | 'rect' | 'image',\n  markDef: MarkDef,\n  sizeChannel: 'width' | 'height',\n  scaleName: string,\n  scale: ScaleComponent,\n  config: Config,\n  band?: number\n): VgValueRef {\n  const markPropOrConfig = getFirstDefined(\n    markDef[sizeChannel],\n    markDef.size,\n    // TODO: deal with sizeChannel config\n    getMarkConfig('size', markDef, config, {vgChannel: sizeChannel})\n  );\n\n  if (markPropOrConfig !== undefined) {\n    return {value: markPropOrConfig};\n  }\n\n  if (scale) {\n    const scaleType = scale.get('type');\n    if (scaleType === 'point' || scaleType === 'band') {\n      if (config[mark].discreteBandSize !== undefined) {\n        return {value: config[mark].discreteBandSize};\n      }\n      if (scaleType === ScaleType.POINT) {\n        const scaleRange = scale.get('range');\n        if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n          return {value: scaleRange.step - 2};\n        }\n        return {value: DEFAULT_STEP - 2};\n      } else {\n        // BAND\n        return bandRef(scaleName, band);\n      }\n    } else {\n      // continuous scale\n      return {value: config[mark].continuousBandSize};\n    }\n  }\n  // No Scale\n\n  const step = getViewConfigDiscreteStep(config.view, sizeChannel);\n\n  const value = getFirstDefined(\n    // No scale is like discrete bar (with one item)\n    config[mark].discreteBandSize,\n    step - 2\n  );\n  return {value};\n}\n\nfunction bandRef(scaleName: string, band: number | boolean = true): VgValueRef {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\nfunction rectBandPosition(\n  fieldDef: PositionFieldDef<string>,\n  channel: 'x' | 'y',\n  model: UnitModel,\n  sizeRef?: VgValueRef\n) {\n  const scaleName = model.scaleName(channel);\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  const {markDef, encoding, config} = model;\n\n  const vgChannel = alignedPositionChannel(channel, markDef, config);\n\n  const centeredBandPositionMixins = {\n    [vgChannel]: ref.fieldRef(fieldDef, scaleName, {}, {band: 0.5})\n  };\n\n  if (encoding.size || (markDef.size !== null && markDef.size !== undefined)) {\n    const orient = markDef.orient;\n    if (orient) {\n      if (getTypedFieldDef(encoding.size) || isValueDef(encoding.size)) {\n        return {\n          ...centeredBandPositionMixins,\n          ...nonPosition('size', model, {vgChannel: sizeChannel})\n        };\n      } else if (markDef.size !== undefined) {\n        return {\n          ...centeredBandPositionMixins,\n          [sizeChannel]: {value: markDef.size}\n        };\n      }\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  }\n\n  if (sizeRef?.value !== undefined) {\n    return {\n      ...centeredBandPositionMixins,\n      [sizeChannel]: sizeRef\n    };\n  }\n  const {band = 1} = fieldDef;\n\n  return {\n    // FIXME: make offset work correctly here when we support group bar (https://github.com/vega/vega-lite/issues/396)\n    [channel]: ref.fieldRef(fieldDef, scaleName, {binSuffix: 'range'}, {band: (1 - band) / 2}),\n    [sizeChannel]: sizeRef ?? bandRef(scaleName, band)\n  };\n}\n\nexport function rectBinPosition({\n  fieldDef,\n  fieldDef2,\n  channel,\n  band,\n  scaleName,\n  markDef,\n  spacing = 0,\n  reverse\n}: {\n  fieldDef: TypedFieldDef<string>;\n  fieldDef2?: ValueDef | SecondaryFieldDef<string>;\n  channel: 'x' | 'y';\n  band: number;\n  scaleName: string;\n  markDef: MarkDef<Mark>;\n  spacing?: number;\n  reverse: boolean;\n}) {\n  const binSpacing = {\n    x: reverse ? spacing : 0,\n    x2: reverse ? 0 : spacing,\n    y: reverse ? 0 : spacing,\n    y2: reverse ? spacing : 0\n  } as const;\n  const channel2 = channel === X ? X2 : Y2;\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    return {\n      [channel2]: rectBinRef({\n        channel,\n        fieldDef,\n        scaleName,\n        markDef,\n        band: (1 - band) / 2,\n        offset: binSpacing[`${channel}2`]\n      }),\n      [channel]: rectBinRef({\n        channel,\n        fieldDef,\n        scaleName,\n        markDef,\n        band: 1 - (1 - band) / 2,\n        offset: binSpacing[channel]\n      })\n    };\n  } else if (isBinned(fieldDef.bin) && isFieldDef(fieldDef2)) {\n    return {\n      [channel2]: ref.fieldRef(fieldDef, scaleName, {}, {offset: binSpacing[`${channel}2`]}),\n      [channel]: ref.fieldRef(fieldDef2, scaleName, {}, {offset: binSpacing[channel]})\n    };\n  } else {\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n  }\n}\n\n/**\n * Value Ref for binned fields\n */\nexport function rectBinRef({\n  channel,\n  fieldDef,\n  scaleName,\n  markDef,\n  band,\n  offset\n}: {\n  channel: PositionChannel;\n  fieldDef: TypedFieldDef<string>;\n  scaleName: string;\n  markDef: MarkDef<Mark>;\n  band: number;\n  offset?: number;\n}) {\n  const r = ref.interpolatedSignalRef({\n    scaleName,\n    fieldDef,\n    band,\n    offset\n  });\n\n  return ref.wrapPositionInvalidTest({\n    fieldDef,\n    channel,\n    markDef,\n    ref: r\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}