{"ast":null,"code":"import { isGenerator, isGraticuleGenerator, isInlineData, isNamedData, isSequenceGenerator, isUrlData, MAIN, RAW } from '../../data';\nimport * as log from '../../log';\nimport { isAggregate, isBin, isCalculate, isDensity, isFilter, isFlatten, isFold, isImpute, isJoinAggregate, isLoess, isLookup, isPivot, isQuantile, isRegression, isSample, isStack, isTimeUnit, isWindow } from '../../transform';\nimport { deepEqual, mergeDeep } from '../../util';\nimport { isFacetModel, isLayerModel, isUnitModel } from '../model';\nimport { requiresSelectionId } from '../selection';\nimport { materializeSelections } from '../selection/parse';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { getImplicitFromEncoding, getImplicitFromFilterTransform, getImplicitFromSelection, ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { AncestorParse } from '.';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { makeJoinAggregateFromFacet } from './joinaggregatefacet';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { PivotTransformNode } from './pivot';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\nexport function findSource(data, sources) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n  for (const other of sources) {\n    const otherData = other.data; // if both datasets have a name defined, we cannot merge\n\n    if (data.name && other.hasName() && data.name !== other.dataName) {\n      continue;\n    } // feature and mesh are mutually exclusive\n\n\n    if (((_a = data['format']) === null || _a === void 0 ? void 0 : _a.mesh) && ((_b = otherData.format) === null || _b === void 0 ? void 0 : _b.feature)) {\n      continue;\n    } // we have to extract the same feature or mesh\n\n\n    if ((((_c = data['format']) === null || _c === void 0 ? void 0 : _c.feature) || ((_d = otherData.format) === null || _d === void 0 ? void 0 : _d.feature)) && ((_e = data['format']) === null || _e === void 0 ? void 0 : _e.feature) !== ((_f = otherData.format) === null || _f === void 0 ? void 0 : _f.feature)) {\n      continue;\n    }\n\n    if ((((_g = data['format']) === null || _g === void 0 ? void 0 : _g.mesh) || ((_h = otherData.format) === null || _h === void 0 ? void 0 : _h.mesh)) && ((_j = data['format']) === null || _j === void 0 ? void 0 : _j.mesh) !== ((_k = otherData.format) === null || _k === void 0 ? void 0 : _k.mesh)) {\n      continue;\n    }\n\n    if (isInlineData(data) && isInlineData(otherData)) {\n      if (deepEqual(data.values, otherData.values)) {\n        return other;\n      }\n    } else if (isUrlData(data) && isUrlData(otherData)) {\n      if (data.url === otherData.url) {\n        return other;\n      }\n    } else if (isNamedData(data)) {\n      if (data.name === other.dataName) {\n        return other;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction parseRoot(model, sources) {\n  if (model.data || !model.parent) {\n    // if the model defines a data source or is the root, create a source node\n    if (model.data === null) {\n      // data: null means we should ignore the parent's data so we just create a new data source\n      const source = new SourceNode([]);\n      sources.push(source);\n      return source;\n    }\n\n    const existingSource = findSource(model.data, sources);\n\n    if (existingSource) {\n      if (!isGenerator(model.data)) {\n        existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);\n      } // if the new source has a name but the existing one does not, we can set it\n\n\n      if (!existingSource.hasName() && model.data.name) {\n        existingSource.dataName = model.data.name;\n      }\n\n      return existingSource;\n    } else {\n      const source = new SourceNode(model.data);\n      sources.push(source);\n      return source;\n    }\n  } else {\n    // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;\n  }\n}\n/**\n * Parses a transform array into a chain of connected dataflow nodes.\n */\n\n\nexport function parseTransformArray(head, model, ancestorParse) {\n  var _a, _b;\n\n  let lookupCounter = 0;\n\n  for (const t of model.transforms) {\n    let derivedType = undefined;\n    let transformNode;\n\n    if (isCalculate(t)) {\n      transformNode = head = new CalculateNode(head, t);\n      derivedType = 'derived';\n    } else if (isFilter(t)) {\n      const implicit = getImplicitFromFilterTransform(t);\n      transformNode = head = (_a = ParseNode.makeWithAncestors(head, {}, implicit, ancestorParse), _a !== null && _a !== void 0 ? _a : head);\n      head = new FilterNode(head, model, t.filter);\n    } else if (isBin(t)) {\n      transformNode = head = BinNode.makeFromTransform(head, t, model);\n      derivedType = 'number';\n    } else if (isTimeUnit(t)) {\n      derivedType = 'date';\n      const parsedAs = ancestorParse.getWithExplicit(t.field); // Create parse node because the input to time unit is always date.\n\n      if (parsedAs.value === undefined) {\n        head = new ParseNode(head, {\n          [t.field]: derivedType\n        });\n        ancestorParse.set(t.field, derivedType, false);\n      }\n\n      transformNode = head = TimeUnitNode.makeFromTransform(head, t);\n    } else if (isAggregate(t)) {\n      transformNode = head = AggregateNode.makeFromTransform(head, t);\n      derivedType = 'number';\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    } else if (isLookup(t)) {\n      transformNode = head = LookupNode.make(head, model, t, lookupCounter++);\n      derivedType = 'derived';\n    } else if (isWindow(t)) {\n      transformNode = head = new WindowTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isJoinAggregate(t)) {\n      transformNode = head = new JoinAggregateTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isStack(t)) {\n      transformNode = head = StackNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isFold(t)) {\n      transformNode = head = new FoldTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isFlatten(t)) {\n      transformNode = head = new FlattenTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isPivot(t)) {\n      transformNode = head = new PivotTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isSample(t)) {\n      head = new SampleTransformNode(head, t);\n    } else if (isImpute(t)) {\n      transformNode = head = ImputeNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isDensity(t)) {\n      transformNode = head = new DensityTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isQuantile(t)) {\n      transformNode = head = new QuantileTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isRegression(t)) {\n      transformNode = head = new RegressionTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isLoess(t)) {\n      transformNode = head = new LoessTransformNode(head, t);\n      derivedType = 'derived';\n    } else {\n      log.warn(log.message.invalidTransformIgnored(t));\n      continue;\n    }\n\n    if (transformNode && derivedType !== undefined) {\n      for (const field of (_b = transformNode.producedFields(), _b !== null && _b !== void 0 ? _b : [])) {\n        ancestorParse.set(field, derivedType, false);\n      }\n    }\n  }\n\n  return head;\n}\n/*\nDescription of the dataflow (http://asciiflow.com/):\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n     FormatParse\n     (explicit)\n         |\n         v\n     Transforms\n(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)\n         |\n         v\n     FormatParse\n     (implicit)\n         |\n         v\n Binning (in `encoding`)\n         |\n         v\n Timeunit (in `encoding`)\n         |\n         v\nFormula From Sort Array\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n  Aggregate (in `encoding`)\n         |\n         v\n  Stack (in `encoding`)\n         |\n         v\n  Invalid Filter\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n*/\n\nexport function parseData(model) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n  let head = parseRoot(model, model.component.data.sources);\n  const {\n    outputNodes,\n    outputNodeRefCounts\n  } = model.component.data;\n  const ancestorParse = model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();\n  const data = model.data;\n\n  if (isGenerator(data)) {\n    // insert generator transform\n    if (isSequenceGenerator(data)) {\n      head = new SequenceNode(head, data.sequence);\n    } else if (isGraticuleGenerator(data)) {\n      head = new GraticuleNode(head, data.graticule);\n    } // no parsing necessary for generator\n\n\n    ancestorParse.parseNothing = true;\n  } else if (((_b = (_a = data) === null || _a === void 0 ? void 0 : _a.format) === null || _b === void 0 ? void 0 : _b.parse) === null) {\n    // format.parse: null means disable parsing\n    ancestorParse.parseNothing = true;\n  }\n\n  head = (_c = ParseNode.makeExplicit(head, model, ancestorParse), _c !== null && _c !== void 0 ? _c : head); // Default discrete selections require an identifer transform to\n  // uniquely identify data points. Add this transform at the head of\n  // the pipeline such that the identifier field is available for all\n  // subsequent datasets. During optimization, we will remove this\n  // transform if it proves to be unnecessary. Additional identifier\n  // transforms will be necessary when new tuples are constructed\n  // (e.g., post-aggregation).\n\n  head = new IdentifierNode(head); // HACK: This is equivalent for merging bin extent for union scale.\n  // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale\n\n  const parentIsLayer = model.parent && isLayerModel(model.parent);\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (parentIsLayer) {\n      head = (_d = BinNode.makeFromEncoding(head, model), _d !== null && _d !== void 0 ? _d : head);\n    }\n  }\n\n  if (model.transforms.length > 0) {\n    head = parseTransformArray(head, model, ancestorParse);\n  } // create parse nodes for fields that need to be parsed (or flattened) implicitly\n\n\n  const implicitSelection = getImplicitFromSelection(model);\n  const implicitEncoding = getImplicitFromEncoding(model);\n  head = (_e = ParseNode.makeWithAncestors(head, {}, Object.assign(Object.assign({}, implicitSelection), implicitEncoding), ancestorParse), _e !== null && _e !== void 0 ? _e : head);\n\n  if (isUnitModel(model)) {\n    head = GeoJSONNode.parseAll(head, model);\n    head = GeoPointNode.parseAll(head, model);\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (!parentIsLayer) {\n      head = (_f = BinNode.makeFromEncoding(head, model), _f !== null && _f !== void 0 ? _f : head);\n    }\n\n    head = (_g = TimeUnitNode.makeFromEncoding(head, model), _g !== null && _g !== void 0 ? _g : head);\n    head = CalculateNode.parseAllForSortIndex(head, model);\n  } // add an output node pre aggregation\n\n\n  const rawName = model.getName(RAW);\n  const raw = new OutputNode(head, rawName, RAW, outputNodeRefCounts);\n  outputNodes[rawName] = raw;\n  head = raw;\n\n  if (isUnitModel(model)) {\n    const agg = AggregateNode.makeFromEncoding(head, model);\n\n    if (agg) {\n      head = agg;\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    }\n\n    head = (_h = ImputeNode.makeFromEncoding(head, model), _h !== null && _h !== void 0 ? _h : head);\n    head = (_j = StackNode.makeFromEncoding(head, model), _j !== null && _j !== void 0 ? _j : head);\n  }\n\n  if (isUnitModel(model)) {\n    head = (_k = FilterInvalidNode.make(head, model), _k !== null && _k !== void 0 ? _k : head);\n  } // output node for marks\n\n\n  const mainName = model.getName(MAIN);\n  const main = new OutputNode(head, mainName, MAIN, outputNodeRefCounts);\n  outputNodes[mainName] = main;\n  head = main;\n\n  if (isUnitModel(model)) {\n    materializeSelections(model, main);\n  } // add facet marker\n\n\n  let facetRoot = null;\n\n  if (isFacetModel(model)) {\n    const facetName = model.getName('facet'); // Derive new sort index field for facet's sort array\n\n    head = CalculateNode.parseAllForSortIndex(head, model); // Derive new aggregate for facet's sort field\n    // augment data source with new fields for crossed facet\n\n    head = (_l = makeJoinAggregateFromFacet(head, model.facet), _l !== null && _l !== void 0 ? _l : head);\n    facetRoot = new FacetNode(head, model, facetName, main.getSource());\n    outputNodes[facetName] = facetRoot;\n    head = facetRoot;\n  }\n\n  return Object.assign(Object.assign({}, model.component.data), {\n    outputNodes,\n    outputNodeRefCounts,\n    raw,\n    main,\n    facetRoot,\n    ancestorParse\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/data/parse.ts"],"names":[],"mappings":"AAAA,SAEE,WAFF,EAGE,oBAHF,EAIE,YAJF,EAKE,WALF,EAME,mBANF,EAOE,SAPF,EAQE,IARF,EAUE,GAVF,QAWO,YAXP;AAYA,OAAO,KAAK,GAAZ,MAAqB,WAArB;AACA,SACE,WADF,EAEE,KAFF,EAGE,WAHF,EAIE,SAJF,EAKE,QALF,EAME,SANF,EAOE,MAPF,EAQE,QARF,EASE,eATF,EAUE,OAVF,EAWE,QAXF,EAYE,OAZF,EAaE,UAbF,EAcE,YAdF,EAeE,QAfF,EAgBE,OAhBF,EAiBE,UAjBF,EAkBE,QAlBF,QAmBO,iBAnBP;AAoBA,SAAQ,SAAR,EAAmB,SAAnB,QAAmC,YAAnC;AACA,SAAQ,YAAR,EAAsB,YAAtB,EAAoC,WAApC,QAA6D,UAA7D;AACA,SAAQ,mBAAR,QAAkC,cAAlC;AACA,SAAQ,qBAAR,QAAoC,oBAApC;AACA,SAAQ,aAAR,QAA4B,aAA5B;AACA,SAAQ,OAAR,QAAsB,OAAtB;AACA,SAAQ,aAAR,QAA4B,aAA5B;AACA,SAAsB,UAAtB,QAAuC,YAAvC;AACA,SAAQ,oBAAR,QAAmC,WAAnC;AACA,SAAQ,SAAR,QAAwB,SAAxB;AACA,SAAQ,UAAR,QAAyB,UAAzB;AACA,SAAQ,iBAAR,QAAgC,iBAAhC;AACA,SAAQ,oBAAR,QAAmC,WAAnC;AACA,SAAQ,iBAAR,QAAgC,QAAhC;AACA,SACE,uBADF,EAEE,8BAFF,EAGE,wBAHF,EAIE,SAJF,QAKO,eALP;AAMA,SAAQ,WAAR,QAA0B,WAA1B;AACA,SAAQ,YAAR,QAA2B,YAA3B;AACA,SAAQ,aAAR,QAA4B,aAA5B;AACA,SAAQ,cAAR,QAA6B,cAA7B;AACA,SAAQ,UAAR,QAAyB,UAAzB;AACA,SAAQ,aAAR,QAA2C,GAA3C;AACA,SAAQ,0BAAR,QAAyC,iBAAzC;AACA,SAAQ,0BAAR,QAAyC,sBAAzC;AACA,SAAQ,kBAAR,QAAiC,SAAjC;AACA,SAAQ,UAAR,QAAyB,UAAzB;AACA,SAAQ,kBAAR,QAAiC,SAAjC;AACA,SAAQ,qBAAR,QAAoC,YAApC;AACA,SAAQ,uBAAR,QAAsC,cAAtC;AACA,SAAQ,mBAAR,QAAkC,UAAlC;AACA,SAAQ,YAAR,QAA2B,YAA3B;AACA,SAAQ,UAAR,QAAyB,UAAzB;AACA,SAAQ,SAAR,QAAwB,SAAxB;AACA,SAAQ,YAAR,QAA2B,YAA3B;AACA,SAAQ,mBAAR,QAAkC,UAAlC;AAEA,OAAM,SAAU,UAAV,CAAqB,IAArB,EAAiC,OAAjC,EAAsD;;;AAC1D,OAAK,MAAM,KAAX,IAAoB,OAApB,EAA6B;AAC3B,UAAM,SAAS,GAAG,KAAK,CAAC,IAAxB,CAD2B,CAG3B;;AACA,QAAI,IAAI,CAAC,IAAL,IAAa,KAAK,CAAC,OAAN,EAAb,IAAgC,IAAI,CAAC,IAAL,KAAc,KAAK,CAAC,QAAxD,EAAkE;AAChE;AACD,KAN0B,CAQ3B;;;AACA,QAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,QAAD,CAAJ,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAE,IAAhB,MAAoB,CAAA,EAAA,GAAI,SAAS,CAAC,MAAd,MAAoB,IAApB,IAAoB,EAAA,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAoB,EAAA,CAAE,OAA1C,CAAJ,EAAuD;AACrD;AACD,KAX0B,CAa3B;;;AACA,QACE,CAAC,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,QAAD,CAAJ,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAE,OAAhB,MAAuB,CAAA,EAAA,GAAI,SAAS,CAAC,MAAd,MAAoB,IAApB,IAAoB,EAAA,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAoB,EAAA,CAAE,OAA7C,CAAD,KACA,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,QAAD,CAAJ,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAE,OAAhB,OAAuB,CAAA,EAAA,GAAK,SAAS,CAAC,MAAf,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,KAAA,CAArB,GAAqB,EAAA,CAAE,OAA9C,CAFF,EAGE;AACA;AACD;;AACD,QAAI,CAAC,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,QAAD,CAAJ,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAE,IAAhB,MAAoB,CAAA,EAAA,GAAI,SAAS,CAAC,MAAd,MAAoB,IAApB,IAAoB,EAAA,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAoB,EAAA,CAAE,IAA1C,CAAD,KAAoD,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,QAAD,CAAJ,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAE,IAAhB,OAAoB,CAAA,EAAA,GAAK,SAAS,CAAC,MAAf,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,KAAA,CAArB,GAAqB,EAAA,CAAE,IAA3C,CAAxD,EAAyG;AACvG;AACD;;AAED,QAAI,YAAY,CAAC,IAAD,CAAZ,IAAsB,YAAY,CAAC,SAAD,CAAtC,EAAmD;AACjD,UAAI,SAAS,CAAC,IAAI,CAAC,MAAN,EAAc,SAAS,CAAC,MAAxB,CAAb,EAA8C;AAC5C,eAAO,KAAP;AACD;AACF,KAJD,MAIO,IAAI,SAAS,CAAC,IAAD,CAAT,IAAmB,SAAS,CAAC,SAAD,CAAhC,EAA6C;AAClD,UAAI,IAAI,CAAC,GAAL,KAAa,SAAS,CAAC,GAA3B,EAAgC;AAC9B,eAAO,KAAP;AACD;AACF,KAJM,MAIA,IAAI,WAAW,CAAC,IAAD,CAAf,EAAuB;AAC5B,UAAI,IAAI,CAAC,IAAL,KAAc,KAAK,CAAC,QAAxB,EAAkC;AAChC,eAAO,KAAP;AACD;AACF;AACF;;AACD,SAAO,IAAP;AACD;;AAED,SAAS,SAAT,CAAmB,KAAnB,EAAiC,OAAjC,EAAsD;AACpD,MAAI,KAAK,CAAC,IAAN,IAAc,CAAC,KAAK,CAAC,MAAzB,EAAiC;AAC/B;AAEA,QAAI,KAAK,CAAC,IAAN,KAAe,IAAnB,EAAyB;AACvB;AACA,YAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,EAAf,CAAf;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,MAAb;AACA,aAAO,MAAP;AACD;;AAED,UAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC,IAAP,EAAa,OAAb,CAAjC;;AAEA,QAAI,cAAJ,EAAoB;AAClB,UAAI,CAAC,WAAW,CAAC,KAAK,CAAC,IAAP,CAAhB,EAA8B;AAC5B,QAAA,cAAc,CAAC,IAAf,CAAoB,MAApB,GAA6B,SAAS,CAAC,EAAD,EAAK,KAAK,CAAC,IAAN,CAAW,MAAhB,EAAwB,cAAc,CAAC,IAAf,CAAoB,MAA5C,CAAtC;AACD,OAHiB,CAKlB;;;AACA,UAAI,CAAC,cAAc,CAAC,OAAf,EAAD,IAA6B,KAAK,CAAC,IAAN,CAAW,IAA5C,EAAkD;AAChD,QAAA,cAAc,CAAC,QAAf,GAA0B,KAAK,CAAC,IAAN,CAAW,IAArC;AACD;;AAED,aAAO,cAAP;AACD,KAXD,MAWO;AACL,YAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,KAAK,CAAC,IAArB,CAAf;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,MAAb;AACA,aAAO,MAAP;AACD;AACF,GA5BD,MA4BO;AACL;AACA,WAAO,KAAK,CAAC,MAAN,CAAa,SAAb,CAAuB,IAAvB,CAA4B,SAA5B,GACH,KAAK,CAAC,MAAN,CAAa,SAAb,CAAuB,IAAvB,CAA4B,SADzB,GAEH,KAAK,CAAC,MAAN,CAAa,SAAb,CAAuB,IAAvB,CAA4B,IAFhC;AAGD;AACF;AAED;;;;;AAGA,OAAM,SAAU,mBAAV,CAA8B,IAA9B,EAAkD,KAAlD,EAAgE,aAAhE,EAA4F;;;AAChG,MAAI,aAAa,GAAG,CAApB;;AAEA,OAAK,MAAM,CAAX,IAAgB,KAAK,CAAC,UAAtB,EAAkC;AAChC,QAAI,WAAW,GAAe,SAA9B;AACA,QAAI,aAAJ;;AAEA,QAAI,WAAW,CAAC,CAAD,CAAf,EAAoB;AAClB,MAAA,aAAa,GAAG,IAAI,GAAG,IAAI,aAAJ,CAAkB,IAAlB,EAAwB,CAAxB,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHD,MAGO,IAAI,QAAQ,CAAC,CAAD,CAAZ,EAAiB;AACtB,YAAM,QAAQ,GAAG,8BAA8B,CAAC,CAAD,CAA/C;AACA,MAAA,aAAa,GAAG,IAAI,IAAA,EAAA,GAAG,SAAS,CAAC,iBAAV,CAA4B,IAA5B,EAAkC,EAAlC,EAAsC,QAAtC,EAAgD,aAAhD,CAAH,EAAiE,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAArE,CAApB;AAEA,MAAA,IAAI,GAAG,IAAI,UAAJ,CAAe,IAAf,EAAqB,KAArB,EAA4B,CAAC,CAAC,MAA9B,CAAP;AACD,KALM,MAKA,IAAI,KAAK,CAAC,CAAD,CAAT,EAAc;AACnB,MAAA,aAAa,GAAG,IAAI,GAAG,OAAO,CAAC,iBAAR,CAA0B,IAA1B,EAAgC,CAAhC,EAAmC,KAAnC,CAAvB;AACA,MAAA,WAAW,GAAG,QAAd;AACD,KAHM,MAGA,IAAI,UAAU,CAAC,CAAD,CAAd,EAAmB;AACxB,MAAA,WAAW,GAAG,MAAd;AACA,YAAM,QAAQ,GAAG,aAAa,CAAC,eAAd,CAA8B,CAAC,CAAC,KAAhC,CAAjB,CAFwB,CAGxB;;AACA,UAAI,QAAQ,CAAC,KAAT,KAAmB,SAAvB,EAAkC;AAChC,QAAA,IAAI,GAAG,IAAI,SAAJ,CAAc,IAAd,EAAoB;AAAC,WAAC,CAAC,CAAC,KAAH,GAAW;AAAZ,SAApB,CAAP;AACA,QAAA,aAAa,CAAC,GAAd,CAAkB,CAAC,CAAC,KAApB,EAA2B,WAA3B,EAAwC,KAAxC;AACD;;AACD,MAAA,aAAa,GAAG,IAAI,GAAG,YAAY,CAAC,iBAAb,CAA+B,IAA/B,EAAqC,CAArC,CAAvB;AACD,KATM,MASA,IAAI,WAAW,CAAC,CAAD,CAAf,EAAoB;AACzB,MAAA,aAAa,GAAG,IAAI,GAAG,aAAa,CAAC,iBAAd,CAAgC,IAAhC,EAAsC,CAAtC,CAAvB;AACA,MAAA,WAAW,GAAG,QAAd;;AACA,UAAI,mBAAmB,CAAC,KAAD,CAAvB,EAAgC;AAC9B,QAAA,IAAI,GAAG,IAAI,cAAJ,CAAmB,IAAnB,CAAP;AACD;AACF,KANM,MAMA,IAAI,QAAQ,CAAC,CAAD,CAAZ,EAAiB;AACtB,MAAA,aAAa,GAAG,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,IAAhB,EAAsB,KAAtB,EAA6B,CAA7B,EAAgC,aAAa,EAA7C,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHM,MAGA,IAAI,QAAQ,CAAC,CAAD,CAAZ,EAAiB;AACtB,MAAA,aAAa,GAAG,IAAI,GAAG,IAAI,mBAAJ,CAAwB,IAAxB,EAA8B,CAA9B,CAAvB;AACA,MAAA,WAAW,GAAG,QAAd;AACD,KAHM,MAGA,IAAI,eAAe,CAAC,CAAD,CAAnB,EAAwB;AAC7B,MAAA,aAAa,GAAG,IAAI,GAAG,IAAI,0BAAJ,CAA+B,IAA/B,EAAqC,CAArC,CAAvB;AACA,MAAA,WAAW,GAAG,QAAd;AACD,KAHM,MAGA,IAAI,OAAO,CAAC,CAAD,CAAX,EAAgB;AACrB,MAAA,aAAa,GAAG,IAAI,GAAG,SAAS,CAAC,iBAAV,CAA4B,IAA5B,EAAkC,CAAlC,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHM,MAGA,IAAI,MAAM,CAAC,CAAD,CAAV,EAAe;AACpB,MAAA,aAAa,GAAG,IAAI,GAAG,IAAI,iBAAJ,CAAsB,IAAtB,EAA4B,CAA5B,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHM,MAGA,IAAI,SAAS,CAAC,CAAD,CAAb,EAAkB;AACvB,MAAA,aAAa,GAAG,IAAI,GAAG,IAAI,oBAAJ,CAAyB,IAAzB,EAA+B,CAA/B,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHM,MAGA,IAAI,OAAO,CAAC,CAAD,CAAX,EAAgB;AACrB,MAAA,aAAa,GAAG,IAAI,GAAG,IAAI,kBAAJ,CAAuB,IAAvB,EAA6B,CAA7B,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHM,MAGA,IAAI,QAAQ,CAAC,CAAD,CAAZ,EAAiB;AACtB,MAAA,IAAI,GAAG,IAAI,mBAAJ,CAAwB,IAAxB,EAA8B,CAA9B,CAAP;AACD,KAFM,MAEA,IAAI,QAAQ,CAAC,CAAD,CAAZ,EAAiB;AACtB,MAAA,aAAa,GAAG,IAAI,GAAG,UAAU,CAAC,iBAAX,CAA6B,IAA7B,EAAmC,CAAnC,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHM,MAGA,IAAI,SAAS,CAAC,CAAD,CAAb,EAAkB;AACvB,MAAA,aAAa,GAAG,IAAI,GAAG,IAAI,oBAAJ,CAAyB,IAAzB,EAA+B,CAA/B,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHM,MAGA,IAAI,UAAU,CAAC,CAAD,CAAd,EAAmB;AACxB,MAAA,aAAa,GAAG,IAAI,GAAG,IAAI,qBAAJ,CAA0B,IAA1B,EAAgC,CAAhC,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHM,MAGA,IAAI,YAAY,CAAC,CAAD,CAAhB,EAAqB;AAC1B,MAAA,aAAa,GAAG,IAAI,GAAG,IAAI,uBAAJ,CAA4B,IAA5B,EAAkC,CAAlC,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHM,MAGA,IAAI,OAAO,CAAC,CAAD,CAAX,EAAgB;AACrB,MAAA,aAAa,GAAG,IAAI,GAAG,IAAI,kBAAJ,CAAuB,IAAvB,EAA6B,CAA7B,CAAvB;AACA,MAAA,WAAW,GAAG,SAAd;AACD,KAHM,MAGA;AACL,MAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,uBAAZ,CAAoC,CAApC,CAAT;AACA;AACD;;AAED,QAAI,aAAa,IAAI,WAAW,KAAK,SAArC,EAAgD;AAC9C,WAAK,MAAM,KAAX,KAAgB,EAAA,GAAI,aAAa,CAAC,cAAd,EAAJ,EAAkC,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAtD,GAA0D;AACxD,QAAA,aAAa,CAAC,GAAd,CAAkB,KAAlB,EAAyB,WAAzB,EAAsC,KAAtC;AACD;AACF;AACF;;AAED,SAAO,IAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDA,OAAM,SAAU,SAAV,CAAoB,KAApB,EAAgC;;;AACpC,MAAI,IAAI,GAAG,SAAS,CAAC,KAAD,EAAQ,KAAK,CAAC,SAAN,CAAgB,IAAhB,CAAqB,OAA7B,CAApB;AAEA,QAAM;AAAC,IAAA,WAAD;AAAc,IAAA;AAAd,MAAqC,KAAK,CAAC,SAAN,CAAgB,IAA3D;AACA,QAAM,aAAa,GAAG,KAAK,CAAC,MAAN,GAAe,KAAK,CAAC,MAAN,CAAa,SAAb,CAAuB,IAAvB,CAA4B,aAA5B,CAA0C,KAA1C,EAAf,GAAmE,IAAI,aAAJ,EAAzF;AACA,QAAM,IAAI,GAAG,KAAK,CAAC,IAAnB;;AAEA,MAAI,WAAW,CAAC,IAAD,CAAf,EAAuB;AACrB;AACA,QAAI,mBAAmB,CAAC,IAAD,CAAvB,EAA+B;AAC7B,MAAA,IAAI,GAAG,IAAI,YAAJ,CAAiB,IAAjB,EAAuB,IAAI,CAAC,QAA5B,CAAP;AACD,KAFD,MAEO,IAAI,oBAAoB,CAAC,IAAD,CAAxB,EAAgC;AACrC,MAAA,IAAI,GAAG,IAAI,aAAJ,CAAkB,IAAlB,EAAwB,IAAI,CAAC,SAA7B,CAAP;AACD,KANoB,CAOrB;;;AACA,IAAA,aAAa,CAAC,YAAd,GAA6B,IAA7B;AACD,GATD,MASO,IAAI,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAA,MAAI,IAAJ,IAAI,EAAA,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAI,EAAA,CAAE,MAAN,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAY,EAAA,CAAE,KAAd,MAAwB,IAA5B,EAAkC;AACvC;AACA,IAAA,aAAa,CAAC,YAAd,GAA6B,IAA7B;AACD;;AAED,EAAA,IAAI,IAAA,EAAA,GAAG,SAAS,CAAC,YAAV,CAAuB,IAAvB,EAA6B,KAA7B,EAAoC,aAApC,CAAH,EAAqD,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAAzD,CAAJ,CArBoC,CAuBpC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,EAAA,IAAI,GAAG,IAAI,cAAJ,CAAmB,IAAnB,CAAP,CA9BoC,CAgCpC;AACA;;AACA,QAAM,aAAa,GAAG,KAAK,CAAC,MAAN,IAAgB,YAAY,CAAC,KAAK,CAAC,MAAP,CAAlD;;AACA,MAAI,WAAW,CAAC,KAAD,CAAX,IAAsB,YAAY,CAAC,KAAD,CAAtC,EAA+C;AAC7C,QAAI,aAAJ,EAAmB;AACjB,MAAA,IAAI,IAAA,EAAA,GAAG,OAAO,CAAC,gBAAR,CAAyB,IAAzB,EAA+B,KAA/B,CAAH,EAAwC,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAA5C,CAAJ;AACD;AACF;;AAED,MAAI,KAAK,CAAC,UAAN,CAAiB,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B,IAAA,IAAI,GAAG,mBAAmB,CAAC,IAAD,EAAO,KAAP,EAAc,aAAd,CAA1B;AACD,GA3CmC,CA6CpC;;;AACA,QAAM,iBAAiB,GAAG,wBAAwB,CAAC,KAAD,CAAlD;AACA,QAAM,gBAAgB,GAAG,uBAAuB,CAAC,KAAD,CAAhD;AACA,EAAA,IAAI,IAAA,EAAA,GAAG,SAAS,CAAC,iBAAV,CAA4B,IAA5B,EAAkC,EAAlC,EAAoC,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAM,iBAAN,CAAA,EAA4B,gBAA5B,CAApC,EAAmF,aAAnF,CAAH,EAAoG,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAAxG,CAAJ;;AAEA,MAAI,WAAW,CAAC,KAAD,CAAf,EAAwB;AACtB,IAAA,IAAI,GAAG,WAAW,CAAC,QAAZ,CAAqB,IAArB,EAA2B,KAA3B,CAAP;AACA,IAAA,IAAI,GAAG,YAAY,CAAC,QAAb,CAAsB,IAAtB,EAA4B,KAA5B,CAAP;AACD;;AAED,MAAI,WAAW,CAAC,KAAD,CAAX,IAAsB,YAAY,CAAC,KAAD,CAAtC,EAA+C;AAC7C,QAAI,CAAC,aAAL,EAAoB;AAClB,MAAA,IAAI,IAAA,EAAA,GAAG,OAAO,CAAC,gBAAR,CAAyB,IAAzB,EAA+B,KAA/B,CAAH,EAAwC,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAA5C,CAAJ;AACD;;AAED,IAAA,IAAI,IAAA,EAAA,GAAG,YAAY,CAAC,gBAAb,CAA8B,IAA9B,EAAoC,KAApC,CAAH,EAA6C,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAAjD,CAAJ;AACA,IAAA,IAAI,GAAG,aAAa,CAAC,oBAAd,CAAmC,IAAnC,EAAyC,KAAzC,CAAP;AACD,GA9DmC,CAgEpC;;;AACA,QAAM,OAAO,GAAG,KAAK,CAAC,OAAN,CAAc,GAAd,CAAhB;AACA,QAAM,GAAG,GAAG,IAAI,UAAJ,CAAe,IAAf,EAAqB,OAArB,EAA8B,GAA9B,EAAmC,mBAAnC,CAAZ;AACA,EAAA,WAAW,CAAC,OAAD,CAAX,GAAuB,GAAvB;AACA,EAAA,IAAI,GAAG,GAAP;;AAEA,MAAI,WAAW,CAAC,KAAD,CAAf,EAAwB;AACtB,UAAM,GAAG,GAAG,aAAa,CAAC,gBAAd,CAA+B,IAA/B,EAAqC,KAArC,CAAZ;;AACA,QAAI,GAAJ,EAAS;AACP,MAAA,IAAI,GAAG,GAAP;;AAEA,UAAI,mBAAmB,CAAC,KAAD,CAAvB,EAAgC;AAC9B,QAAA,IAAI,GAAG,IAAI,cAAJ,CAAmB,IAAnB,CAAP;AACD;AACF;;AACD,IAAA,IAAI,IAAA,EAAA,GAAG,UAAU,CAAC,gBAAX,CAA4B,IAA5B,EAAkC,KAAlC,CAAH,EAA2C,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAA/C,CAAJ;AACA,IAAA,IAAI,IAAA,EAAA,GAAG,SAAS,CAAC,gBAAV,CAA2B,IAA3B,EAAiC,KAAjC,CAAH,EAA0C,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAA9C,CAAJ;AACD;;AAED,MAAI,WAAW,CAAC,KAAD,CAAf,EAAwB;AACtB,IAAA,IAAI,IAAA,EAAA,GAAG,iBAAiB,CAAC,IAAlB,CAAuB,IAAvB,EAA6B,KAA7B,CAAH,EAAsC,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAA1C,CAAJ;AACD,GArFmC,CAuFpC;;;AACA,QAAM,QAAQ,GAAG,KAAK,CAAC,OAAN,CAAc,IAAd,CAAjB;AACA,QAAM,IAAI,GAAG,IAAI,UAAJ,CAAe,IAAf,EAAqB,QAArB,EAA+B,IAA/B,EAAqC,mBAArC,CAAb;AACA,EAAA,WAAW,CAAC,QAAD,CAAX,GAAwB,IAAxB;AACA,EAAA,IAAI,GAAG,IAAP;;AAEA,MAAI,WAAW,CAAC,KAAD,CAAf,EAAwB;AACtB,IAAA,qBAAqB,CAAC,KAAD,EAAQ,IAAR,CAArB;AACD,GA/FmC,CAiGpC;;;AACA,MAAI,SAAS,GAAG,IAAhB;;AACA,MAAI,YAAY,CAAC,KAAD,CAAhB,EAAyB;AACvB,UAAM,SAAS,GAAG,KAAK,CAAC,OAAN,CAAc,OAAd,CAAlB,CADuB,CAGvB;;AACA,IAAA,IAAI,GAAG,aAAa,CAAC,oBAAd,CAAmC,IAAnC,EAAyC,KAAzC,CAAP,CAJuB,CAMvB;AACA;;AACA,IAAA,IAAI,IAAA,EAAA,GAAG,0BAA0B,CAAC,IAAD,EAAO,KAAK,CAAC,KAAb,CAA7B,EAAgD,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAApD,CAAJ;AAEA,IAAA,SAAS,GAAG,IAAI,SAAJ,CAAc,IAAd,EAAoB,KAApB,EAA2B,SAA3B,EAAsC,IAAI,CAAC,SAAL,EAAtC,CAAZ;AACA,IAAA,WAAW,CAAC,SAAD,CAAX,GAAyB,SAAzB;AACA,IAAA,IAAI,GAAG,SAAP;AACD;;AACD,SAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,KAAK,CAAC,SAAN,CAAgB,IADrB,CAAA,EACyB;AACvB,IAAA,WADuB;AAEvB,IAAA,mBAFuB;AAGvB,IAAA,GAHuB;AAIvB,IAAA,IAJuB;AAKvB,IAAA,SALuB;AAMvB,IAAA;AANuB,GADzB,CAAA;AASD","sourcesContent":["import {\n  Data,\n  isGenerator,\n  isGraticuleGenerator,\n  isInlineData,\n  isNamedData,\n  isSequenceGenerator,\n  isUrlData,\n  MAIN,\n  ParseValue,\n  RAW\n} from '../../data';\nimport * as log from '../../log';\nimport {\n  isAggregate,\n  isBin,\n  isCalculate,\n  isDensity,\n  isFilter,\n  isFlatten,\n  isFold,\n  isImpute,\n  isJoinAggregate,\n  isLoess,\n  isLookup,\n  isPivot,\n  isQuantile,\n  isRegression,\n  isSample,\n  isStack,\n  isTimeUnit,\n  isWindow\n} from '../../transform';\nimport {deepEqual, mergeDeep} from '../../util';\nimport {isFacetModel, isLayerModel, isUnitModel, Model} from '../model';\nimport {requiresSelectionId} from '../selection';\nimport {materializeSelections} from '../selection/parse';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {CalculateNode} from './calculate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {DensityTransformNode} from './density';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {FilterInvalidNode} from './filterinvalid';\nimport {FlattenTransformNode} from './flatten';\nimport {FoldTransformNode} from './fold';\nimport {\n  getImplicitFromEncoding,\n  getImplicitFromFilterTransform,\n  getImplicitFromSelection,\n  ParseNode\n} from './formatparse';\nimport {GeoJSONNode} from './geojson';\nimport {GeoPointNode} from './geopoint';\nimport {GraticuleNode} from './graticule';\nimport {IdentifierNode} from './identifier';\nimport {ImputeNode} from './impute';\nimport {AncestorParse, DataComponent} from '.';\nimport {JoinAggregateTransformNode} from './joinaggregate';\nimport {makeJoinAggregateFromFacet} from './joinaggregatefacet';\nimport {LoessTransformNode} from './loess';\nimport {LookupNode} from './lookup';\nimport {PivotTransformNode} from './pivot';\nimport {QuantileTransformNode} from './quantile';\nimport {RegressionTransformNode} from './regression';\nimport {SampleTransformNode} from './sample';\nimport {SequenceNode} from './sequence';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\nexport function findSource(data: Data, sources: SourceNode[]) {\n  for (const other of sources) {\n    const otherData = other.data;\n\n    // if both datasets have a name defined, we cannot merge\n    if (data.name && other.hasName() && data.name !== other.dataName) {\n      continue;\n    }\n\n    // feature and mesh are mutually exclusive\n    if (data['format']?.mesh && otherData.format?.feature) {\n      continue;\n    }\n\n    // we have to extract the same feature or mesh\n    if (\n      (data['format']?.feature || otherData.format?.feature) &&\n      data['format']?.feature !== otherData.format?.feature\n    ) {\n      continue;\n    }\n    if ((data['format']?.mesh || otherData.format?.mesh) && data['format']?.mesh !== otherData.format?.mesh) {\n      continue;\n    }\n\n    if (isInlineData(data) && isInlineData(otherData)) {\n      if (deepEqual(data.values, otherData.values)) {\n        return other;\n      }\n    } else if (isUrlData(data) && isUrlData(otherData)) {\n      if (data.url === otherData.url) {\n        return other;\n      }\n    } else if (isNamedData(data)) {\n      if (data.name === other.dataName) {\n        return other;\n      }\n    }\n  }\n  return null;\n}\n\nfunction parseRoot(model: Model, sources: SourceNode[]): DataFlowNode {\n  if (model.data || !model.parent) {\n    // if the model defines a data source or is the root, create a source node\n\n    if (model.data === null) {\n      // data: null means we should ignore the parent's data so we just create a new data source\n      const source = new SourceNode([]);\n      sources.push(source);\n      return source;\n    }\n\n    const existingSource = findSource(model.data, sources);\n\n    if (existingSource) {\n      if (!isGenerator(model.data)) {\n        existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);\n      }\n\n      // if the new source has a name but the existing one does not, we can set it\n      if (!existingSource.hasName() && model.data.name) {\n        existingSource.dataName = model.data.name;\n      }\n\n      return existingSource;\n    } else {\n      const source = new SourceNode(model.data);\n      sources.push(source);\n      return source;\n    }\n  } else {\n    // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n    return model.parent.component.data.facetRoot\n      ? model.parent.component.data.facetRoot\n      : model.parent.component.data.main;\n  }\n}\n\n/**\n * Parses a transform array into a chain of connected dataflow nodes.\n */\nexport function parseTransformArray(head: DataFlowNode, model: Model, ancestorParse: AncestorParse): DataFlowNode {\n  let lookupCounter = 0;\n\n  for (const t of model.transforms) {\n    let derivedType: ParseValue = undefined;\n    let transformNode: DataFlowNode;\n\n    if (isCalculate(t)) {\n      transformNode = head = new CalculateNode(head, t);\n      derivedType = 'derived';\n    } else if (isFilter(t)) {\n      const implicit = getImplicitFromFilterTransform(t);\n      transformNode = head = ParseNode.makeWithAncestors(head, {}, implicit, ancestorParse) ?? head;\n\n      head = new FilterNode(head, model, t.filter);\n    } else if (isBin(t)) {\n      transformNode = head = BinNode.makeFromTransform(head, t, model);\n      derivedType = 'number';\n    } else if (isTimeUnit(t)) {\n      derivedType = 'date';\n      const parsedAs = ancestorParse.getWithExplicit(t.field);\n      // Create parse node because the input to time unit is always date.\n      if (parsedAs.value === undefined) {\n        head = new ParseNode(head, {[t.field]: derivedType});\n        ancestorParse.set(t.field, derivedType, false);\n      }\n      transformNode = head = TimeUnitNode.makeFromTransform(head, t);\n    } else if (isAggregate(t)) {\n      transformNode = head = AggregateNode.makeFromTransform(head, t);\n      derivedType = 'number';\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    } else if (isLookup(t)) {\n      transformNode = head = LookupNode.make(head, model, t, lookupCounter++);\n      derivedType = 'derived';\n    } else if (isWindow(t)) {\n      transformNode = head = new WindowTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isJoinAggregate(t)) {\n      transformNode = head = new JoinAggregateTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isStack(t)) {\n      transformNode = head = StackNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isFold(t)) {\n      transformNode = head = new FoldTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isFlatten(t)) {\n      transformNode = head = new FlattenTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isPivot(t)) {\n      transformNode = head = new PivotTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isSample(t)) {\n      head = new SampleTransformNode(head, t);\n    } else if (isImpute(t)) {\n      transformNode = head = ImputeNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isDensity(t)) {\n      transformNode = head = new DensityTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isQuantile(t)) {\n      transformNode = head = new QuantileTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isRegression(t)) {\n      transformNode = head = new RegressionTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isLoess(t)) {\n      transformNode = head = new LoessTransformNode(head, t);\n      derivedType = 'derived';\n    } else {\n      log.warn(log.message.invalidTransformIgnored(t));\n      continue;\n    }\n\n    if (transformNode && derivedType !== undefined) {\n      for (const field of transformNode.producedFields() ?? []) {\n        ancestorParse.set(field, derivedType, false);\n      }\n    }\n  }\n\n  return head;\n}\n\n/*\nDescription of the dataflow (http://asciiflow.com/):\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n     FormatParse\n     (explicit)\n         |\n         v\n     Transforms\n(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)\n         |\n         v\n     FormatParse\n     (implicit)\n         |\n         v\n Binning (in `encoding`)\n         |\n         v\n Timeunit (in `encoding`)\n         |\n         v\nFormula From Sort Array\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n  Aggregate (in `encoding`)\n         |\n         v\n  Stack (in `encoding`)\n         |\n         v\n  Invalid Filter\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n*/\n\nexport function parseData(model: Model): DataComponent {\n  let head = parseRoot(model, model.component.data.sources);\n\n  const {outputNodes, outputNodeRefCounts} = model.component.data;\n  const ancestorParse = model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();\n  const data = model.data;\n\n  if (isGenerator(data)) {\n    // insert generator transform\n    if (isSequenceGenerator(data)) {\n      head = new SequenceNode(head, data.sequence);\n    } else if (isGraticuleGenerator(data)) {\n      head = new GraticuleNode(head, data.graticule);\n    }\n    // no parsing necessary for generator\n    ancestorParse.parseNothing = true;\n  } else if (data?.format?.parse === null) {\n    // format.parse: null means disable parsing\n    ancestorParse.parseNothing = true;\n  }\n\n  head = ParseNode.makeExplicit(head, model, ancestorParse) ?? head;\n\n  // Default discrete selections require an identifer transform to\n  // uniquely identify data points. Add this transform at the head of\n  // the pipeline such that the identifier field is available for all\n  // subsequent datasets. During optimization, we will remove this\n  // transform if it proves to be unnecessary. Additional identifier\n  // transforms will be necessary when new tuples are constructed\n  // (e.g., post-aggregation).\n  head = new IdentifierNode(head);\n\n  // HACK: This is equivalent for merging bin extent for union scale.\n  // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale\n  const parentIsLayer = model.parent && isLayerModel(model.parent);\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) ?? head;\n    }\n  }\n\n  if (model.transforms.length > 0) {\n    head = parseTransformArray(head, model, ancestorParse);\n  }\n\n  // create parse nodes for fields that need to be parsed (or flattened) implicitly\n  const implicitSelection = getImplicitFromSelection(model);\n  const implicitEncoding = getImplicitFromEncoding(model);\n  head = ParseNode.makeWithAncestors(head, {}, {...implicitSelection, ...implicitEncoding}, ancestorParse) ?? head;\n\n  if (isUnitModel(model)) {\n    head = GeoJSONNode.parseAll(head, model);\n    head = GeoPointNode.parseAll(head, model);\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (!parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) ?? head;\n    }\n\n    head = TimeUnitNode.makeFromEncoding(head, model) ?? head;\n    head = CalculateNode.parseAllForSortIndex(head, model);\n  }\n\n  // add an output node pre aggregation\n  const rawName = model.getName(RAW);\n  const raw = new OutputNode(head, rawName, RAW, outputNodeRefCounts);\n  outputNodes[rawName] = raw;\n  head = raw;\n\n  if (isUnitModel(model)) {\n    const agg = AggregateNode.makeFromEncoding(head, model);\n    if (agg) {\n      head = agg;\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    }\n    head = ImputeNode.makeFromEncoding(head, model) ?? head;\n    head = StackNode.makeFromEncoding(head, model) ?? head;\n  }\n\n  if (isUnitModel(model)) {\n    head = FilterInvalidNode.make(head, model) ?? head;\n  }\n\n  // output node for marks\n  const mainName = model.getName(MAIN);\n  const main = new OutputNode(head, mainName, MAIN, outputNodeRefCounts);\n  outputNodes[mainName] = main;\n  head = main;\n\n  if (isUnitModel(model)) {\n    materializeSelections(model, main);\n  }\n\n  // add facet marker\n  let facetRoot = null;\n  if (isFacetModel(model)) {\n    const facetName = model.getName('facet');\n\n    // Derive new sort index field for facet's sort array\n    head = CalculateNode.parseAllForSortIndex(head, model);\n\n    // Derive new aggregate for facet's sort field\n    // augment data source with new fields for crossed facet\n    head = makeJoinAggregateFromFacet(head, model.facet) ?? head;\n\n    facetRoot = new FacetNode(head, model, facetName, main.getSource());\n    outputNodes[facetName] = facetRoot;\n    head = facetRoot;\n  }\n  return {\n    ...model.component.data,\n    outputNodes,\n    outputNodeRefCounts,\n    raw,\n    main,\n    facetRoot,\n    ancestorParse\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}