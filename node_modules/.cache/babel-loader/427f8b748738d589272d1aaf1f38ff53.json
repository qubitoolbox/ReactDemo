{"ast":null,"code":"import { Symbols, Start, Middle, End, Top, Bottom, Left, Right, TopLeft, TopRight, BottomLeft, BottomRight, None, Each, Flush } from '../constants';\nimport { boundStroke, multiLineOffset } from 'vega-scenegraph'; // utility for looking up legend layout configuration\n\nfunction lookup(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;\n} // if legends specify offset directly, use the maximum specified value\n\n\nfunction offsets(legends, value) {\n  var max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\n\nexport function legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup(config, orient),\n        offset = offsets(g, _('offset', 0)),\n        anchor = _('anchor', Start),\n        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n\n  const p = {\n    align: Each,\n    bounds: _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center: _('center'),\n    nodirty: true\n  };\n\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset,\n        column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset,\n        row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case TopLeft:\n      p.anchor = {\n        x: offset,\n        y: offset\n      };\n      break;\n\n    case TopRight:\n      p.anchor = {\n        x: w - offset,\n        y: offset,\n        column: End\n      };\n      break;\n\n    case BottomLeft:\n      p.anchor = {\n        x: offset,\n        y: h - offset,\n        row: End\n      };\n      break;\n\n    case BottomRight:\n      p.anchor = {\n        x: w - offset,\n        y: h - offset,\n        column: End,\n        row: End\n      };\n      break;\n  }\n\n  return p;\n}\nexport function legendLayout(view, legend) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = item.orient,\n      bounds = item.bounds,\n      x = item.x,\n      y = item.y,\n      w,\n      h; // cache current bounds for later comparison\n\n  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();\n  bounds.clear(); // adjust legend to accommodate padding and title\n\n  legendGroupLayout(view, item, item.items[0].items[0]); // aggregate bounds to determine size, and include origin\n\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n  return item;\n}\n\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds)); // anchor to legend origin\n\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n  return b;\n}\n\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n      ex = pad - entry.x,\n      ey = pad - entry.y;\n\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n        anchor = title.anchor,\n        tpad = item.titlePadding || 0,\n        tx = pad - title.x,\n        ty = pad - title.y;\n\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n\n      case Right:\n      case Bottom:\n        break;\n\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n\n    if (ex || ey) translate(view, entry, ex, ey);\n\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n\n    if (tx || ty) translate(view, title, tx, ty); // translate legend if title pushes into negative coordinates\n\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\n\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n        vgrad = title.datum.vgrad,\n        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n        u = vgrad && lr ? s : 0,\n        v = vgrad && lr ? 0 : s,\n        o = y <= 0 ? 0 : multiLineOffset(title);\n  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));\n}\n\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\n\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  var widths = entries.reduce(function (w, g) {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {}); // set dimensions of legend entry groups\n\n  entries.forEach(function (g) {\n    g.width = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-view-transforms/src/layout/legend.js"],"names":["Symbols","Start","Middle","End","Top","Bottom","Left","Right","TopLeft","TopRight","BottomLeft","BottomRight","None","Each","Flush","boundStroke","multiLineOffset","lookup","config","orient","opt","key","d","offsets","legends","value","max","Infinity","forEach","item","offset","Math","legendParams","g","xb","yb","w","h","_","anchor","mult","p","align","bounds","columns","length","padding","center","nodirty","x","floor","x1","column","y","height","y1","row","ceil","x2","width","y2","legendLayout","view","legend","items","datum","_bounds","clear","union","clone","legendGroupLayout","legendBounds","empty","type","legendEntryLayout","set","mark","b","entry","pad","ex","ey","title","translate","tpad","titlePadding","tx","ty","legendTitleOffset","round","lr","noBar","grad","vgrad","e","s","u","v","o","dx","dy","dirty","entries","widths","reduce"],"mappings":"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","sourcesContent":["import {\n  Symbols, Start, Middle, End, Top, Bottom, Left, Right,\n  TopLeft, TopRight, BottomLeft, BottomRight, None,\n  Each, Flush\n} from '../constants';\nimport {boundStroke, multiLineOffset} from 'vega-scenegraph';\n\n// utility for looking up legend layout configuration\nfunction lookup(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key]\n    : config[key] != null ? config[key]\n    : d;\n}\n\n// if legends specify offset directly, use the maximum specified value\nfunction offsets(legends, value) {\n  var max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\n\nexport function legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup(config, orient),\n        offset = offsets(g, _('offset', 0)),\n        anchor = _('anchor', Start),\n        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n\n  const p = {\n    align:   Each,\n    bounds:  _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center:  _('center'),\n    nodirty: true\n  };\n\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset, column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1), row: anchor\n      };\n      break;\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1), row: anchor\n      };\n      break;\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset, row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1), column: anchor\n      };\n      break;\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1), column: anchor\n      };\n      break;\n    case TopLeft:\n      p.anchor = {x: offset, y: offset};\n      break;\n    case TopRight:\n      p.anchor = {x: w - offset, y: offset, column: End};\n      break;\n    case BottomLeft:\n      p.anchor = {x: offset, y: h - offset, row: End};\n      break;\n    case BottomRight:\n      p.anchor = {x: w - offset, y: h - offset, column: End, row: End};\n      break;\n  }\n\n  return p;\n}\n\nexport function legendLayout(view, legend) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = item.orient,\n      bounds = item.bounds,\n      x = item.x, y = item.y, w, h;\n\n  // cache current bounds for later comparison\n  item._bounds\n    ? item._bounds.clear().union(bounds)\n    : item._bounds = bounds.clone();\n  bounds.clear();\n\n  // adjust legend to accommodate padding and title\n  legendGroupLayout(view, item, item.items[0].items[0]);\n\n  // aggregate bounds to determine size, and include origin\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n\n  return item;\n}\n\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds));\n\n  // anchor to legend origin\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n\n  return b;\n}\n\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n      ex = pad - entry.x,\n      ey = pad - entry.y;\n\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n        anchor = title.anchor,\n        tpad = item.titlePadding || 0,\n        tx = pad - title.x,\n        ty = pad - title.y;\n\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n      case Right:\n      case Bottom:\n        break;\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n    if (ex || ey) translate(view, entry, ex, ey);\n\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n    if (tx || ty) translate(view, title, tx, ty);\n\n    // translate legend if title pushes into negative coordinates\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\n\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n        vgrad = title.datum.vgrad,\n        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n        u = vgrad && lr ? s : 0,\n        v = vgrad && lr ? 0 : s,\n        o = y <= 0 ? 0 : multiLineOffset(title);\n\n  return Math.round(anchor === Start ? u\n    : anchor === End ? (v - o)\n    : 0.5 * (s - o));\n}\n\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\n\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  var widths = entries.reduce(function(w, g) {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {});\n\n  // set dimensions of legend entry groups\n  entries.forEach(function(g) {\n    g.width  = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}