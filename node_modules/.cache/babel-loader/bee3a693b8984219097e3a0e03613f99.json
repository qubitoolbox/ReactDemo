{"ast":null,"code":"import { ingest, Transform } from 'vega-dataflow';\nimport { inherits, isArray } from 'vega-util';\nimport { transform } from './Isocontour';\nimport { params } from './KDE2D';\nimport contours from './util/contours';\nimport density2D from './util/density2D';\nimport quantize from './util/quantize';\n/**\n * Generate contours based on kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n *  If the values parameter is provided, this must be the dimensions of the input data.\n *  If density estimation is performed, this is the output view dimensions in pixels.\n * @param {Array<number>} [params.values] - An array of numeric values representing an\n *  width x height grid of values over which to compute contours. If unspecified, this\n *  transform will instead attempt to compute contours for the kernel density estimate\n *  using values drawn from data tuples in the input pulse.\n * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   this parameter is set, the count and nice parameters will be ignored.\n * @param {number} [params.count] - The desired number of contours.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified count.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n */\n\nexport default function Contour(params) {\n  Transform.call(this, null, params);\n}\nContour.Definition = {\n  \"type\": \"Contour\",\n  \"metadata\": {\n    \"generates\": true\n  },\n  \"params\": [{\n    \"name\": \"size\",\n    \"type\": \"number\",\n    \"array\": true,\n    \"length\": 2,\n    \"required\": true\n  }, {\n    \"name\": \"values\",\n    \"type\": \"number\",\n    \"array\": true\n  }, {\n    \"name\": \"x\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"y\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"weight\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"cellSize\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"bandwidth\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"count\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"nice\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }, {\n    \"name\": \"thresholds\",\n    \"type\": \"number\",\n    \"array\": true\n  }, {\n    \"name\": \"smooth\",\n    \"type\": \"boolean\",\n    \"default\": true\n  }]\n};\nvar prototype = inherits(Contour, Transform);\n\nprototype.transform = function (_, pulse) {\n  if (this.value && !pulse.changed() && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      contour = contours().smooth(_.smooth !== false),\n      values = _.values,\n      thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),\n      size = _.size,\n      grid,\n      post;\n\n  if (!values) {\n    values = pulse.materialize(pulse.SOURCE).source;\n    grid = params(density2D(), _)(values, true);\n    post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);\n    size = [grid.width, grid.height];\n    values = grid.values;\n  }\n\n  thresh = isArray(thresh) ? thresh : thresh(values);\n  values = contour.size(size)(values, thresh);\n  if (post) values.forEach(post);\n  if (this.value) out.rem = this.value;\n  this.value = out.source = out.add = (values || []).map(ingest);\n  return out;\n};","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-geo/src/Contour.js"],"names":["ingest","Transform","inherits","isArray","transform","params","contours","density2D","quantize","Contour","call","Definition","prototype","_","pulse","value","changed","modified","StopPropagation","out","fork","NO_SOURCE","NO_FIELDS","contour","smooth","values","thresh","thresholds","count","nice","size","grid","post","materialize","SOURCE","source","scale","width","height","forEach","rem","add","map"],"mappings":"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","sourcesContent":["import {ingest, Transform} from 'vega-dataflow';\nimport {inherits, isArray} from 'vega-util';\nimport {transform} from './Isocontour';\nimport {params} from './KDE2D';\nimport contours from './util/contours';\nimport density2D from './util/density2D';\nimport quantize from './util/quantize';\n\n/**\n * Generate contours based on kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n *  If the values parameter is provided, this must be the dimensions of the input data.\n *  If density estimation is performed, this is the output view dimensions in pixels.\n * @param {Array<number>} [params.values] - An array of numeric values representing an\n *  width x height grid of values over which to compute contours. If unspecified, this\n *  transform will instead attempt to compute contours for the kernel density estimate\n *  using values drawn from data tuples in the input pulse.\n * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   this parameter is set, the count and nice parameters will be ignored.\n * @param {number} [params.count] - The desired number of contours.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified count.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n */\nexport default function Contour(params) {\n  Transform.call(this, null, params);\n}\n\nContour.Definition = {\n  \"type\": \"Contour\",\n  \"metadata\": {\"generates\": true},\n  \"params\": [\n    { \"name\": \"size\", \"type\": \"number\", \"array\": true, \"length\": 2, \"required\": true },\n    { \"name\": \"values\", \"type\": \"number\", \"array\": true },\n    { \"name\": \"x\", \"type\": \"field\" },\n    { \"name\": \"y\", \"type\": \"field\" },\n    { \"name\": \"weight\", \"type\": \"field\" },\n    { \"name\": \"cellSize\", \"type\": \"number\" },\n    { \"name\": \"bandwidth\", \"type\": \"number\" },\n    { \"name\": \"count\", \"type\": \"number\" },\n    { \"name\": \"nice\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"thresholds\", \"type\": \"number\", \"array\": true },\n    { \"name\": \"smooth\", \"type\": \"boolean\", \"default\": true }\n  ]\n};\n\nvar prototype = inherits(Contour, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (this.value && !pulse.changed() && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      contour = contours().smooth(_.smooth !== false),\n      values = _.values,\n      thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),\n      size = _.size, grid, post;\n\n  if (!values) {\n    values = pulse.materialize(pulse.SOURCE).source;\n    grid = params(density2D(), _)(values, true);\n    post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);\n    size = [grid.width, grid.height];\n    values = grid.values;\n  }\n\n  thresh = isArray(thresh) ? thresh : thresh(values);\n  values = contour.size(size)(values, thresh);\n  if (post) values.forEach(post);\n\n  if (this.value) out.rem = this.value;\n  this.value = out.source = out.add = (values || []).map(ingest);\n\n  return out;\n};\n"]},"metadata":{},"sourceType":"module"}