{"ast":null,"code":"import { getMainRangeChannel, X, X2, Y2 } from '../../../channel';\nimport { isFieldDef, isPositionFieldDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { ScaleType } from '../../../scale';\nimport { contains, getFirstDefined } from '../../../util';\nimport { getMarkConfig } from '../../common';\nimport { getOffset } from './offset';\nimport * as ref from './valueref';\n/**\n * Return encode for point (non-band) position channels.\n */\n\nexport function pointPosition(channel, model, {\n  defaultPos,\n  vgChannel\n}) {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n  const {\n    encoding,\n    mark,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[channel === X ? X2 : Y2];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const offset = getOffset(channel, model.markDef);\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    markDef,\n    config,\n    defaultPos,\n    channel,\n    scaleName,\n    scale,\n    mark,\n    checkBarAreaWithoutZero: !channel2Def // only check for non-ranged marks\n\n  });\n  const valueRef = !channelDef && (encoding.latitude || encoding.longitude) ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n  {\n    field: model.getName(channel)\n  } : positionRef({\n    channel,\n    channelDef,\n    channel2Def,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef\n  });\n  return {\n    [vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel]: valueRef\n  };\n} // TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\n\nfunction positionRef(params) {\n  const {\n    channel,\n    channelDef,\n    scaleName,\n    stack,\n    offset\n  } = params; // This isn't a part of midPoint because we use midPoint for non-position too\n\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isPositionFieldDef(channelDef) && channelDef.band !== undefined) {\n      return ref.interpolatedSignalRef({\n        scaleName,\n        fieldDef: channelDef,\n        startSuffix: 'start',\n        band: channelDef.band,\n        offset: 0\n      });\n    } // x or y use stack_end so that stacked line's point mark use stack_end too.\n\n\n    return ref.fieldRef(channelDef, scaleName, {\n      suffix: 'end'\n    }, {\n      offset\n    });\n  }\n\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\n\nexport function pointPositionDefaultRef({\n  model,\n  markDef,\n  config,\n  defaultPos,\n  channel,\n  scaleName,\n  scale,\n  mark,\n  checkBarAreaWithoutZero: checkBarAreaWithZero\n}) {\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n    const definedValueOrConfig = getFirstDefined(markDef[channel], getMarkConfig(channel, markDef, config));\n\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueRef(channel, definedValueOrConfig);\n    }\n\n    if (defaultPos === 'zeroOrMin' || defaultPos === 'zeroOrMax') {\n      if (scaleName) {\n        const scaleType = scale.get('type');\n\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {\n              scaleType\n            }));\n          }\n        } else {\n          if (scale.domainDefinitelyIncludesZero()) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {\n              zeroFalse: scale.explicit.zero === false\n            }));\n          }\n        }\n      }\n\n      if (defaultPos === 'zeroOrMin') {\n        return mainChannel === 'x' ? {\n          value: 0\n        } : {\n          field: {\n            group: 'height'\n          }\n        };\n      } else {\n        // zeroOrMax\n        return mainChannel === 'x' ? {\n          field: {\n            group: 'width'\n          }\n        } : {\n          value: 0\n        };\n      }\n    } else {\n      // mid\n      const sizeRef = model[mainChannel === 'x' ? 'width' : 'height'];\n      return Object.assign(Object.assign({}, sizeRef), {\n        mult: 0.5\n      });\n    }\n  };\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-point.ts"],"names":[],"mappings":"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","sourcesContent":["import {getMainRangeChannel, PositionChannel, X, X2, Y2} from '../../../channel';\nimport {isFieldDef, isPositionFieldDef} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport * as log from '../../../log';\nimport {Mark, MarkDef} from '../../../mark';\nimport {ScaleType} from '../../../scale';\nimport {contains, getFirstDefined} from '../../../util';\nimport {VgValueRef} from '../../../vega.schema';\nimport {getMarkConfig} from '../../common';\nimport {ScaleComponent} from '../../scale/component';\nimport {UnitModel} from '../../unit';\nimport {getOffset} from './offset';\nimport * as ref from './valueref';\n\n/**\n * Return encode for point (non-band) position channels.\n */\nexport function pointPosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  {defaultPos, vgChannel}: {defaultPos: 'mid' | 'zeroOrMin' | 'zeroOrMax'; vgChannel?: 'x' | 'y' | 'xc' | 'yc'}\n) {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  const {encoding, mark, markDef, config, stack} = model;\n\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[channel === X ? X2 : Y2];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n\n  const offset = getOffset(channel, model.markDef);\n\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    markDef,\n    config,\n    defaultPos,\n    channel,\n    scaleName,\n    scale,\n    mark,\n    checkBarAreaWithoutZero: !channel2Def // only check for non-ranged marks\n  });\n\n  const valueRef =\n    !channelDef && (encoding.latitude || encoding.longitude)\n      ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n        {field: model.getName(channel)}\n      : positionRef({\n          channel,\n          channelDef,\n          channel2Def,\n          markDef,\n          config,\n          scaleName,\n          scale,\n          stack,\n          offset,\n          defaultRef\n        });\n\n  return {\n    [vgChannel ?? channel]: valueRef\n  };\n}\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nfunction positionRef(\n  params: ref.MidPointParams & {\n    channel: 'x' | 'y';\n  }\n): VgValueRef | VgValueRef[] {\n  const {channel, channelDef, scaleName, stack, offset} = params;\n\n  // This isn't a part of midPoint because we use midPoint for non-position too\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isPositionFieldDef(channelDef) && channelDef.band !== undefined) {\n      return ref.interpolatedSignalRef({\n        scaleName,\n        fieldDef: channelDef,\n        startSuffix: 'start',\n        band: channelDef.band,\n        offset: 0\n      });\n    }\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return ref.fieldRef(channelDef, scaleName, {suffix: 'end'}, {offset});\n  }\n\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\n\nexport function pointPositionDefaultRef({\n  model,\n  markDef,\n  config,\n  defaultPos,\n  channel,\n  scaleName,\n  scale,\n  mark,\n  checkBarAreaWithoutZero: checkBarAreaWithZero\n}: {\n  model: UnitModel;\n  markDef: MarkDef;\n  config: Config;\n  defaultPos: 'mid' | 'zeroOrMin' | 'zeroOrMax';\n  channel: PositionChannel;\n  scaleName: string;\n  scale: ScaleComponent;\n  mark: Mark;\n  checkBarAreaWithoutZero: boolean;\n}) {\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n\n    const definedValueOrConfig = getFirstDefined(markDef[channel], getMarkConfig(channel, markDef, config));\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueRef(channel, definedValueOrConfig);\n    }\n\n    if (defaultPos === 'zeroOrMin' || defaultPos === 'zeroOrMax') {\n      if (scaleName) {\n        const scaleType = scale.get('type');\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {scaleType}));\n          }\n        } else {\n          if (scale.domainDefinitelyIncludesZero()) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(\n              log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {zeroFalse: scale.explicit.zero === false})\n            );\n          }\n        }\n      }\n\n      if (defaultPos === 'zeroOrMin') {\n        return mainChannel === 'x' ? {value: 0} : {field: {group: 'height'}};\n      } else {\n        // zeroOrMax\n        return mainChannel === 'x' ? {field: {group: 'width'}} : {value: 0};\n      }\n    } else {\n      // mid\n      const sizeRef = model[mainChannel === 'x' ? 'width' : 'height'];\n      return {...sizeRef, mult: 0.5};\n    }\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}