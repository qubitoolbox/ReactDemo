{"ast":null,"code":"export function isUrlData(data) {\n  return !!data['url'];\n}\nexport function isInlineData(data) {\n  return !!data['values'];\n}\nexport function isNamedData(data) {\n  return !!data['name'] && !isUrlData(data) && !isInlineData(data) && !isGenerator(data);\n}\nexport function isGenerator(data) {\n  return data && (isSequenceGenerator(data) || isSphereGenerator(data) || isGraticuleGenerator(data));\n}\nexport function isSequenceGenerator(data) {\n  return !!data['sequence'];\n}\nexport function isSphereGenerator(data) {\n  return !!data['sphere'];\n}\nexport function isGraticuleGenerator(data) {\n  return !!data['graticule'];\n}\nexport const MAIN = 'main';\nexport const RAW = 'raw';","map":{"version":3,"sources":["../../src/data.ts"],"names":[],"mappings":"AAyHA,OAAM,SAAU,SAAV,CAAoB,IAApB,EAAyD;AAC7D,SAAO,CAAC,CAAC,IAAI,CAAC,KAAD,CAAb;AACD;AAED,OAAM,SAAU,YAAV,CAAuB,IAAvB,EAA4D;AAChE,SAAO,CAAC,CAAC,IAAI,CAAC,QAAD,CAAb;AACD;AAED,OAAM,SAAU,WAAV,CAAsB,IAAtB,EAA2D;AAC/D,SAAO,CAAC,CAAC,IAAI,CAAC,MAAD,CAAN,IAAkB,CAAC,SAAS,CAAC,IAAD,CAA5B,IAAsC,CAAC,YAAY,CAAC,IAAD,CAAnD,IAA6D,CAAC,WAAW,CAAC,IAAD,CAAhF;AACD;AAED,OAAM,SAAU,WAAV,CAAsB,IAAtB,EAA2D;AAC/D,SAAO,IAAI,KAAK,mBAAmB,CAAC,IAAD,CAAnB,IAA6B,iBAAiB,CAAC,IAAD,CAA9C,IAAwD,oBAAoB,CAAC,IAAD,CAAjF,CAAX;AACD;AAED,OAAM,SAAU,mBAAV,CAA8B,IAA9B,EAAmE;AACvE,SAAO,CAAC,CAAC,IAAI,CAAC,UAAD,CAAb;AACD;AAED,OAAM,SAAU,iBAAV,CAA4B,IAA5B,EAAiE;AACrE,SAAO,CAAC,CAAC,IAAI,CAAC,QAAD,CAAb;AACD;AAED,OAAM,SAAU,oBAAV,CAA+B,IAA/B,EAAoE;AACxE,SAAO,CAAC,CAAC,IAAI,CAAC,WAAD,CAAb;AACD;AAID,OAAO,MAAM,IAAI,GAAW,MAArB;AACP,OAAO,MAAM,GAAG,GAAU,KAAnB","sourcesContent":["/*\n * Constants and utilities for data.\n */\nimport {VgData} from './vega.schema';\nimport {FieldName} from './channeldef';\nimport {Vector2} from 'vega';\n\nexport type ParseValue = null | string | 'string' | 'boolean' | 'date' | 'number';\n\nexport interface Parse {\n  [field: string]: ParseValue;\n}\n\nexport interface DataFormatBase {\n  /**\n   * If set to `null`, disable type inference based on the spec and only use type inference based on the data.\n   * Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `\"number\"`, `\"boolean\"`, `\"date\"`, or null (do not parse the field)).\n   * For example, `\"parse\": {\"modified_on\": \"date\"}` parses the `modified_on` field in each input record a Date value.\n   *\n   * For `\"date\"`, we parse data based using Javascript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).\n   * For Specific date formats can be provided (e.g., `{foo: \"date:'%m%d%Y'\"}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: \"utc:'%m%d%Y'\"}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)\n   */\n  parse?: Parse | null;\n\n  /**\n   * Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`, `\"dsv\"`.\n   *\n   * __Default value:__  The default format type is determined by the extension of the file URL.\n   * If no extension is detected, `\"json\"` will be used by default.\n   */\n  type?: 'csv' | 'tsv' | 'dsv' | 'json' | 'topojson';\n}\n\nexport interface CsvDataFormat extends DataFormatBase {\n  type?: 'csv' | 'tsv';\n}\n\nexport interface DsvDataFormat extends DataFormatBase {\n  type?: 'dsv';\n\n  /**\n   * The delimiter between records. The delimiter must be a single character (i.e., a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.\n   *\n   * @minLength 1\n   * @maxLength 1\n   */\n  delimiter: string;\n}\n\nexport interface JsonDataFormat extends DataFormatBase {\n  type?: 'json';\n  /**\n   * The JSON property containing the desired data.\n   * This parameter can be used when the loaded JSON file may have surrounding structure or meta-data.\n   * For example `\"property\": \"values.features\"` is equivalent to retrieving `json.values.features`\n   * from the loaded JSON object.\n   */\n  property?: string;\n}\n\nexport interface TopoDataFormat extends DataFormatBase {\n  type?: 'topojson';\n  /**\n   * The name of the TopoJSON object set to convert to a GeoJSON feature collection.\n   * For example, in a map of the world, there may be an object set named `\"countries\"`.\n   * Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.\n   */\n  feature?: string;\n  /**\n   * The name of the TopoJSON object set to convert to mesh.\n   * Similar to the `feature` option, `mesh` extracts a named TopoJSON object set.\n   *  Unlike the `feature` option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features.\n   * Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.\n   */\n  mesh?: string;\n}\n\nexport type DataFormat = CsvDataFormat | DsvDataFormat | JsonDataFormat | TopoDataFormat;\n\nexport type DataFormatType = 'json' | 'csv' | 'tsv' | 'dsv' | 'topojson';\n\nexport type DataSource = UrlData | InlineData | NamedData;\n\nexport type Data = DataSource | Generator;\n\nexport type InlineDataset = number[] | string[] | boolean[] | object[] | string | object;\n\nexport interface DataBase {\n  /**\n   * An object that specifies the format for parsing the data.\n   */\n  format?: DataFormat;\n  /**\n   * Provide a placeholder name and bind data at runtime.\n   */\n  name?: string;\n}\n\nexport interface UrlData extends DataBase {\n  /**\n   * An URL from which to load the data set. Use the `format.type` property\n   * to ensure the loaded data is correctly parsed.\n   */\n  url: string;\n}\n\nexport interface InlineData extends DataBase {\n  /**\n   * The full data set, included inline. This can be an array of objects or primitive values, an object, or a string.\n   * Arrays of primitive values are ingested as objects with a `data` property. Strings are parsed according to the specified format type.\n   */\n  values: InlineDataset;\n}\n\nexport interface NamedData extends DataBase {\n  /**\n   * Provide a placeholder name and bind data at runtime.\n   */\n  name: string;\n}\n\nexport function isUrlData(data: Partial<Data> | Partial<VgData>): data is UrlData {\n  return !!data['url'];\n}\n\nexport function isInlineData(data: Partial<Data> | Partial<VgData>): data is InlineData {\n  return !!data['values'];\n}\n\nexport function isNamedData(data: Partial<Data> | Partial<VgData>): data is NamedData {\n  return !!data['name'] && !isUrlData(data) && !isInlineData(data) && !isGenerator(data);\n}\n\nexport function isGenerator(data: Partial<Data> | Partial<VgData>): data is Generator {\n  return data && (isSequenceGenerator(data) || isSphereGenerator(data) || isGraticuleGenerator(data));\n}\n\nexport function isSequenceGenerator(data: Partial<Data> | Partial<VgData>): data is SequenceGenerator {\n  return !!data['sequence'];\n}\n\nexport function isSphereGenerator(data: Partial<Data> | Partial<VgData>): data is SphereGenerator {\n  return !!data['sphere'];\n}\n\nexport function isGraticuleGenerator(data: Partial<Data> | Partial<VgData>): data is GraticuleGenerator {\n  return !!data['graticule'];\n}\n\nexport type DataSourceType = 'raw' | 'main' | 'row' | 'column' | 'lookup';\n\nexport const MAIN: 'main' = 'main';\nexport const RAW: 'raw' = 'raw';\n\nexport type Generator = SequenceGenerator | SphereGenerator | GraticuleGenerator;\n\nexport interface GeneratorBase {\n  /**\n   * Provide a placeholder name and bind data at runtime.\n   */\n  name?: string;\n}\n\nexport interface SequenceGenerator extends GeneratorBase {\n  /**\n   * Generate a sequence of numbers.\n   */\n  sequence: SequenceParams;\n}\n\nexport interface SequenceParams {\n  /**\n   * The starting value of the sequence (inclusive).\n   */\n  start: number;\n  /**\n   * The ending value of the sequence (exclusive).\n   */\n  stop: number;\n  /**\n   * The step value between sequence entries.\n   *\n   * __Default value:__ `1`\n   */\n  step?: number;\n\n  /**\n   * The name of the generated sequence field.\n   *\n   * __Default value:__ `\"data\"`\n   */\n  as?: FieldName;\n}\n\nexport interface SphereGenerator extends GeneratorBase {\n  /**\n   * Generate sphere GeoJSON data for the full globe.\n   */\n  sphere: true | {};\n}\n\nexport interface GraticuleGenerator extends GeneratorBase {\n  /**\n   * Generate graticule GeoJSON data for geographic reference lines.\n   */\n  graticule: true | GraticuleParams;\n}\n\nexport interface GraticuleParams {\n  /**\n   * The major extent of the graticule as a two-element array of coordinates.\n   */\n  extentMajor?: Vector2<Vector2<number>>;\n\n  /**\n   * The minor extent of the graticule as a two-element array of coordinates.\n   */\n  extentMinor?: Vector2<Vector2<number>>;\n\n  /**\n   * Sets both the major and minor extents to the same values.\n   */\n  extent?: Vector2<Vector2<number>>;\n\n  /**\n   * The major step angles of the graticule.\n   *\n   *\n   * __Default value:__ `[90, 360]`\n   */\n  stepMajor?: Vector2<number>;\n\n  /**\n   * The minor step angles of the graticule.\n   *\n   * __Default value:__ `[10, 10]`\n   */\n  stepMinor?: Vector2<number>;\n\n  /**\n   * Sets both the major and minor step angles to the same values.\n   */\n  step?: Vector2<number>;\n\n  /**\n   * The precision of the graticule in degrees.\n   *\n   * __Default value:__ `2.5`\n   */\n  precision?: number;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}