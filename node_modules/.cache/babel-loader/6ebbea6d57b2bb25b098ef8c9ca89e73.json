{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isObject } from 'vega-util';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\n\nfunction dropLineAndPoint(markDef) {\n  const {\n    point: _point,\n    line: _line\n  } = markDef,\n        mark = __rest(markDef, [\"point\", \"line\"]);\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction dropLineAndPointFromConfig(config) {\n  for (const mark of ['line', 'area', 'rule', 'trail']) {\n    if (config[mark]) {\n      config = Object.assign(Object.assign({}, config), {\n        // TODO: remove as any\n        [mark]: omit(config[mark], ['point', 'line'])\n      });\n    }\n  }\n\n  return config;\n}\n\nfunction getPointOverlay(markDef, markConfig = {}, encoding) {\n  if (markDef.point === 'transparent') {\n    return {\n      opacity: 0\n    };\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    } // markDef.point is defined as falsy\n\n\n    return undefined;\n  }\n}\n\nfunction getLineOverlay(markDef, markConfig = {}) {\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    } // markDef.point is defined as falsy\n\n\n    return undefined;\n  }\n}\n\nexport class PathOverlayNormalizer {\n  constructor() {\n    this.name = 'path-overlay';\n  }\n\n  hasMatchingType(spec, config) {\n    if (isUnitSpec(spec)) {\n      const {\n        mark,\n        encoding\n      } = spec;\n      const markDef = isMarkDef(mark) ? mark : {\n        type: mark\n      };\n\n      switch (markDef.type) {\n        case 'line':\n        case 'rule':\n        case 'trail':\n          return !!getPointOverlay(markDef, config[markDef.type], encoding);\n\n        case 'area':\n          return (// false / null are also included as we want to remove the properties\n            !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])\n          );\n      }\n    }\n\n    return false;\n  }\n\n  run(spec, params, normalize) {\n    const {\n      config\n    } = params;\n\n    const {\n      selection,\n      projection,\n      encoding,\n      mark\n    } = spec,\n          outerSpec = __rest(spec, [\"selection\", \"projection\", \"encoding\", \"mark\"]);\n\n    const markDef = isMarkDef(mark) ? mark : {\n      type: mark\n    };\n    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n    const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n    const layer = [Object.assign(Object.assign({}, selection ? {\n      selection\n    } : {}), {\n      // Do not include point / line overlay in the normalize spec\n      mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef), markDef.type === 'area' ? {\n        opacity: 0.7\n      } : {})),\n      // drop shape from encoding as this might be used to trigger point overlay\n      encoding: omit(encoding, ['shape'])\n    })]; // FIXME: determine rules for applying selections.\n    // Need to copy stack config to overlayed layer\n\n    const stackProps = stack(markDef, encoding);\n    let overlayEncoding = encoding;\n\n    if (stackProps) {\n      const {\n        fieldChannel: stackFieldChannel,\n        offset\n      } = stackProps;\n      overlayEncoding = Object.assign(Object.assign({}, encoding), {\n        [stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset ? {\n          stack: offset\n        } : {})\n      });\n    }\n\n    if (lineOverlay) {\n      layer.push(Object.assign(Object.assign({}, projection ? {\n        projection\n      } : {}), {\n        mark: Object.assign(Object.assign({\n          type: 'line'\n        }, pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip'])), lineOverlay),\n        encoding: overlayEncoding\n      }));\n    }\n\n    if (pointOverlay) {\n      layer.push(Object.assign(Object.assign({}, projection ? {\n        projection\n      } : {}), {\n        mark: Object.assign(Object.assign({\n          type: 'point',\n          opacity: 1,\n          filled: true\n        }, pick(markDef, ['clip', 'tooltip'])), pointOverlay),\n        encoding: overlayEncoding\n      }));\n    }\n\n    return normalize(Object.assign(Object.assign({}, outerSpec), {\n      layer\n    }), Object.assign(Object.assign({}, params), {\n      config: dropLineAndPointFromConfig(config)\n    }));\n  }\n\n}","map":{"version":3,"sources":["../../../src/normalize/pathoverlay.ts"],"names":[],"mappings":"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","sourcesContent":["import {isObject} from 'vega-util';\nimport {Field} from '../channeldef';\nimport {Config} from '../config';\nimport {Encoding} from '../encoding';\nimport {AreaConfig, isMarkDef, LineConfig, Mark, MarkConfig, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedUnitSpec} from '../spec';\nimport {isUnitSpec} from '../spec/unit';\nimport {stack} from '../stack';\nimport {keys, omit, pick} from '../util';\nimport {NonFacetUnitNormalizer, NormalizeLayerOrUnit, NormalizerParams} from './base';\n\ntype UnitSpecWithPathOverlay = GenericUnitSpec<Encoding<string>, Mark | MarkDef<'line' | 'area' | 'rule' | 'trail'>>;\n\nfunction dropLineAndPoint(markDef: MarkDef): MarkDef | Mark {\n  const {point: _point, line: _line, ...mark} = markDef;\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction dropLineAndPointFromConfig(config: Config) {\n  for (const mark of ['line', 'area', 'rule', 'trail'] as const) {\n    if (config[mark]) {\n      config = {\n        ...config,\n        // TODO: remove as any\n        [mark]: omit(config[mark], ['point', 'line'] as any)\n      };\n    }\n  }\n  return config;\n}\n\nfunction getPointOverlay(markDef: MarkDef, markConfig: LineConfig = {}, encoding: Encoding<Field>): MarkConfig {\n  if (markDef.point === 'transparent') {\n    return {opacity: 0};\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\n\nfunction getLineOverlay(markDef: MarkDef, markConfig: AreaConfig = {}): MarkConfig {\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\n\nexport class PathOverlayNormalizer implements NonFacetUnitNormalizer<UnitSpecWithPathOverlay> {\n  public name = 'path-overlay';\n  public hasMatchingType(spec: GenericUnitSpec<any, Mark | MarkDef>, config: Config): spec is UnitSpecWithPathOverlay {\n    if (isUnitSpec(spec)) {\n      const {mark, encoding} = spec;\n      const markDef = isMarkDef(mark) ? mark : {type: mark};\n      switch (markDef.type) {\n        case 'line':\n        case 'rule':\n        case 'trail':\n          return !!getPointOverlay(markDef, config[markDef.type], encoding);\n        case 'area':\n          return (\n            // false / null are also included as we want to remove the properties\n            !!getPointOverlay(markDef, config[markDef.type], encoding) ||\n            !!getLineOverlay(markDef, config[markDef.type])\n          );\n      }\n    }\n    return false;\n  }\n  public run(spec: UnitSpecWithPathOverlay, params: NormalizerParams, normalize: NormalizeLayerOrUnit) {\n    const {config} = params;\n    const {selection, projection, encoding, mark, ...outerSpec} = spec;\n    const markDef: MarkDef = isMarkDef(mark) ? mark : {type: mark};\n\n    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n    const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n\n    const layer: NormalizedUnitSpec[] = [\n      {\n        ...(selection ? {selection} : {}),\n        // Do not include point / line overlay in the normalize spec\n        mark: dropLineAndPoint({\n          ...markDef,\n          // make area mark translucent by default\n          // TODO: extract this 0.7 to be shared with default opacity for point/tick/...\n          ...(markDef.type === 'area' ? {opacity: 0.7} : {})\n        }),\n        // drop shape from encoding as this might be used to trigger point overlay\n        encoding: omit(encoding, ['shape'])\n      }\n    ];\n\n    // FIXME: determine rules for applying selections.\n\n    // Need to copy stack config to overlayed layer\n    const stackProps = stack(markDef, encoding);\n\n    let overlayEncoding = encoding;\n    if (stackProps) {\n      const {fieldChannel: stackFieldChannel, offset} = stackProps;\n      overlayEncoding = {\n        ...encoding,\n        [stackFieldChannel]: {\n          ...encoding[stackFieldChannel],\n          ...(offset ? {stack: offset} : {})\n        }\n      };\n    }\n\n    if (lineOverlay) {\n      layer.push({\n        ...(projection ? {projection} : {}),\n        mark: {\n          type: 'line',\n          ...pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip']),\n          ...lineOverlay\n        },\n        encoding: overlayEncoding\n      });\n    }\n    if (pointOverlay) {\n      layer.push({\n        ...(projection ? {projection} : {}),\n        mark: {\n          type: 'point',\n          opacity: 1,\n          filled: true,\n          ...pick(markDef, ['clip', 'tooltip']),\n          ...pointOverlay\n        },\n        encoding: overlayEncoding\n      });\n    }\n\n    return normalize(\n      {\n        ...outerSpec,\n        layer\n      },\n      {\n        ...params,\n        config: dropLineAndPointFromConfig(config)\n      }\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}