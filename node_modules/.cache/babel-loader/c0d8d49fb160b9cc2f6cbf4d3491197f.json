{"ast":null,"code":"import { inferTypes, typeParsers } from './type';\nimport { formats } from './formats/index';\nimport { error, hasOwnProperty } from 'vega-util';\nimport { timeParse, utcParse } from 'd3-time-format';\nexport default function (data, schema, dateParse) {\n  schema = schema || {};\n  const reader = formats(schema.type || 'json');\n  if (!reader) error('Unknown data format type: ' + schema.type);\n  data = reader(data, schema);\n  if (schema.parse) parse(data, schema.parse, dateParse);\n  if (hasOwnProperty(data, 'columns')) delete data.columns;\n  return data;\n}\n\nfunction parse(data, types, dateParse) {\n  if (!data.length) return; // early exit for empty data\n\n  dateParse = dateParse || timeParse;\n  var fields = data.columns || Object.keys(data[0]),\n      parsers,\n      datum,\n      field,\n      i,\n      j,\n      n,\n      m;\n  if (types === 'auto') types = inferTypes(data, fields);\n  fields = Object.keys(types);\n  parsers = fields.map(function (field) {\n    var type = types[field],\n        parts,\n        pattern;\n\n    if (type && (type.indexOf('date:') === 0 || type.indexOf('utc:') === 0)) {\n      parts = type.split(/:(.+)?/, 2); // split on first :\n\n      pattern = parts[1];\n\n      if (pattern[0] === '\\'' && pattern[pattern.length - 1] === '\\'' || pattern[0] === '\"' && pattern[pattern.length - 1] === '\"') {\n        pattern = pattern.slice(1, -1);\n      }\n\n      return parts[0] === 'utc' ? utcParse(pattern) : dateParse(pattern);\n    }\n\n    if (!typeParsers[type]) {\n      throw Error('Illegal format pattern: ' + field + ':' + type);\n    }\n\n    return typeParsers[type];\n  });\n\n  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {\n    datum = data[i];\n\n    for (j = 0; j < m; ++j) {\n      field = fields[j];\n      datum[field] = parsers[j](datum[field]);\n    }\n  }\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-loader/src/read.js"],"names":["inferTypes","typeParsers","formats","error","hasOwnProperty","timeParse","utcParse","data","schema","dateParse","reader","type","parse","columns","types","length","fields","Object","keys","parsers","datum","field","i","j","n","m","map","parts","pattern","indexOf","split","slice","Error"],"mappings":"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","sourcesContent":["import {inferTypes, typeParsers} from './type';\nimport {formats} from './formats/index';\nimport {error, hasOwnProperty} from 'vega-util';\nimport {timeParse, utcParse} from 'd3-time-format';\n\nexport default function(data, schema, dateParse) {\n  schema = schema || {};\n\n  const reader = formats(schema.type || 'json');\n  if (!reader) error('Unknown data format type: ' + schema.type);\n\n  data = reader(data, schema);\n  if (schema.parse) parse(data, schema.parse, dateParse);\n\n  if (hasOwnProperty(data, 'columns')) delete data.columns;\n  return data;\n}\n\nfunction parse(data, types, dateParse) {\n  if (!data.length) return; // early exit for empty data\n\n  dateParse = dateParse || timeParse;\n\n  var fields = data.columns || Object.keys(data[0]),\n      parsers, datum, field, i, j, n, m;\n\n  if (types === 'auto') types = inferTypes(data, fields);\n\n  fields = Object.keys(types);\n  parsers = fields.map(function(field) {\n    var type = types[field],\n        parts, pattern;\n\n    if (type && (type.indexOf('date:') === 0 || type.indexOf('utc:') === 0)) {\n      parts = type.split(/:(.+)?/, 2);  // split on first :\n      pattern = parts[1];\n\n      if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n          (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n        pattern = pattern.slice(1, -1);\n      }\n\n      return parts[0] === 'utc' ? utcParse(pattern) : dateParse(pattern);\n    }\n\n    if (!typeParsers[type]) {\n      throw Error('Illegal format pattern: ' + field + ':' + type);\n    }\n\n    return typeParsers[type];\n  });\n\n  for (i=0, n=data.length, m=fields.length; i<n; ++i) {\n    datum = data[i];\n    for (j=0; j<m; ++j) {\n      field = fields[j];\n      datum[field] = parsers[j](datum[field]);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}