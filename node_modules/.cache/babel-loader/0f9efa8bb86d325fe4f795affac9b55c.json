{"ast":null,"code":"import clear from './clear';\nimport inputs from './inputs';\nimport nearest from './nearest';\nimport project from './project';\nimport scales from './scales';\nimport legends from './legends';\nimport toggle from './toggle';\nimport translate from './translate';\nimport zoom from './zoom';\nconst compilers = [project, toggle, scales, legends, translate, zoom, inputs, nearest, clear];\nexport function forEachTransform(selCmpt, cb) {\n  for (const t of compilers) {\n    if (t.has(selCmpt)) {\n      cb(t);\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../src/compile/selection/transforms/transforms.ts"],"names":[],"mappings":"AAKA,OAAO,KAAP,MAAkB,SAAlB;AACA,OAAO,MAAP,MAAmB,UAAnB;AACA,OAAO,OAAP,MAAoB,WAApB;AACA,OAAO,OAAP,MAAoB,WAApB;AACA,OAAO,MAAP,MAAmB,UAAnB;AACA,OAAO,OAAP,MAAoB,WAApB;AACA,OAAO,MAAP,MAAmB,UAAnB;AACA,OAAO,SAAP,MAAsB,aAAtB;AACA,OAAO,IAAP,MAAiB,QAAjB;AAWA,MAAM,SAAS,GAAwB,CAAC,OAAD,EAAU,MAAV,EAAkB,MAAlB,EAA0B,OAA1B,EAAmC,SAAnC,EAA8C,IAA9C,EAAoD,MAApD,EAA4D,OAA5D,EAAqE,KAArE,CAAvC;AAEA,OAAM,SAAU,gBAAV,CAA2B,OAA3B,EAAwD,EAAxD,EAA2F;AAC/F,OAAK,MAAM,CAAX,IAAgB,SAAhB,EAA2B;AACzB,QAAI,CAAC,CAAC,GAAF,CAAM,OAAN,CAAJ,EAAoB;AAClB,MAAA,EAAE,CAAC,CAAD,CAAF;AACD;AACF;AACF","sourcesContent":["import {NewSignal, Signal} from 'vega';\nimport {SelectionComponent} from '..';\nimport {SelectionDef} from '../../../selection';\nimport {Model} from '../../model';\nimport {UnitModel} from '../../unit';\nimport clear from './clear';\nimport inputs from './inputs';\nimport nearest from './nearest';\nimport project from './project';\nimport scales from './scales';\nimport legends from './legends';\nimport toggle from './toggle';\nimport translate from './translate';\nimport zoom from './zoom';\n\nexport interface TransformCompiler {\n  has: (selCmpt: SelectionComponent) => boolean;\n  parse?: (model: UnitModel, selCmpt: SelectionComponent, def: SelectionDef, origDef: SelectionDef) => void;\n  signals?: (model: UnitModel, selCmpt: SelectionComponent, signals: NewSignal[]) => Signal[]; // the output can be a new or a push signal\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent, signals: NewSignal[]) => NewSignal[];\n  modifyExpr?: (model: UnitModel, selCmpt: SelectionComponent, expr: string) => string;\n  marks?: (model: UnitModel, selCmpt: SelectionComponent, marks: any[]) => any[];\n}\n\nconst compilers: TransformCompiler[] = [project, toggle, scales, legends, translate, zoom, inputs, nearest, clear];\n\nexport function forEachTransform(selCmpt: SelectionComponent, cb: (tx: TransformCompiler) => void) {\n  for (const t of compilers) {\n    if (t.has(selCmpt)) {\n      cb(t);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}