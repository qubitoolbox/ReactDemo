{"ast":null,"code":"import { selector as parseSelector } from 'vega-event-selector';\nimport { isString } from 'vega-util';\nimport { TUPLE } from '..';\nimport { varName } from '../../../util';\nimport inputBindings from './inputs';\nimport toggle, { TOGGLE } from './toggle';\nconst clear = {\n  has: selCmpt => {\n    return selCmpt.clear !== undefined && selCmpt.clear !== false;\n  },\n  parse: (model, selCmpt, selDef) => {\n    if (selDef.clear) {\n      selCmpt.clear = isString(selDef.clear) ? parseSelector(selDef.clear, 'scope') : selDef.clear;\n    }\n  },\n  topLevelSignals: (model, selCmpt, signals) => {\n    if (inputBindings.has(selCmpt)) {\n      selCmpt.project.items.forEach(proj => {\n        const idx = signals.findIndex(n => n.name === varName(`${selCmpt.name}_${proj.field}`));\n\n        if (idx !== -1) {\n          signals[idx].on.push({\n            events: selCmpt.clear,\n            update: 'null'\n          });\n        }\n      });\n    }\n\n    return signals;\n  },\n  signals: (model, selCmpt, signals) => {\n    function addClear(idx, update) {\n      if (idx !== -1 && signals[idx].on) {\n        signals[idx].on.push({\n          events: selCmpt.clear,\n          update\n        });\n      }\n    } // Be as minimalist as possible when adding clear triggers to minimize dataflow execution.\n\n\n    if (selCmpt.type === 'interval') {\n      selCmpt.project.items.forEach(proj => {\n        const vIdx = signals.findIndex(n => n.name === proj.signals.visual);\n        addClear(vIdx, '[0, 0]');\n\n        if (vIdx === -1) {\n          const dIdx = signals.findIndex(n => n.name === proj.signals.data);\n          addClear(dIdx, 'null');\n        }\n      });\n    } else {\n      let tIdx = signals.findIndex(n => n.name === selCmpt.name + TUPLE);\n      addClear(tIdx, 'null');\n\n      if (toggle.has(selCmpt)) {\n        tIdx = signals.findIndex(n => n.name === selCmpt.name + TOGGLE);\n        addClear(tIdx, 'false');\n      }\n    }\n\n    return signals;\n  }\n};\nexport default clear;","map":{"version":3,"sources":["../../../../../src/compile/selection/transforms/clear.ts"],"names":[],"mappings":"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","sourcesContent":["import {Update} from 'vega';\nimport {selector as parseSelector} from 'vega-event-selector';\nimport {isString} from 'vega-util';\nimport {TUPLE} from '..';\nimport {varName} from '../../../util';\nimport inputBindings from './inputs';\nimport toggle, {TOGGLE} from './toggle';\nimport {TransformCompiler} from './transforms';\n\nconst clear: TransformCompiler = {\n  has: selCmpt => {\n    return selCmpt.clear !== undefined && selCmpt.clear !== false;\n  },\n\n  parse: (model, selCmpt, selDef) => {\n    if (selDef.clear) {\n      selCmpt.clear = isString(selDef.clear) ? parseSelector(selDef.clear, 'scope') : selDef.clear;\n    }\n  },\n\n  topLevelSignals: (model, selCmpt, signals) => {\n    if (inputBindings.has(selCmpt)) {\n      selCmpt.project.items.forEach(proj => {\n        const idx = signals.findIndex(n => n.name === varName(`${selCmpt.name}_${proj.field}`));\n        if (idx !== -1) {\n          signals[idx].on.push({events: selCmpt.clear, update: 'null'});\n        }\n      });\n    }\n\n    return signals;\n  },\n\n  signals: (model, selCmpt, signals) => {\n    function addClear(idx: number, update: Update) {\n      if (idx !== -1 && signals[idx].on) {\n        signals[idx].on.push({events: selCmpt.clear, update});\n      }\n    }\n\n    // Be as minimalist as possible when adding clear triggers to minimize dataflow execution.\n    if (selCmpt.type === 'interval') {\n      selCmpt.project.items.forEach(proj => {\n        const vIdx = signals.findIndex(n => n.name === proj.signals.visual);\n        addClear(vIdx, '[0, 0]');\n\n        if (vIdx === -1) {\n          const dIdx = signals.findIndex(n => n.name === proj.signals.data);\n          addClear(dIdx, 'null');\n        }\n      });\n    } else {\n      let tIdx = signals.findIndex(n => n.name === selCmpt.name + TUPLE);\n      addClear(tIdx, 'null');\n\n      if (toggle.has(selCmpt)) {\n        tIdx = signals.findIndex(n => n.name === selCmpt.name + TOGGLE);\n        addClear(tIdx, 'false');\n      }\n    }\n\n    return signals;\n  }\n};\n\nexport default clear;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}