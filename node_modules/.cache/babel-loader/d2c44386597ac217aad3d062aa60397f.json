{"ast":null,"code":"import { array, isArray, isObject, isString, stringValue } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel } from '../../../channel';\nimport { format, getFieldDef, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, title, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { getFirstDefined } from '../../../util';\nimport { binFormatExpression, getMarkConfig } from '../../common';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model, opt = {}) {\n  const {\n    encoding,\n    markDef,\n    config\n  } = model;\n  const channelDef = encoding.tooltip;\n\n  if (isArray(channelDef)) {\n    return {\n      tooltip: tooltipRefForEncoding({\n        tooltip: channelDef\n      }, config, opt)\n    };\n  } else {\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, model.config, opt.reactiveGeom ? 'datum.datum' : 'datum');\n\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      } // If tooltipDef does not exist, then use value from markDef or config\n\n\n      let markTooltip = getFirstDefined(markDef.tooltip, getMarkConfig('tooltip', markDef, config));\n\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, config, opt);\n        } else {\n          return {\n            signal: 'datum'\n          };\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\nexport function tooltipRefForEncoding(encoding, config, {\n  reactiveGeom\n} = {}) {\n  const keyValues = [];\n  const usedKey = {};\n  const toSkip = {};\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tooltipTuples = [];\n\n  function add(fDef, channel) {\n    const mainChannel = getMainRangeChannel(channel);\n    const fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n\n    });\n    const key = array(title(fieldDef, config, {\n      allowDisabling: false\n    })).join(', ');\n    let value = textRef(fieldDef, config, expr).signal;\n\n    if (channel === 'x' || channel === 'y') {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {\n          expr\n        });\n        const endField = vgField(fieldDef2, {\n          expr\n        });\n        value = binFormatExpression(startField, endField, format(fieldDef), config);\n        toSkip[channel2] = true;\n      }\n    }\n\n    tooltipTuples.push({\n      channel,\n      key,\n      value\n    });\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n\n  for (const {\n    channel,\n    key,\n    value\n  } of tooltipTuples) {\n    if (!toSkip[channel] && !usedKey[key]) {\n      keyValues.push(`${stringValue(key)}: ${value}`);\n      usedKey[key] = true;\n    }\n  }\n\n  return keyValues.length > 0 ? {\n    signal: `{${keyValues.join(', ')}}`\n  } : undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/tooltip.ts"],"names":[],"mappings":"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","sourcesContent":["import {array, isArray, isObject, isString, stringValue} from 'vega-util';\nimport {isBinned} from '../../../bin';\nimport {Channel, getMainRangeChannel} from '../../../channel';\nimport {\n  format,\n  getFieldDef,\n  hasConditionalFieldDef,\n  isFieldDef,\n  isTypedFieldDef,\n  SecondaryFieldDef,\n  title,\n  TypedFieldDef,\n  vgField\n} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport {Encoding, forEach} from '../../../encoding';\nimport {getFirstDefined} from '../../../util';\nimport {binFormatExpression, getMarkConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {wrapCondition} from './conditional';\nimport {textRef} from './text';\n\nexport function tooltip(model: UnitModel, opt: {reactiveGeom?: boolean} = {}) {\n  const {encoding, markDef, config} = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {tooltip: tooltipRefForEncoding({tooltip: channelDef}, config, opt)};\n  } else {\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, model.config, opt.reactiveGeom ? 'datum.datum' : 'datum');\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n\n      // If tooltipDef does not exist, then use value from markDef or config\n      let markTooltip = getFirstDefined(markDef.tooltip, getMarkConfig('tooltip', markDef, config));\n\n      if (markTooltip === true) {\n        markTooltip = {content: 'encoding'};\n      }\n\n      if (isString(markTooltip)) {\n        return {value: markTooltip};\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, config, opt);\n        } else {\n          return {signal: 'datum'};\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\n\nexport function tooltipRefForEncoding(\n  encoding: Encoding<string>,\n  config: Config,\n  {reactiveGeom}: {reactiveGeom?: boolean} = {}\n) {\n  const keyValues: string[] = [];\n  const usedKey = {};\n  const toSkip = {};\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tooltipTuples: {channel: Channel; key: string; value: string}[] = [];\n\n  function add(fDef: TypedFieldDef<string> | SecondaryFieldDef<string>, channel: Channel) {\n    const mainChannel = getMainRangeChannel(channel);\n\n    const fieldDef: TypedFieldDef<string> = isTypedFieldDef(fDef)\n      ? fDef\n      : {\n          ...fDef,\n          type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n        };\n\n    const key = array(title(fieldDef, config, {allowDisabling: false})).join(', ');\n\n    let value = textRef(fieldDef, config, expr).signal;\n\n    if (channel === 'x' || channel === 'y') {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {expr});\n        const endField = vgField(fieldDef2, {expr});\n        value = binFormatExpression(startField, endField, format(fieldDef), config);\n        toSkip[channel2] = true;\n      }\n    }\n\n    tooltipTuples.push({channel, key, value});\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n\n  for (const {channel, key, value} of tooltipTuples) {\n    if (!toSkip[channel] && !usedKey[key]) {\n      keyValues.push(`${stringValue(key)}: ${value}`);\n      usedKey[key] = true;\n    }\n  }\n\n  return keyValues.length > 0 ? {signal: `{${keyValues.join(', ')}}`} : undefined;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}