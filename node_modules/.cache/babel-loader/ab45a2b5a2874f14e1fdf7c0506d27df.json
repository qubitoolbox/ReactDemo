{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { valueExpr, vgField } from './channeldef';\nimport { fieldExpr as timeUnitFieldExpr, normalizeTimeUnit } from './timeunit';\nexport function isSelectionPredicate(predicate) {\n  var _a;\n\n  return (_a = predicate) === null || _a === void 0 ? void 0 : _a['selection'];\n}\nexport function isFieldEqualPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.equal !== undefined;\n}\nexport function isFieldLTPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.lt !== undefined;\n}\nexport function isFieldLTEPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.lte !== undefined;\n}\nexport function isFieldGTPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.gt !== undefined;\n}\nexport function isFieldGTEPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.gte !== undefined;\n}\nexport function isFieldRangePredicate(predicate) {\n  if (predicate && predicate.field) {\n    if (isArray(predicate.range) && predicate.range.length === 2) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function isFieldOneOfPredicate(predicate) {\n  return predicate && !!predicate.field && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n  ;\n}\nexport function isFieldValidPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.valid !== undefined;\n}\nexport function isFieldPredicate(predicate) {\n  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);\n}\n\nfunction predicateValueExpr(v, timeUnit) {\n  return valueExpr(v, {\n    timeUnit,\n    time: true\n  });\n}\n\nfunction predicateValuesExpr(vals, timeUnit) {\n  return vals.map(v => predicateValueExpr(v, timeUnit));\n} // This method is used by Voyager. Do not change its behavior without changing Voyager.\n\n\nexport function fieldFilterExpression(predicate, useInRange = true) {\n  const {\n    field,\n    timeUnit\n  } = predicate;\n  const fieldExpr = timeUnit ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n  // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n  // TODO: support utc\n  'time(' + timeUnitFieldExpr(timeUnit, field) + ')' : vgField(predicate, {\n    expr: 'datum'\n  });\n\n  if (isFieldEqualPredicate(predicate)) {\n    return fieldExpr + '===' + predicateValueExpr(predicate.equal, timeUnit);\n  } else if (isFieldLTPredicate(predicate)) {\n    const upper = predicate.lt;\n    return `${fieldExpr}<${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTPredicate(predicate)) {\n    const lower = predicate.gt;\n    return `${fieldExpr}>${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldLTEPredicate(predicate)) {\n    const upper = predicate.lte;\n    return `${fieldExpr}<=${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTEPredicate(predicate)) {\n    const lower = predicate.gte;\n    return `${fieldExpr}>=${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldOneOfPredicate(predicate)) {\n    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(',')}], ${fieldExpr}) !== -1`;\n  } else if (isFieldValidPredicate(predicate)) {\n    return fieldValidPredicate(fieldExpr, predicate.valid);\n  } else if (isFieldRangePredicate(predicate)) {\n    const lower = predicate.range[0];\n    const upper = predicate.range[1];\n\n    if (lower !== null && upper !== null && useInRange) {\n      return 'inrange(' + fieldExpr + ', [' + predicateValueExpr(lower, timeUnit) + ', ' + predicateValueExpr(upper, timeUnit) + '])';\n    }\n\n    const exprs = [];\n\n    if (lower !== null) {\n      exprs.push(`${fieldExpr} >= ${predicateValueExpr(lower, timeUnit)}`);\n    }\n\n    if (upper !== null) {\n      exprs.push(`${fieldExpr} <= ${predicateValueExpr(upper, timeUnit)}`);\n    }\n\n    return exprs.length > 0 ? exprs.join(' && ') : 'true';\n  }\n  /* istanbul ignore next: it should never reach here */\n\n\n  throw new Error(`Invalid field predicate: ${JSON.stringify(predicate)}`);\n}\nexport function fieldValidPredicate(fieldExpr, valid = true) {\n  if (valid) {\n    return `isValid(${fieldExpr}) && isFinite(+${fieldExpr})`;\n  } else {\n    return `!isValid(${fieldExpr}) || !isFinite(+${fieldExpr})`;\n  }\n}\nexport function normalizePredicate(f) {\n  if (isFieldPredicate(f) && f.timeUnit) {\n    return Object.assign(Object.assign({}, f), {\n      timeUnit: normalizeTimeUnit(f.timeUnit)\n    });\n  }\n\n  return f;\n}","map":{"version":3,"sources":["../../src/predicate.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {FieldName, valueExpr, vgField} from './channeldef';\nimport {DateTime} from './datetime';\nimport {LogicalOperand} from './logical';\nimport {fieldExpr as timeUnitFieldExpr, normalizeTimeUnit, TimeUnit} from './timeunit';\n\nexport type Predicate =\n  // a) FieldPredicate (but we don't type FieldFilter here so the schema has no nesting\n  // and thus the documentation shows all of the types clearly)\n  | FieldEqualPredicate\n  | FieldRangePredicate\n  | FieldOneOfPredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate\n  | FieldValidPredicate\n  // b) Selection Predicate\n  | SelectionPredicate\n  // c) Vega Expression string\n  | string;\n\nexport type FieldPredicate =\n  | FieldEqualPredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate\n  | FieldRangePredicate\n  | FieldOneOfPredicate\n  | FieldValidPredicate;\n\nexport interface SelectionPredicate {\n  /**\n   * Filter using a selection name.\n   */\n  selection: LogicalOperand<string>;\n}\n\nexport function isSelectionPredicate(predicate: LogicalOperand<Predicate>): predicate is SelectionPredicate {\n  return predicate?.['selection'];\n}\n\nexport interface FieldPredicateBase {\n  // TODO: support aggregate\n\n  /**\n   * Time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered.\n   */\n  field: FieldName;\n}\n\nexport interface FieldEqualPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be equal to.\n   */\n  equal: string | number | boolean | DateTime;\n}\n\nexport function isFieldEqualPredicate(predicate: any): predicate is FieldEqualPredicate {\n  return predicate && !!predicate.field && predicate.equal !== undefined;\n}\n\nexport interface FieldLTPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be less than.\n   */\n  lt: string | number | DateTime;\n}\n\nexport function isFieldLTPredicate(predicate: any): predicate is FieldLTPredicate {\n  return predicate && !!predicate.field && predicate.lt !== undefined;\n}\n\nexport interface FieldLTEPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be less than or equals to.\n   */\n  lte: string | number | DateTime;\n}\n\nexport function isFieldLTEPredicate(predicate: any): predicate is FieldLTEPredicate {\n  return predicate && !!predicate.field && predicate.lte !== undefined;\n}\n\nexport interface FieldGTPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be greater than.\n   */\n  gt: string | number | DateTime;\n}\n\nexport function isFieldGTPredicate(predicate: any): predicate is FieldGTPredicate {\n  return predicate && !!predicate.field && predicate.gt !== undefined;\n}\n\nexport interface FieldGTEPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be greater than or equals to.\n   */\n  gte: string | number | DateTime;\n}\n\nexport function isFieldGTEPredicate(predicate: any): predicate is FieldGTEPredicate {\n  return predicate && !!predicate.field && predicate.gte !== undefined;\n}\n\nexport interface FieldRangePredicate extends FieldPredicateBase {\n  /**\n   * An array of inclusive minimum and maximum values\n   * for a field value of a data item to be included in the filtered data.\n   * @maxItems 2\n   * @minItems 2\n   */\n  range: (number | DateTime | null)[];\n}\n\nexport function isFieldRangePredicate(predicate: any): predicate is FieldRangePredicate {\n  if (predicate && predicate.field) {\n    if (isArray(predicate.range) && predicate.range.length === 2) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface FieldOneOfPredicate extends FieldPredicateBase {\n  /**\n   * A set of values that the `field`'s value should be a member of,\n   * for a data item included in the filtered data.\n   */\n  oneOf: string[] | number[] | boolean[] | DateTime[];\n}\n\nexport interface FieldValidPredicate extends FieldPredicateBase {\n  /**\n   * If set to true the field's value has to be valid, meaning both not `null` and not [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).\n   */\n  valid: boolean;\n}\n\nexport function isFieldOneOfPredicate(predicate: any): predicate is FieldOneOfPredicate {\n  return (\n    predicate && !!predicate.field && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n  );\n}\n\nexport function isFieldValidPredicate(predicate: any): predicate is FieldValidPredicate {\n  return predicate && !!predicate.field && predicate.valid !== undefined;\n}\n\nexport function isFieldPredicate(\n  predicate: Predicate\n): predicate is\n  | FieldOneOfPredicate\n  | FieldEqualPredicate\n  | FieldRangePredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate {\n  return (\n    isFieldOneOfPredicate(predicate) ||\n    isFieldEqualPredicate(predicate) ||\n    isFieldRangePredicate(predicate) ||\n    isFieldLTPredicate(predicate) ||\n    isFieldGTPredicate(predicate) ||\n    isFieldLTEPredicate(predicate) ||\n    isFieldGTEPredicate(predicate)\n  );\n}\n\nfunction predicateValueExpr(v: number | string | boolean | DateTime, timeUnit: TimeUnit) {\n  return valueExpr(v, {timeUnit, time: true});\n}\n\nfunction predicateValuesExpr(vals: (number | string | boolean | DateTime)[], timeUnit: TimeUnit) {\n  return vals.map(v => predicateValueExpr(v, timeUnit));\n}\n\n// This method is used by Voyager. Do not change its behavior without changing Voyager.\nexport function fieldFilterExpression(predicate: FieldPredicate, useInRange = true) {\n  const {field, timeUnit} = predicate;\n  const fieldExpr = timeUnit\n    ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n      // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n      // TODO: support utc\n      'time(' + timeUnitFieldExpr(timeUnit, field) + ')'\n    : vgField(predicate, {expr: 'datum'});\n\n  if (isFieldEqualPredicate(predicate)) {\n    return fieldExpr + '===' + predicateValueExpr(predicate.equal, timeUnit);\n  } else if (isFieldLTPredicate(predicate)) {\n    const upper = predicate.lt;\n    return `${fieldExpr}<${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTPredicate(predicate)) {\n    const lower = predicate.gt;\n    return `${fieldExpr}>${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldLTEPredicate(predicate)) {\n    const upper = predicate.lte;\n    return `${fieldExpr}<=${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTEPredicate(predicate)) {\n    const lower = predicate.gte;\n    return `${fieldExpr}>=${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldOneOfPredicate(predicate)) {\n    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(',')}], ${fieldExpr}) !== -1`;\n  } else if (isFieldValidPredicate(predicate)) {\n    return fieldValidPredicate(fieldExpr, predicate.valid);\n  } else if (isFieldRangePredicate(predicate)) {\n    const lower = predicate.range[0];\n    const upper = predicate.range[1];\n\n    if (lower !== null && upper !== null && useInRange) {\n      return (\n        'inrange(' +\n        fieldExpr +\n        ', [' +\n        predicateValueExpr(lower, timeUnit) +\n        ', ' +\n        predicateValueExpr(upper, timeUnit) +\n        '])'\n      );\n    }\n\n    const exprs = [];\n    if (lower !== null) {\n      exprs.push(`${fieldExpr} >= ${predicateValueExpr(lower, timeUnit)}`);\n    }\n    if (upper !== null) {\n      exprs.push(`${fieldExpr} <= ${predicateValueExpr(upper, timeUnit)}`);\n    }\n\n    return exprs.length > 0 ? exprs.join(' && ') : 'true';\n  }\n\n  /* istanbul ignore next: it should never reach here */\n  throw new Error(`Invalid field predicate: ${JSON.stringify(predicate)}`);\n}\n\nexport function fieldValidPredicate(fieldExpr: string, valid = true) {\n  if (valid) {\n    return `isValid(${fieldExpr}) && isFinite(+${fieldExpr})`;\n  } else {\n    return `!isValid(${fieldExpr}) || !isFinite(+${fieldExpr})`;\n  }\n}\n\nexport function normalizePredicate(f: Predicate): Predicate {\n  if (isFieldPredicate(f) && f.timeUnit) {\n    return {\n      ...f,\n      timeUnit: normalizeTimeUnit(f.timeUnit)\n    };\n  }\n  return f;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}