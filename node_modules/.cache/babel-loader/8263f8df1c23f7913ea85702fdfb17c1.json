{"ast":null,"code":"import parseDataflow from './dataflow';\nimport { parameterExpression, encodeExpression } from './expression';\nimport { tupleid } from 'vega-dataflow';\nimport { accessor, array, compare, error, field, isArray, isObject, hasOwnProperty, key } from 'vega-util';\n/**\n * Parse a set of operator parameters.\n */\n\nexport default function parseParameters(spec, ctx, params) {\n  params = params || {};\n  var key, value;\n\n  for (key in spec) {\n    value = spec[key];\n    params[key] = isArray(value) ? value.map(function (v) {\n      return parseParameter(v, ctx, params);\n    }) : parseParameter(value, ctx, params);\n  }\n\n  return params;\n}\n/**\n * Parse a single parameter.\n */\n\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n\n  for (var i = 0, n = PARSERS.length, p; i < n; ++i) {\n    p = PARSERS[i];\n\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n\n  return spec;\n}\n/** Reference parsers. */\n\n\nvar PARSERS = [{\n  key: '$ref',\n  parse: getOperator\n}, {\n  key: '$key',\n  parse: getKey\n}, {\n  key: '$expr',\n  parse: getExpression\n}, {\n  key: '$field',\n  parse: getField\n}, {\n  key: '$encode',\n  parse: getEncode\n}, {\n  key: '$compare',\n  parse: getCompare\n}, {\n  key: '$context',\n  parse: getContext\n}, {\n  key: '$subflow',\n  parse: getSubflow\n}, {\n  key: '$tupleid',\n  parse: getTupleId\n}];\n/**\n * Resolve an operator reference.\n */\n\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n/**\n * Resolve an expression reference.\n */\n\n\nfunction getExpression(_, ctx, params) {\n  if (_.$params) {\n    // parse expression parameters\n    parseParameters(_.$params, ctx, params);\n  }\n\n  var k = 'e:' + _.$expr + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(parameterExpression(_.$expr, ctx), _.$fields, _.$name));\n}\n/**\n * Resolve a key accessor reference.\n */\n\n\nfunction getKey(_, ctx) {\n  var k = 'k:' + _.$key + '_' + !!_.$flat;\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat));\n}\n/**\n * Resolve a field accessor reference.\n */\n\n\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  var k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name));\n}\n/**\n * Resolve a comparator function reference.\n */\n\n\nfunction getCompare(_, ctx) {\n  var k = 'c:' + _.$compare + '_' + _.$order,\n      c = array(_.$compare).map(function (_) {\n    return _ && _.$tupleid ? tupleid : _;\n  });\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order));\n}\n/**\n * Resolve an encode operator reference.\n */\n\n\nfunction getEncode(_, ctx) {\n  var spec = _.$encode,\n      encode = {},\n      name,\n      enc;\n\n  for (name in spec) {\n    enc = spec[name];\n    encode[name] = accessor(encodeExpression(enc.$expr, ctx), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n\n  return encode;\n}\n/**\n * Resolve a context reference.\n */\n\n\nfunction getContext(_, ctx) {\n  return ctx;\n}\n/**\n * Resolve a recursive subflow specification.\n */\n\n\nfunction getSubflow(_, ctx) {\n  var spec = _.$subflow;\n  return function (dataflow, key, parent) {\n    var subctx = parseDataflow(spec, ctx.fork()),\n        op = subctx.get(spec.operators[0].id),\n        p = subctx.signals.parent;\n    if (p) p.set(parent);\n    return op;\n  };\n}\n/**\n * Resolve a tuple id reference.\n */\n\n\nfunction getTupleId() {\n  return tupleid;\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-runtime/src/parameters.js"],"names":["parseDataflow","parameterExpression","encodeExpression","tupleid","accessor","array","compare","error","field","isArray","isObject","hasOwnProperty","key","parseParameters","spec","ctx","params","value","map","v","parseParameter","i","n","PARSERS","length","p","parse","getOperator","getKey","getExpression","getField","getEncode","getCompare","getContext","getSubflow","getTupleId","_","get","$ref","$params","k","$expr","$name","fn","$fields","$key","$flat","$field","$compare","$order","c","$tupleid","$encode","encode","name","enc","output","$output","$subflow","dataflow","parent","subctx","fork","op","operators","id","signals","set"],"mappings":"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","sourcesContent":["import parseDataflow from './dataflow';\nimport {parameterExpression, encodeExpression} from './expression';\nimport {tupleid} from 'vega-dataflow';\nimport {\n  accessor, array, compare, error, field,\n  isArray, isObject, hasOwnProperty, key\n} from 'vega-util';\n\n/**\n * Parse a set of operator parameters.\n */\nexport default function parseParameters(spec, ctx, params) {\n  params = params || {};\n  var key, value;\n\n  for (key in spec) {\n    value = spec[key];\n\n    params[key] = isArray(value)\n      ? value.map(function(v) { return parseParameter(v, ctx, params); })\n      : parseParameter(value, ctx, params);\n  }\n  return params;\n}\n\n/**\n * Parse a single parameter.\n */\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n\n  for (var i=0, n=PARSERS.length, p; i<n; ++i) {\n    p = PARSERS[i];\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n  return spec;\n}\n\n/** Reference parsers. */\nvar PARSERS = [\n  {key: '$ref',      parse: getOperator},\n  {key: '$key',      parse: getKey},\n  {key: '$expr',     parse: getExpression},\n  {key: '$field',    parse: getField},\n  {key: '$encode',   parse: getEncode},\n  {key: '$compare',  parse: getCompare},\n  {key: '$context',  parse: getContext},\n  {key: '$subflow',  parse: getSubflow},\n  {key: '$tupleid',  parse: getTupleId}\n];\n\n/**\n * Resolve an operator reference.\n */\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n\n/**\n * Resolve an expression reference.\n */\nfunction getExpression(_, ctx, params) {\n  if (_.$params) { // parse expression parameters\n    parseParameters(_.$params, ctx, params);\n  }\n  var k = 'e:' + _.$expr + '_' + _.$name;\n  return ctx.fn[k]\n    || (ctx.fn[k] = accessor(parameterExpression(_.$expr, ctx), _.$fields, _.$name));\n}\n\n/**\n * Resolve a key accessor reference.\n */\nfunction getKey(_, ctx) {\n  var k = 'k:' + _.$key + '_' + (!!_.$flat);\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat));\n}\n\n/**\n * Resolve a field accessor reference.\n */\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  var k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name));\n}\n\n/**\n * Resolve a comparator function reference.\n */\nfunction getCompare(_, ctx) {\n  var k = 'c:' + _.$compare + '_' + _.$order,\n      c = array(_.$compare).map(function(_) {\n        return (_ && _.$tupleid) ? tupleid : _;\n      });\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order));\n}\n\n/**\n * Resolve an encode operator reference.\n */\nfunction getEncode(_, ctx) {\n  var spec = _.$encode,\n      encode = {}, name, enc;\n\n  for (name in spec) {\n    enc = spec[name];\n    encode[name] = accessor(encodeExpression(enc.$expr, ctx), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n  return encode;\n}\n\n/**\n * Resolve a context reference.\n */\nfunction getContext(_, ctx) {\n  return ctx;\n}\n\n/**\n * Resolve a recursive subflow specification.\n */\nfunction getSubflow(_, ctx) {\n  var spec = _.$subflow;\n  return function(dataflow, key, parent) {\n    var subctx = parseDataflow(spec, ctx.fork()),\n        op = subctx.get(spec.operators[0].id),\n        p = subctx.signals.parent;\n    if (p) p.set(parent);\n    return op;\n  };\n}\n\n/**\n * Resolve a tuple id reference.\n */\nfunction getTupleId() {\n  return tupleid;\n}\n"]},"metadata":{},"sourceType":"module"}