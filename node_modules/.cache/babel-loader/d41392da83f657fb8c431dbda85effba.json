{"ast":null,"code":"import { array32 } from './arrays';\nimport { bisectLeft, bisectRight, permute } from 'd3-array';\n/**\n * Maintains a list of values, sorted by key.\n */\n\nexport default function SortedIndex() {\n  var index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    var n0 = size,\n        n1 = data.length,\n        addv = Array(n1),\n        addi = array32(n1),\n        oldv,\n        oldi,\n        i;\n\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n\n    size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    var n = size,\n        idx,\n        i,\n        j; // seek forward to first removal\n\n    for (i = 0; !map[index[i]] && i < n; ++i); // condense index and value arrays\n\n\n    for (j = i; i < n; ++i) {\n      if (!map[idx = index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (var i = 0, n = size; i < n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    var n;\n\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: function () {\n      return index;\n    },\n    size: function () {\n      return size;\n    }\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, function (a, b) {\n    var x = values[a],\n        y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  var i0 = 0,\n      i1 = 0,\n      i;\n\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-crossfilter/src/SortedIndex.js"],"names":["array32","bisectLeft","bisectRight","permute","SortedIndex","index","value","size","insert","key","data","base","length","n0","n1","addv","Array","addi","oldv","oldi","i","sort","merge","remove","num","map","n","idx","j","reindex","bisect","range","array","values","call","a","b","x","y","value0","index0","value1","index1","i0","i1"],"mappings":"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","sourcesContent":["import {array32} from './arrays';\nimport {bisectLeft, bisectRight, permute} from 'd3-array';\n\n/**\n * Maintains a list of values, sorted by key.\n */\nexport default function SortedIndex() {\n  var index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n\n    var n0 = size,\n        n1 = data.length,\n        addv = Array(n1),\n        addi = array32(n1),\n        oldv, oldi, i;\n\n    for (i=0; i<n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i=0; i<n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n    size = n0 + n1;\n\n    return {index: addi, value: addv};\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    var n = size,\n        idx, i, j;\n\n    // seek forward to first removal\n    for (i=0; !map[index[i]] && i<n; ++i);\n\n    // condense index and value arrays\n    for (j=i; i<n; ++i) {\n      if (!map[idx=index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (var i=0, n=size; i<n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    var n;\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n    return [\n      bisectLeft(array, range[0], 0, n),\n      bisectRight(array, range[1], 0, n)\n    ];\n  }\n\n  return {\n    insert:  insert,\n    remove:  remove,\n    bisect:  bisect,\n    reindex: reindex,\n    index:   function() { return index; },\n    size:    function() { return size; }\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, function(a, b) {\n    var x = values[a],\n        y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  var i0 = 0, i1 = 0, i;\n\n  for (i=0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}