{"ast":null,"code":"import parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport { hasSignal, ref } from '../util';\nimport { Collect, Load, Relay, Sieve } from '../transforms';\nimport { array } from 'vega-util';\nexport default function parseData(data, scope) {\n  var transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(function (tx) {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(function (on) {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n/**\n * Analyze a data pipeline, add needed operators.\n */\n\nfunction analyze(data, scope, ops) {\n  var output = [],\n      source = null,\n      modify = false,\n      generate = false,\n      upstream,\n      i,\n      n,\n      t,\n      m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (hasSignal(data.values) || hasSignal(data.format)) {\n      // if either values or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(function (d) {\n      return ref(scope.getData(d).output);\n    });\n    output.push(null); // populate later\n  } // scan data transforms, add collectors as needed\n\n\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  var s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/data.js"],"names":["parseTransform","parseTrigger","hasSignal","ref","Collect","Load","Relay","Sieve","array","parseData","data","scope","transforms","transform","forEach","tx","push","on","name","addDataPipeline","analyze","ops","output","source","modify","generate","upstream","i","n","t","m","values","format","load","collect","$ingest","$format","url","$request","map","d","getData","length","metadata","generates","modifies","changes","derive","pulse","splice","s","property","undefined","async","objectProperty"],"mappings":"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","sourcesContent":["import parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport {hasSignal, ref} from '../util';\nimport {Collect, Load, Relay, Sieve} from '../transforms';\nimport {array} from 'vega-util';\n\nexport default function parseData(data, scope) {\n  var transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(function(tx) {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(function(on) {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n\n/**\n * Analyze a data pipeline, add needed operators.\n */\nfunction analyze(data, scope, ops) {\n  var output = [],\n      source = null,\n      modify = false,\n      generate = false,\n      upstream, i, n, t, m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (hasSignal(data.values) || hasSignal(data.format)) {\n      // if either values or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(function(d) {\n      return ref(scope.getData(d).output);\n    });\n    output.push(null); // populate later\n  }\n\n  // scan data transforms, add collectors as needed\n  for (i=0, n=ops.length; i<n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n    output.push(t);\n\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n\n    if (m.source) source = t;\n    else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  var s = Collect({}, values);\n  s.metadata = {source: true};\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url:    data.url ? scope.property(data.url) : undefined,\n    async:  data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n"]},"metadata":{},"sourceType":"module"}