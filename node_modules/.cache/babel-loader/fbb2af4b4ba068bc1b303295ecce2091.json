{"ast":null,"code":"import lookup from './lookup';\nimport { ingest, isTuple, Transform, tupleid } from 'vega-dataflow';\nimport { array, error, inherits } from 'vega-util';\nimport { hierarchy } from 'd3-hierarchy';\n/**\n * Nest tuples into a tree structure, grouped by key values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n * @param {boolean} [params.generate=false] - A boolean flag indicating if\n *   non-leaf nodes generated by this transform should be included in the\n *   output. The default (false) includes only the input data (leaf nodes)\n *   in the data stream.\n */\n\nexport default function Nest(params) {\n  Transform.call(this, null, params);\n}\nNest.Definition = {\n  \"type\": \"Nest\",\n  \"metadata\": {\n    \"treesource\": true,\n    \"changes\": true\n  },\n  \"params\": [{\n    \"name\": \"keys\",\n    \"type\": \"field\",\n    \"array\": true\n  }, {\n    \"name\": \"generate\",\n    \"type\": \"boolean\"\n  }]\n};\nvar prototype = inherits(Nest, Transform);\n\nfunction children(n) {\n  return n.values;\n}\n\nprototype.transform = function (_, pulse) {\n  if (!pulse.source) {\n    error('Nest transform requires an upstream data source.');\n  }\n\n  var gen = _.generate,\n      mod = _.modified(),\n      out = pulse.clone(),\n      tree = this.value;\n\n  if (!tree || mod || pulse.changed()) {\n    // collect nodes to remove\n    if (tree) {\n      tree.each(node => {\n        if (node.children && isTuple(node.data)) {\n          out.rem.push(node.data);\n        }\n      });\n    } // generate new tree structure\n\n\n    this.value = tree = hierarchy({\n      values: array(_.keys).reduce((n, k) => {\n        n.key(k);\n        return n;\n      }, nest()).entries(out.source)\n    }, children); // collect nodes to add\n\n    if (gen) {\n      tree.each(node => {\n        if (node.children) {\n          node = ingest(node.data);\n          out.add.push(node);\n          out.source.push(node);\n        }\n      });\n    } // build lookup table\n\n\n    lookup(tree, tupleid, tupleid);\n  }\n\n  out.source.root = tree;\n  return out;\n};\n\nfunction nest() {\n  var keys = [],\n      nest;\n\n  function apply(array, depth) {\n    if (depth >= keys.length) {\n      return array;\n    }\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        value,\n        valuesByKey = {},\n        values,\n        result = {};\n\n    while (++i < n) {\n      keyValue = key(value = array[i]) + '';\n\n      if (values = valuesByKey[keyValue]) {\n        values.push(value);\n      } else {\n        valuesByKey[keyValue] = [value];\n      }\n    }\n\n    for (keyValue in valuesByKey) {\n      result[keyValue] = apply(valuesByKey[keyValue], depth);\n    }\n\n    return result;\n  }\n\n  function entries(map, depth) {\n    if (++depth > keys.length) return map;\n    var array = [],\n        k;\n\n    for (k in map) {\n      array.push({\n        key: k,\n        values: entries(map[k], depth)\n      });\n    }\n\n    return array;\n  }\n\n  return nest = {\n    entries: array => entries(apply(array, 0), 0),\n    key: d => {\n      keys.push(d);\n      return nest;\n    }\n  };\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-hierarchy/src/Nest.js"],"names":["lookup","ingest","isTuple","Transform","tupleid","array","error","inherits","hierarchy","Nest","params","call","Definition","prototype","children","n","values","transform","_","pulse","source","gen","generate","mod","modified","out","clone","tree","value","changed","each","node","data","rem","push","keys","reduce","k","key","nest","entries","add","root","apply","depth","length","i","keyValue","valuesByKey","result","map","d"],"mappings":"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","sourcesContent":["import lookup from './lookup';\nimport {ingest, isTuple, Transform, tupleid} from 'vega-dataflow';\nimport {array, error, inherits} from 'vega-util';\nimport {hierarchy} from 'd3-hierarchy';\n\n /**\n  * Nest tuples into a tree structure, grouped by key values.\n  * @constructor\n  * @param {object} params - The parameters for this operator.\n  * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n  * @param {boolean} [params.generate=false] - A boolean flag indicating if\n  *   non-leaf nodes generated by this transform should be included in the\n  *   output. The default (false) includes only the input data (leaf nodes)\n  *   in the data stream.\n  */\nexport default function Nest(params) {\n  Transform.call(this, null, params);\n}\n\nNest.Definition = {\n  \"type\": \"Nest\",\n  \"metadata\": {\"treesource\": true, \"changes\": true},\n  \"params\": [\n    { \"name\": \"keys\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"generate\", \"type\": \"boolean\" }\n  ]\n};\n\nvar prototype = inherits(Nest, Transform);\n\nfunction children(n) {\n  return n.values;\n}\n\nprototype.transform = function(_, pulse) {\n  if (!pulse.source) {\n    error('Nest transform requires an upstream data source.');\n  }\n\n  var gen = _.generate,\n      mod = _.modified(),\n      out = pulse.clone(),\n      tree = this.value;\n\n  if (!tree || mod || pulse.changed()) {\n    // collect nodes to remove\n    if (tree) {\n      tree.each(node => {\n        if (node.children && isTuple(node.data)) {\n          out.rem.push(node.data);\n        }\n      });\n    }\n\n    // generate new tree structure\n    this.value = tree = hierarchy({\n      values: array(_.keys)\n        .reduce((n, k) => { n.key(k); return n; }, nest())\n        .entries(out.source)\n    }, children);\n\n    // collect nodes to add\n    if (gen) {\n      tree.each(node => {\n        if (node.children) {\n          node = ingest(node.data);\n          out.add.push(node);\n          out.source.push(node);\n        }\n      });\n    }\n\n    // build lookup table\n    lookup(tree, tupleid, tupleid);\n  }\n\n  out.source.root = tree;\n  return out;\n};\n\nfunction nest() {\n  var keys = [],\n      nest;\n\n  function apply(array, depth) {\n    if (depth >= keys.length) {\n      return array;\n    }\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        value,\n        valuesByKey = {},\n        values,\n        result = {};\n\n    while (++i < n) {\n      keyValue = key(value = array[i]) + '';\n      if (values = valuesByKey[keyValue]) {\n        values.push(value);\n      } else {\n        valuesByKey[keyValue] = [value];\n      }\n    }\n\n    for (keyValue in valuesByKey) {\n      result[keyValue] = apply(valuesByKey[keyValue], depth);\n    }\n\n    return result;\n  }\n\n  function entries(map, depth) {\n    if (++depth > keys.length) return map;\n    var array = [], k;\n    for (k in map) {\n      array.push({key: k, values: entries(map[k], depth)});\n    }\n    return array;\n  }\n\n  return nest = {\n    entries: array => entries(apply(array, 0), 0),\n    key: d => { keys.push(d); return nest; }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}