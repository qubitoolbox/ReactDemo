{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { getFirstDefined, keys, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { expression } from '../predicate';\nimport { isText } from '../../title';\n\nfunction assembleTitle(title, config) {\n  if (!title) {\n    return undefined;\n  }\n\n  if (!isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n\n  return title;\n}\n\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  var _a, _b, _c;\n\n  axis.encode = (_a = axis.encode, _a !== null && _a !== void 0 ? _a : {});\n  axis.encode[part] = (_b = axis.encode[part], _b !== null && _b !== void 0 ? _b : {});\n  axis.encode[part].update = (_c = axis.encode[part].update, _c !== null && _c !== void 0 ? _c : {}); // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n\n  axis.encode[part].update[vgProp] = vgRef;\n}\n\nexport function assembleAxis(axisCmpt, kind, config, opt = {\n  header: false\n}) {\n  var _a, _b;\n\n  const _c = axisCmpt.combine(),\n        {\n    orient,\n    scale,\n    labelExpr,\n    title,\n    zindex\n  } = _c,\n        axis = __rest(_c, [\"orient\", \"scale\", \"labelExpr\", \"title\", \"zindex\"]); // Remove properties that are not valid for this kind of axis\n\n\n  keys(axis).forEach(prop => {\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n\n    if (propType && propType !== kind && propType !== 'both') {\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      const {\n        vgProp,\n        part\n      } = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      const {\n        condition,\n        value\n      } = propValue;\n      const vgRef = [...(isArray(condition) ? condition : [condition]).map(c => {\n        const {\n          value: v,\n          test\n        } = c;\n        return {\n          test: expression(null, test),\n          value: v\n        };\n      }), {\n        value\n      }];\n      setAxisEncode(axis, part, vgProp, vgRef);\n      delete axis[prop];\n    }\n  });\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {\n        grid\n      } = axis.encode;\n      axis.encode = Object.assign({}, grid ? {\n        grid\n      } : {});\n\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    return Object.assign(Object.assign({\n      scale,\n      orient\n    }, axis), {\n      domain: false,\n      labels: false,\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n\n    });\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n\n      if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    const titleString = assembleTitle(title, config);\n    return Object.assign(Object.assign(Object.assign({\n      scale,\n      orient,\n      grid: false\n    }, titleString ? {\n      title: titleString\n    } : {}), axis), {\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n\n    });\n  }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\n\nexport function assembleAxisSignals(model) {\n  const {\n    axes\n  } = model.component;\n\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/weight so x-axis can draw the grid with the right height. Same for y-axis and width.\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          return [{\n            name: sizeType,\n            update: model.getSizeSignalRef(sizeType).signal\n          }];\n        }\n      }\n    }\n  }\n\n  return [];\n}\nexport function assembleAxes(axisComponents, config) {\n  const {\n    x = [],\n    y = []\n  } = axisComponents;\n  return [...x.map(a => assembleAxis(a, 'grid', config)), ...y.map(a => assembleAxis(a, 'grid', config)), ...x.map(a => assembleAxis(a, 'main', config)), ...y.map(a => assembleAxis(a, 'main', config))].filter(a => a); // filter undefined\n}","map":{"version":3,"sources":["../../../../src/compile/axis/assemble.ts"],"names":[],"mappings":"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","sourcesContent":["import {Axis as VgAxis, AxisEncode, NewSignal, Text} from 'vega';\nimport {isArray} from 'vega-util';\nimport {AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue} from '../../axis';\nimport {POSITION_SCALE_CHANNELS} from '../../channel';\nimport {defaultTitle, FieldDefBase} from '../../channeldef';\nimport {Config} from '../../config';\nimport {getFirstDefined, keys, replaceAll} from '../../util';\nimport {isSignalRef, VgEncodeChannel, VgValueRef} from '../../vega.schema';\nimport {Model} from '../model';\nimport {expression} from '../predicate';\nimport {AxisComponent, AxisComponentIndex} from './component';\nimport {isText} from '../../title';\n\nfunction assembleTitle(title: Text | FieldDefBase<string>[], config: Config): Text {\n  if (!title) {\n    return undefined;\n  }\n  if (!isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n  return title;\n}\n\nfunction setAxisEncode(\n  axis: Omit<VgAxis, 'orient' | 'scale'>,\n  part: keyof AxisEncode,\n  vgProp: VgEncodeChannel,\n  vgRef: VgValueRef | readonly VgValueRef[]\n) {\n  axis.encode = axis.encode ?? {};\n  axis.encode[part] = axis.encode[part] ?? {};\n  axis.encode[part].update = axis.encode[part].update ?? {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  (axis.encode[part].update[vgProp] as any) = vgRef;\n}\n\nexport function assembleAxis(\n  axisCmpt: AxisComponent,\n  kind: 'main' | 'grid',\n  config: Config,\n  opt: {\n    header: boolean; // whether this is called via a header\n  } = {header: false}\n): VgAxis {\n  const {orient, scale, labelExpr, title, zindex, ...axis} = axisCmpt.combine();\n\n  // Remove properties that are not valid for this kind of axis\n  keys(axis).forEach(prop => {\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n    if (propType && propType !== kind && propType !== 'both') {\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      const {vgProp, part} = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      const {condition, value} = propValue;\n\n      const vgRef = [\n        ...(isArray(condition) ? condition : [condition]).map(c => {\n          const {value: v, test} = c;\n          return {\n            test: expression(null, test),\n            value: v\n          };\n        }),\n        {value}\n      ];\n\n      setAxisEncode(axis, part, vgProp, vgRef);\n\n      delete axis[prop];\n    }\n  });\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {grid} = axis.encode;\n      axis.encode = {\n        ...(grid ? {grid} : {})\n      };\n\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    return {\n      scale,\n      orient,\n      ...axis,\n      domain: false,\n      labels: false,\n\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    };\n  } else {\n    // kind === 'main'\n\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n      if (axis.encode?.labels?.update && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n\n      setAxisEncode(axis, 'labels', 'text', {signal: expr});\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    const titleString = assembleTitle(title, config);\n\n    return {\n      scale,\n      orient,\n      grid: false,\n      ...(titleString ? {title: titleString} : {}),\n      ...axis,\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n    };\n  }\n}\n\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model: Model): NewSignal[] {\n  const {axes} = model.component;\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/weight so x-axis can draw the grid with the right height. Same for y-axis and width.\n\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          return [\n            {\n              name: sizeType,\n              update: model.getSizeSignalRef(sizeType).signal\n            }\n          ];\n        }\n      }\n    }\n  }\n  return [];\n}\n\nexport function assembleAxes(axisComponents: AxisComponentIndex, config: Config): VgAxis[] {\n  const {x = [], y = []} = axisComponents;\n  return [\n    ...x.map(a => assembleAxis(a, 'grid', config)),\n    ...y.map(a => assembleAxis(a, 'grid', config)),\n    ...x.map(a => assembleAxis(a, 'main', config)),\n    ...y.map(a => assembleAxis(a, 'main', config))\n  ].filter(a => a); // filter undefined\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}