{"ast":null,"code":"import * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n\nexport class Split {\n  constructor(explicit = {}, implicit = {}) {\n    this.explicit = explicit;\n    this.implicit = implicit;\n  }\n\n  clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  combine() {\n    // FIXME remove \"as any\".\n    // Add \"as any\" to avoid an error \"Spread types may only be created from object types\".\n    return Object.assign(Object.assign({}, this.explicit), this.implicit);\n  }\n\n  get(key) {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n\n  getWithExplicit(key) {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {\n        explicit: true,\n        value: this.explicit[key]\n      };\n    } else if (this.implicit[key] !== undefined) {\n      return {\n        explicit: false,\n        value: this.implicit[key]\n      };\n    }\n\n    return {\n      explicit: false,\n      value: undefined\n    };\n  }\n\n  setWithExplicit(key, value) {\n    if (value.value !== undefined) {\n      this.set(key, value.value, value.explicit);\n    }\n  }\n\n  set(key, value, explicit) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  copyKeyFromSplit(key, s) {\n    // Explicit has higher precedence\n    if (s.explicit[key] !== undefined) {\n      this.set(key, s.explicit[key], true);\n    } else if (s.implicit[key] !== undefined) {\n      this.set(key, s.implicit[key], false);\n    }\n  }\n\n  copyKeyFromObject(key, s) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n\n\n  copyAll(other) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n\n}\nexport function makeExplicit(value) {\n  return {\n    explicit: true,\n    value\n  };\n}\nexport function makeImplicit(value) {\n  return {\n    explicit: false,\n    value\n  };\n}\nexport function tieBreakByComparing(compare) {\n  return (v1, v2, property, propertyOf) => {\n    const diff = compare(v1.value, v2.value);\n\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n\n    return defaultTieBreaker(v1, v2, property, propertyOf);\n  };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  } // If equal score, prefer v1.\n\n\n  return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf, tieBreaker = defaultTieBreaker) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}","map":{"version":3,"sources":["../../../src/compile/split.ts"],"names":[],"mappings":"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","sourcesContent":["import * as log from '../log';\nimport {deepEqual, duplicate, getFirstDefined, keys} from '../util';\n\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\nexport class Split<T extends object> {\n  constructor(public readonly explicit: Partial<T> = {}, public readonly implicit: Partial<T> = {}) {}\n\n  public clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  public combine(): Partial<T> {\n    // FIXME remove \"as any\".\n    // Add \"as any\" to avoid an error \"Spread types may only be created from object types\".\n    return {\n      ...(this.explicit as any), // Explicit properties comes first\n      ...(this.implicit as any)\n    };\n  }\n\n  public get<K extends keyof T>(key: K): T[K] {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n\n  public getWithExplicit<K extends keyof T>(key: K): Explicit<T[K]> {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {explicit: true, value: this.explicit[key]};\n    } else if (this.implicit[key] !== undefined) {\n      return {explicit: false, value: this.implicit[key]};\n    }\n    return {explicit: false, value: undefined};\n  }\n\n  public setWithExplicit<K extends keyof T>(key: K, value: Explicit<T[K]>) {\n    if (value.value !== undefined) {\n      this.set(key, value.value, value.explicit);\n    }\n  }\n\n  public set<K extends keyof T>(key: K, value: T[K], explicit: boolean) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  public copyKeyFromSplit<S extends T>(key: keyof T, s: Split<S>) {\n    // Explicit has higher precedence\n    if (s.explicit[key] !== undefined) {\n      this.set(key, s.explicit[key], true);\n    } else if (s.implicit[key] !== undefined) {\n      this.set(key, s.implicit[key], false);\n    }\n  }\n  public copyKeyFromObject<S extends T>(key: keyof T, s: Partial<S>) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n  public copyAll(other: Split<T>) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n}\n\nexport interface Explicit<T> {\n  explicit: boolean;\n  value: T;\n}\n\nexport function makeExplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: true,\n    value\n  };\n}\n\nexport function makeImplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: false,\n    value\n  };\n}\n\nexport type SplitParentProperty = 'scale' | 'axis' | 'legend' | '';\n\nexport function tieBreakByComparing<S, T>(compare: (v1: T, v2: T) => number) {\n  return (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S | never,\n    propertyOf: SplitParentProperty\n  ): Explicit<T> => {\n    const diff = compare(v1.value, v2.value);\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n    return defaultTieBreaker<S, T>(v1, v2, property, propertyOf);\n  };\n}\n\nexport function defaultTieBreaker<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: SplitParentProperty\n) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, prefer v1.\n  return v1;\n}\n\nexport function mergeValuesWithExplicit<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: SplitParentProperty,\n  tieBreaker: (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S,\n    propertyOf: string\n  ) => Explicit<T> = defaultTieBreaker\n) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}