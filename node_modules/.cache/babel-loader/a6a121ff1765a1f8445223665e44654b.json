{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { keys, replaceAll, stringify, vals } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeLegendComponent } from './parse';\n\nfunction setLegendEncode(legend, part, vgProp, vgRef) {\n  var _a, _b, _c;\n\n  legend.encode = (_a = legend.encode, _a !== null && _a !== void 0 ? _a : {});\n  legend.encode[part] = (_b = legend.encode[part], _b !== null && _b !== void 0 ? _b : {});\n  legend.encode[part].update = (_c = legend.encode[part].update, _c !== null && _c !== void 0 ? _c : {}); // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n\n  legend.encode[part].update[vgProp] = vgRef;\n}\n\nexport function assembleLegends(model) {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.get('domains'));\n\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  return vals(legendByDomain).flat().map(legendCmpt => {\n    var _a, _b, _c, _d;\n\n    const _e = legendCmpt.combine(),\n          {\n      labelExpr,\n      selections\n    } = _e,\n          legend = __rest(_e, [\"labelExpr\", \"selections\"]);\n\n    if ((_a = legend.encode) === null || _a === void 0 ? void 0 : _a.symbols) {\n      const out = legend.encode.symbols.update;\n\n      if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n        // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n        out.stroke = {\n          value: 'transparent'\n        };\n      }\n\n      if (legend.fill) {\n        // If top-level fill is defined, for non color channel's legend, we need remove fill.\n        delete out.fill;\n      }\n    }\n\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n\n      if (((_d = (_c = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.update) === null || _d === void 0 ? void 0 : _d.text) && isSignalRef(legend.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n      }\n\n      setLegendEncode(legend, 'labels', 'text', {\n        signal: expr\n      });\n    }\n\n    return legend;\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/legend/assemble.ts"],"names":[],"mappings":";AACA,SAAQ,IAAR,EAAc,UAAd,EAA0B,SAA1B,EAAqC,IAArC,QAAgD,YAAhD;AACA,SAAQ,WAAR,QAAuD,mBAAvD;AAGA,SAAQ,oBAAR,QAAmC,SAAnC;;AAEA,SAAS,eAAT,CACE,MADF,EAEE,IAFF,EAGE,MAHF,EAIE,KAJF,EAIkC;;;AAEhC,EAAA,MAAM,CAAC,MAAP,IAAa,EAAA,GAAG,MAAM,CAAC,MAAV,EAAgB,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAjC;AACA,EAAA,MAAM,CAAC,MAAP,CAAc,IAAd,KAAmB,EAAA,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAH,EAAsB,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAA7C;AACA,EAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB,MAApB,IAA0B,EAAA,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB,MAAvB,EAA6B,EAAA,KAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAA3D,EAJgC,CAKhC;;AACC,EAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB,MAApB,CAA2B,MAA3B,IAA6C,KAA7C;AACF;;AAED,OAAM,SAAU,eAAV,CAA0B,KAA1B,EAAsC;AAC1C,QAAM,oBAAoB,GAAG,KAAK,CAAC,SAAN,CAAgB,OAA7C;AACA,QAAM,cAAc,GAA8C,EAAlE;;AAEA,OAAK,MAAM,OAAX,IAAsB,IAAI,CAAC,oBAAD,CAA1B,EAAkD;AAChD,UAAM,cAAc,GAAG,KAAK,CAAC,iBAAN,CAAwB,OAAxB,CAAvB;AACA,UAAM,UAAU,GAAG,SAAS,CAAC,cAAc,CAAC,GAAf,CAAmB,SAAnB,CAAD,CAA5B;;AACA,QAAI,cAAc,CAAC,UAAD,CAAlB,EAAgC;AAC9B,WAAK,MAAM,qBAAX,IAAoC,cAAc,CAAC,UAAD,CAAlD,EAAgE;AAC9D,cAAM,MAAM,GAAG,oBAAoB,CAAC,qBAAD,EAAwB,oBAAoB,CAAC,OAAD,CAA5C,CAAnC;;AACA,YAAI,CAAC,MAAL,EAAa;AACX;AACA,UAAA,cAAc,CAAC,UAAD,CAAd,CAA2B,IAA3B,CAAgC,oBAAoB,CAAC,OAAD,CAApD;AACD;AACF;AACF,KARD,MAQO;AACL,MAAA,cAAc,CAAC,UAAD,CAAd,GAA6B,CAAC,oBAAoB,CAAC,OAAD,CAApB,CAA8B,KAA9B,EAAD,CAA7B;AACD;AACF;;AAED,SAAO,IAAI,CAAC,cAAD,CAAJ,CACJ,IADI,GAEJ,GAFI,CAEC,UAAD,IAAgC;;;AACnC,UAAM,EAAA,GAAA,UAAA,CAAA,OAAA,EAAN;AAAA,UAAM;AAAC,MAAA,SAAD;AAAY,MAAA;AAAZ,QAAsB,EAA5B;AAAA,UAA8B,MAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,WAAA,EAAA,YAAA,CAAA,CAA9B;;AAEA,QAAA,CAAA,EAAA,GAAI,MAAM,CAAC,MAAX,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,KAAA,CAAjB,GAAiB,EAAA,CAAE,OAAnB,EAA4B;AAC1B,YAAM,GAAG,GAAG,MAAM,CAAC,MAAP,CAAc,OAAd,CAAsB,MAAlC;;AACA,UAAI,GAAG,CAAC,IAAJ,IAAY,GAAG,CAAC,IAAJ,CAAS,OAAT,MAAsB,aAAlC,IAAmD,CAAC,GAAG,CAAC,MAAxD,IAAkE,CAAC,MAAM,CAAC,MAA9E,EAAsF;AACpF;AACA,QAAA,GAAG,CAAC,MAAJ,GAAa;AAAC,UAAA,KAAK,EAAE;AAAR,SAAb;AACD;;AAED,UAAI,MAAM,CAAC,IAAX,EAAiB;AACf;AACA,eAAO,GAAG,CAAC,IAAX;AACD;AACF;;AAED,QAAI,SAAS,KAAK,SAAlB,EAA6B;AAC3B,UAAI,IAAI,GAAG,SAAX;;AACA,UAAI,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,MAAM,CAAC,MAAP,MAAa,IAAb,IAAa,EAAA,KAAA,KAAA,CAAb,GAAa,KAAA,CAAb,GAAa,EAAA,CAAE,MAAf,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,KAAA,CAArB,GAAqB,EAAA,CAAE,MAAvB,MAA6B,IAA7B,IAA6B,EAAA,KAAA,KAAA,CAA7B,GAA6B,KAAA,CAA7B,GAA6B,EAAA,CAAE,IAA/B,KAAuC,WAAW,CAAC,MAAM,CAAC,MAAP,CAAc,MAAd,CAAqB,MAArB,CAA4B,IAA7B,CAAtD,EAA0F;AACxF,QAAA,IAAI,GAAG,UAAU,CAAC,SAAD,EAAY,aAAZ,EAA2B,MAAM,CAAC,MAAP,CAAc,MAAd,CAAqB,MAArB,CAA4B,IAA5B,CAAiC,MAA5D,CAAjB;AACD;;AAED,MAAA,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,MAAnB,EAA2B;AAAC,QAAA,MAAM,EAAE;AAAT,OAA3B,CAAf;AACD;;AAED,WAAO,MAAP;AACD,GA5BI,CAAP;AA6BD","sourcesContent":["import {Legend as VgLegend, LegendEncode} from 'vega';\nimport {keys, replaceAll, stringify, vals} from '../../util';\nimport {isSignalRef, VgEncodeChannel, VgValueRef} from '../../vega.schema';\nimport {Model} from '../model';\nimport {LegendComponent} from './component';\nimport {mergeLegendComponent} from './parse';\n\nfunction setLegendEncode(\n  legend: VgLegend,\n  part: keyof LegendEncode,\n  vgProp: VgEncodeChannel,\n  vgRef: VgValueRef | VgValueRef[]\n) {\n  legend.encode = legend.encode ?? {};\n  legend.encode[part] = legend.encode[part] ?? {};\n  legend.encode[part].update = legend.encode[part].update ?? {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  (legend.encode[part].update[vgProp] as any) = vgRef;\n}\n\nexport function assembleLegends(model: Model): VgLegend[] {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain: {[domainHash: string]: LegendComponent[]} = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.get('domains'));\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  return vals(legendByDomain)\n    .flat()\n    .map((legendCmpt: LegendComponent) => {\n      const {labelExpr, selections, ...legend} = legendCmpt.combine();\n\n      if (legend.encode?.symbols) {\n        const out = legend.encode.symbols.update;\n        if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n          // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n          out.stroke = {value: 'transparent'};\n        }\n\n        if (legend.fill) {\n          // If top-level fill is defined, for non color channel's legend, we need remove fill.\n          delete out.fill;\n        }\n      }\n\n      if (labelExpr !== undefined) {\n        let expr = labelExpr;\n        if (legend.encode?.labels?.update?.text && isSignalRef(legend.encode.labels.update.text)) {\n          expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n        }\n\n        setLegendEncode(legend, 'labels', 'text', {signal: expr});\n      }\n\n      return legend;\n    });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}