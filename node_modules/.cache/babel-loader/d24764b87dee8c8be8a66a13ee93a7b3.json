{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isUnitSpec } from '../spec/unit';\nimport { keys, omit } from '../util';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { RangeStepNormalizer } from './rangestep';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport class CoreNormalizer extends SpecMapper {\n  constructor() {\n    super(...arguments);\n    this.nonFacetUnitNormalizers = [boxPlotNormalizer, errorBarNormalizer, errorBandNormalizer, new PathOverlayNormalizer(), new RuleForRangedLineNormalizer(), new RangeStepNormalizer()];\n  }\n\n  map(spec, params) {\n    // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n    if (isUnitSpec(spec)) {\n      const hasRow = channelHasField(spec.encoding, ROW);\n      const hasColumn = channelHasField(spec.encoding, COLUMN);\n      const hasFacet = channelHasField(spec.encoding, FACET);\n\n      if (hasRow || hasColumn || hasFacet) {\n        return this.mapFacetedUnit(spec, params);\n      }\n    }\n\n    return super.map(spec, params);\n  } // This is for normalizing non-facet unit\n\n\n  mapUnit(spec, params) {\n    const {\n      parentEncoding,\n      parentProjection\n    } = params;\n\n    if (parentEncoding || parentProjection) {\n      return this.mapUnitWithParentEncodingOrProjection(spec, params);\n    }\n\n    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n\n    for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n      if (unitNormalizer.hasMatchingType(spec, params.config)) {\n        return unitNormalizer.run(spec, params, normalizeLayerOrUnit);\n      }\n    }\n\n    return spec;\n  }\n\n  mapRepeat(spec, params) {\n    const {\n      repeat\n    } = spec;\n\n    if (!isArray(repeat) && spec.columns) {\n      // is repeat with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n    }\n\n    return Object.assign(Object.assign({}, spec), {\n      spec: this.map(spec.spec, params)\n    });\n  }\n\n  mapFacet(spec, params) {\n    const {\n      facet\n    } = spec;\n\n    if (isFacetMapping(facet) && spec.columns) {\n      // is facet with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('facet'));\n    }\n\n    return super.mapFacet(spec, params);\n  }\n\n  mapUnitWithParentEncodingOrProjection(spec, params) {\n    const {\n      encoding,\n      projection\n    } = spec;\n    const {\n      parentEncoding,\n      parentProjection,\n      config\n    } = params;\n    const mergedProjection = mergeProjection({\n      parentProjection,\n      projection\n    });\n    const mergedEncoding = mergeEncoding({\n      parentEncoding,\n      encoding\n    });\n    return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? {\n      projection: mergedProjection\n    } : {}), mergedEncoding ? {\n      encoding: mergedEncoding\n    } : {}), {\n      config\n    });\n  }\n\n  mapFacetedUnit(spec, params) {\n    // New encoding in the inside spec should not contain row / column\n    // as row/column should be moved to facet\n    const _a = spec.encoding,\n          {\n      row,\n      column,\n      facet\n    } = _a,\n          encoding = __rest(_a, [\"row\", \"column\", \"facet\"]); // Mark and encoding should be moved into the inner spec\n\n\n    const {\n      mark,\n      width,\n      projection,\n      height,\n      selection,\n      encoding: _\n    } = spec,\n          outerSpec = __rest(spec, [\"mark\", \"width\", \"projection\", \"height\", \"selection\", \"encoding\"]);\n\n    const {\n      facetMapping,\n      layout\n    } = this.getFacetMappingAndLayout({\n      row,\n      column,\n      facet\n    });\n    return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {\n      // row / column has higher precedence than facet\n      facet: facetMapping,\n      spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, projection ? {\n        projection\n      } : {}), {\n        mark\n      }), width ? {\n        width\n      } : {}), height ? {\n        height\n      } : {}), {\n        encoding\n      }), selection ? {\n        selection\n      } : {})\n    }), params);\n  }\n\n  getFacetMappingAndLayout(facets) {\n    var _a;\n\n    const {\n      row,\n      column,\n      facet\n    } = facets;\n\n    if (row || column) {\n      if (facet) {\n        log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n      }\n\n      const facetMapping = {};\n      const layout = {};\n\n      for (const channel of [ROW, COLUMN]) {\n        const def = facets[channel];\n\n        if (def) {\n          const {\n            align,\n            center,\n            spacing,\n            columns\n          } = def,\n                defWithoutLayout = __rest(def, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n          facetMapping[channel] = defWithoutLayout;\n\n          for (const prop of ['align', 'center', 'spacing']) {\n            if (def[prop] !== undefined) {\n              layout[prop] = (_a = layout[prop], _a !== null && _a !== void 0 ? _a : {});\n              layout[prop][channel] = def[prop];\n            }\n          }\n        }\n      }\n\n      return {\n        facetMapping,\n        layout\n      };\n    } else {\n      const {\n        align,\n        center,\n        spacing,\n        columns\n      } = facet,\n            facetMapping = __rest(facet, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n      return {\n        facetMapping,\n        layout: Object.assign(Object.assign(Object.assign(Object.assign({}, align ? {\n          align\n        } : {}), center ? {\n          center\n        } : {}), spacing ? {\n          spacing\n        } : {}), columns ? {\n          columns\n        } : {})\n      };\n    }\n  }\n\n  mapLayer(spec, _a) {\n    // Special handling for extended layer spec\n    var {\n      parentEncoding,\n      parentProjection\n    } = _a,\n        otherParams = __rest(_a, [\"parentEncoding\", \"parentProjection\"]);\n\n    const {\n      encoding,\n      projection\n    } = spec,\n          rest = __rest(spec, [\"encoding\", \"projection\"]);\n\n    const params = Object.assign(Object.assign({}, otherParams), {\n      parentEncoding: mergeEncoding({\n        parentEncoding,\n        encoding\n      }),\n      parentProjection: mergeProjection({\n        parentProjection,\n        projection\n      })\n    });\n    return super.mapLayer(rest, params);\n  }\n\n}\n\nfunction mergeEncoding(opt) {\n  const {\n    parentEncoding,\n    encoding\n  } = opt;\n\n  if (parentEncoding && encoding) {\n    const overriden = keys(parentEncoding).reduce((o, key) => {\n      if (encoding[key]) {\n        o.push(key);\n      }\n\n      return o;\n    }, []);\n\n    if (overriden.length > 0) {\n      log.warn(log.message.encodingOverridden(overriden));\n    }\n  }\n\n  const merged = Object.assign(Object.assign({}, parentEncoding !== null && parentEncoding !== void 0 ? parentEncoding : {}), encoding !== null && encoding !== void 0 ? encoding : {});\n  return keys(merged).length > 0 ? merged : undefined;\n}\n\nfunction mergeProjection(opt) {\n  const {\n    parentProjection,\n    projection\n  } = opt;\n\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({\n      parentProjection,\n      projection\n    }));\n  }\n\n  return projection !== null && projection !== void 0 ? projection : parentProjection;\n}","map":{"version":3,"sources":["../../../src/normalize/core.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {COLUMN, FACET, ROW} from '../channel';\nimport {Field} from '../channeldef';\nimport {boxPlotNormalizer} from '../compositemark/boxplot';\nimport {errorBandNormalizer} from '../compositemark/errorband';\nimport {errorBarNormalizer} from '../compositemark/errorbar';\nimport {channelHasField, Encoding} from '../encoding';\nimport * as log from '../log';\nimport {Projection} from '../projection';\nimport {ExtendedLayerSpec, FacetedUnitSpec, GenericSpec, UnitSpec} from '../spec';\nimport {GenericCompositionLayoutWithColumns} from '../spec/base';\nimport {\n  FacetEncodingFieldDef,\n  FacetFieldDef,\n  FacetMapping,\n  GenericFacetSpec,\n  isFacetMapping,\n  NormalizedFacetSpec\n} from '../spec/facet';\nimport {GenericLayerSpec, NormalizedLayerSpec} from '../spec/layer';\nimport {SpecMapper} from '../spec/map';\nimport {GenericRepeatSpec} from '../spec/repeat';\nimport {isUnitSpec, NormalizedUnitSpec} from '../spec/unit';\nimport {keys, omit} from '../util';\nimport {NonFacetUnitNormalizer, NormalizerParams} from './base';\nimport {PathOverlayNormalizer} from './pathoverlay';\nimport {RangeStepNormalizer} from './rangestep';\nimport {RuleForRangedLineNormalizer} from './ruleforrangedline';\n\nexport class CoreNormalizer extends SpecMapper<NormalizerParams, FacetedUnitSpec, ExtendedLayerSpec> {\n  private nonFacetUnitNormalizers: NonFacetUnitNormalizer<any>[] = [\n    boxPlotNormalizer,\n    errorBarNormalizer,\n    errorBandNormalizer,\n    new PathOverlayNormalizer(),\n    new RuleForRangedLineNormalizer(),\n    new RangeStepNormalizer()\n  ];\n\n  public map(spec: GenericSpec<FacetedUnitSpec, ExtendedLayerSpec>, params: NormalizerParams) {\n    // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n    if (isUnitSpec(spec)) {\n      const hasRow = channelHasField(spec.encoding, ROW);\n      const hasColumn = channelHasField(spec.encoding, COLUMN);\n      const hasFacet = channelHasField(spec.encoding, FACET);\n\n      if (hasRow || hasColumn || hasFacet) {\n        return this.mapFacetedUnit(spec, params);\n      }\n    }\n\n    return super.map(spec, params);\n  }\n\n  // This is for normalizing non-facet unit\n  public mapUnit(spec: UnitSpec, params: NormalizerParams): NormalizedUnitSpec | NormalizedLayerSpec {\n    const {parentEncoding, parentProjection} = params;\n    if (parentEncoding || parentProjection) {\n      return this.mapUnitWithParentEncodingOrProjection(spec, params);\n    }\n\n    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n\n    for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n      if (unitNormalizer.hasMatchingType(spec, params.config)) {\n        return unitNormalizer.run(spec, params, normalizeLayerOrUnit);\n      }\n    }\n\n    return spec as NormalizedUnitSpec;\n  }\n\n  protected mapRepeat(\n    spec: GenericRepeatSpec<UnitSpec, ExtendedLayerSpec>,\n    params: NormalizerParams\n  ): GenericRepeatSpec<NormalizedUnitSpec, NormalizedLayerSpec> {\n    const {repeat} = spec;\n\n    if (!isArray(repeat) && spec.columns) {\n      // is repeat with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n    }\n\n    return {\n      ...spec,\n      spec: this.map(spec.spec, params)\n    };\n  }\n\n  protected mapFacet(\n    spec: GenericFacetSpec<UnitSpec, ExtendedLayerSpec>,\n    params: NormalizerParams\n  ): GenericFacetSpec<NormalizedUnitSpec, NormalizedLayerSpec> {\n    const {facet} = spec;\n\n    if (isFacetMapping(facet) && spec.columns) {\n      // is facet with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('facet'));\n    }\n\n    return super.mapFacet(spec, params);\n  }\n\n  private mapUnitWithParentEncodingOrProjection(\n    spec: FacetedUnitSpec,\n    params: NormalizerParams\n  ): NormalizedUnitSpec | NormalizedLayerSpec {\n    const {encoding, projection} = spec;\n    const {parentEncoding, parentProjection, config} = params;\n    const mergedProjection = mergeProjection({parentProjection, projection});\n    const mergedEncoding = mergeEncoding({parentEncoding, encoding});\n    return this.mapUnit(\n      {\n        ...spec,\n        ...(mergedProjection ? {projection: mergedProjection} : {}),\n        ...(mergedEncoding ? {encoding: mergedEncoding} : {})\n      },\n      {config}\n    );\n  }\n\n  private mapFacetedUnit(spec: FacetedUnitSpec, params: NormalizerParams): NormalizedFacetSpec {\n    // New encoding in the inside spec should not contain row / column\n    // as row/column should be moved to facet\n    const {row, column, facet, ...encoding} = spec.encoding;\n\n    // Mark and encoding should be moved into the inner spec\n    const {mark, width, projection, height, selection, encoding: _, ...outerSpec} = spec;\n\n    const {facetMapping, layout} = this.getFacetMappingAndLayout({row, column, facet});\n\n    return this.mapFacet(\n      {\n        ...outerSpec,\n        ...layout,\n\n        // row / column has higher precedence than facet\n        facet: facetMapping,\n        spec: {\n          ...(projection ? {projection} : {}),\n          mark,\n          ...(width ? {width} : {}),\n          ...(height ? {height} : {}),\n          encoding,\n          ...(selection ? {selection} : {})\n        }\n      },\n      params\n    );\n  }\n\n  private getFacetMappingAndLayout(facets: {\n    row: FacetEncodingFieldDef<Field>;\n    column: FacetEncodingFieldDef<Field>;\n    facet: FacetEncodingFieldDef<Field>;\n  }): {facetMapping: FacetMapping<Field> | FacetFieldDef<Field>; layout: GenericCompositionLayoutWithColumns} {\n    const {row, column, facet} = facets;\n\n    if (row || column) {\n      if (facet) {\n        log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n      }\n\n      const facetMapping = {};\n      const layout = {};\n\n      for (const channel of [ROW, COLUMN]) {\n        const def = facets[channel];\n        if (def) {\n          const {align, center, spacing, columns, ...defWithoutLayout} = def;\n          facetMapping[channel] = defWithoutLayout;\n\n          for (const prop of ['align', 'center', 'spacing'] as const) {\n            if (def[prop] !== undefined) {\n              layout[prop] = layout[prop] ?? {};\n              layout[prop][channel] = def[prop];\n            }\n          }\n        }\n      }\n\n      return {facetMapping, layout};\n    } else {\n      const {align, center, spacing, columns, ...facetMapping} = facet;\n      return {\n        facetMapping,\n        layout: {\n          ...(align ? {align} : {}),\n          ...(center ? {center} : {}),\n          ...(spacing ? {spacing} : {}),\n          ...(columns ? {columns} : {})\n        }\n      };\n    }\n  }\n\n  public mapLayer(\n    spec: ExtendedLayerSpec,\n    {parentEncoding, parentProjection, ...otherParams}: NormalizerParams\n  ): GenericLayerSpec<NormalizedUnitSpec> {\n    // Special handling for extended layer spec\n\n    const {encoding, projection, ...rest} = spec;\n    const params: NormalizerParams = {\n      ...otherParams,\n      parentEncoding: mergeEncoding({parentEncoding, encoding}),\n      parentProjection: mergeProjection({parentProjection, projection})\n    };\n    return super.mapLayer(rest, params);\n  }\n}\n\nfunction mergeEncoding(opt: {parentEncoding: Encoding<any>; encoding: Encoding<any>}): Encoding<any> {\n  const {parentEncoding, encoding} = opt;\n  if (parentEncoding && encoding) {\n    const overriden = keys(parentEncoding).reduce((o, key) => {\n      if (encoding[key]) {\n        o.push(key);\n      }\n      return o;\n    }, []);\n\n    if (overriden.length > 0) {\n      log.warn(log.message.encodingOverridden(overriden));\n    }\n  }\n\n  const merged = {\n    ...(parentEncoding ?? {}),\n    ...(encoding ?? {})\n  };\n  return keys(merged).length > 0 ? merged : undefined;\n}\n\nfunction mergeProjection(opt: {parentProjection: Projection; projection: Projection}) {\n  const {parentProjection, projection} = opt;\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({parentProjection, projection}));\n  }\n  return projection ?? parentProjection;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}