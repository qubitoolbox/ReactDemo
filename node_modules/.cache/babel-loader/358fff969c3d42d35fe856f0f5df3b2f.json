{"ast":null,"code":"// subdivide up to accuracy of 0.1 degrees\nconst MIN_RADIANS = 0.1 * Math.PI / 180; // Adaptively sample an interpolated function over a domain extent\n\nexport default function (f, extent, minSteps, maxSteps) {\n  minSteps = minSteps || 25;\n  maxSteps = Math.max(minSteps, maxSteps || 200);\n\n  const point = x => [x, f(x)],\n        minX = extent[0],\n        maxX = extent[1],\n        span = maxX - minX,\n        stop = span / maxSteps,\n        prev = [point(minX)],\n        next = [];\n\n  if (minSteps === maxSteps) {\n    // no adaptation, sample uniform grid directly and return\n    for (let i = 1; i < maxSteps; ++i) {\n      prev.push(point(minX + i / minSteps * span));\n    }\n\n    prev.push(point(maxX));\n    return prev;\n  } else {\n    // sample minimum points on uniform grid\n    // then move on to perform adaptive refinement\n    next.push(point(maxX));\n\n    for (let i = minSteps; --i > 0;) {\n      next.push(point(minX + i / minSteps * span));\n    }\n  }\n\n  let p0 = prev[0],\n      p1 = next[next.length - 1];\n\n  while (p1) {\n    // midpoint for potential curve subdivision\n    const pm = point((p0[0] + p1[0]) / 2);\n\n    if (pm[0] - p0[0] >= stop && angleDelta(p0, pm, p1) > MIN_RADIANS) {\n      // maximum resolution has not yet been met, and\n      // subdivision midpoint sufficiently different from endpoint\n      // save subdivision, push midpoint onto the visitation stack\n      next.push(pm);\n    } else {\n      // subdivision midpoint sufficiently similar to endpoint\n      // skip subdivision, store endpoint, move to next point on the stack\n      p0 = p1;\n      prev.push(p1);\n      next.pop();\n    }\n\n    p1 = next[next.length - 1];\n  }\n\n  return prev;\n}\n\nfunction angleDelta(p, q, r) {\n  const a0 = Math.atan2(r[1] - p[1], r[0] - p[0]),\n        a1 = Math.atan2(q[1] - p[1], q[0] - p[0]);\n  return Math.abs(a0 - a1);\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-statistics/src/sampleCurve.js"],"names":["MIN_RADIANS","Math","PI","f","extent","minSteps","maxSteps","max","point","x","minX","maxX","span","stop","prev","next","i","push","p0","p1","length","pm","angleDelta","pop","p","q","r","a0","atan2","a1","abs"],"mappings":"AAAA;AACA,MAAMA,WAAW,GAAG,MAAMC,IAAI,CAACC,EAAX,GAAgB,GAApC,C,CAEA;;AACA,eAAe,UAASC,CAAT,EAAYC,MAAZ,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwC;AACrDD,EAAAA,QAAQ,GAAGA,QAAQ,IAAI,EAAvB;AACAC,EAAAA,QAAQ,GAAGL,IAAI,CAACM,GAAL,CAASF,QAAT,EAAmBC,QAAQ,IAAI,GAA/B,CAAX;;AAEA,QAAME,KAAK,GAAGC,CAAC,IAAI,CAACA,CAAD,EAAIN,CAAC,CAACM,CAAD,CAAL,CAAnB;AAAA,QACMC,IAAI,GAAGN,MAAM,CAAC,CAAD,CADnB;AAAA,QAEMO,IAAI,GAAGP,MAAM,CAAC,CAAD,CAFnB;AAAA,QAGMQ,IAAI,GAAGD,IAAI,GAAGD,IAHpB;AAAA,QAIMG,IAAI,GAAGD,IAAI,GAAGN,QAJpB;AAAA,QAKMQ,IAAI,GAAG,CAACN,KAAK,CAACE,IAAD,CAAN,CALb;AAAA,QAMMK,IAAI,GAAG,EANb;;AAQA,MAAIV,QAAQ,KAAKC,QAAjB,EAA2B;AACzB;AACA,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,QAApB,EAA8B,EAAEU,CAAhC,EAAmC;AACjCF,MAAAA,IAAI,CAACG,IAAL,CAAUT,KAAK,CAACE,IAAI,GAAIM,CAAC,GAAGX,QAAL,GAAiBO,IAAzB,CAAf;AACD;;AACDE,IAAAA,IAAI,CAACG,IAAL,CAAUT,KAAK,CAACG,IAAD,CAAf;AACA,WAAOG,IAAP;AACD,GAPD,MAOO;AACL;AACA;AACAC,IAAAA,IAAI,CAACE,IAAL,CAAUT,KAAK,CAACG,IAAD,CAAf;;AACA,SAAK,IAAIK,CAAC,GAAGX,QAAb,EAAuB,EAAEW,CAAF,GAAM,CAA7B,GAAiC;AAC/BD,MAAAA,IAAI,CAACE,IAAL,CAAUT,KAAK,CAACE,IAAI,GAAIM,CAAC,GAAGX,QAAL,GAAiBO,IAAzB,CAAf;AACD;AACF;;AAED,MAAIM,EAAE,GAAGJ,IAAI,CAAC,CAAD,CAAb;AAAA,MACIK,EAAE,GAAGJ,IAAI,CAACA,IAAI,CAACK,MAAL,GAAc,CAAf,CADb;;AAGA,SAAOD,EAAP,EAAW;AACT;AACA,UAAME,EAAE,GAAGb,KAAK,CAAC,CAACU,EAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAX,IAAkB,CAAnB,CAAhB;;AAEA,QAAIE,EAAE,CAAC,CAAD,CAAF,GAAQH,EAAE,CAAC,CAAD,CAAV,IAAiBL,IAAjB,IAAyBS,UAAU,CAACJ,EAAD,EAAKG,EAAL,EAASF,EAAT,CAAV,GAAyBnB,WAAtD,EAAmE;AACjE;AACA;AACA;AACAe,MAAAA,IAAI,CAACE,IAAL,CAAUI,EAAV;AACD,KALD,MAKO;AACL;AACA;AACAH,MAAAA,EAAE,GAAGC,EAAL;AACAL,MAAAA,IAAI,CAACG,IAAL,CAAUE,EAAV;AACAJ,MAAAA,IAAI,CAACQ,GAAL;AACD;;AACDJ,IAAAA,EAAE,GAAGJ,IAAI,CAACA,IAAI,CAACK,MAAL,GAAc,CAAf,CAAT;AACD;;AAED,SAAON,IAAP;AACD;;AAED,SAASQ,UAAT,CAAoBE,CAApB,EAAuBC,CAAvB,EAA0BC,CAA1B,EAA6B;AAC3B,QAAMC,EAAE,GAAG1B,IAAI,CAAC2B,KAAL,CAAWF,CAAC,CAAC,CAAD,CAAD,GAAOF,CAAC,CAAC,CAAD,CAAnB,EAAwBE,CAAC,CAAC,CAAD,CAAD,GAAOF,CAAC,CAAC,CAAD,CAAhC,CAAX;AAAA,QACMK,EAAE,GAAG5B,IAAI,CAAC2B,KAAL,CAAWH,CAAC,CAAC,CAAD,CAAD,GAAOD,CAAC,CAAC,CAAD,CAAnB,EAAwBC,CAAC,CAAC,CAAD,CAAD,GAAOD,CAAC,CAAC,CAAD,CAAhC,CADX;AAEA,SAAOvB,IAAI,CAAC6B,GAAL,CAASH,EAAE,GAAGE,EAAd,CAAP;AACD","sourcesContent":["// subdivide up to accuracy of 0.1 degrees\nconst MIN_RADIANS = 0.1 * Math.PI / 180;\n\n// Adaptively sample an interpolated function over a domain extent\nexport default function(f, extent, minSteps, maxSteps) {\n  minSteps = minSteps || 25;\n  maxSteps = Math.max(minSteps, maxSteps || 200);\n\n  const point = x => [x, f(x)],\n        minX = extent[0],\n        maxX = extent[1],\n        span = maxX - minX,\n        stop = span / maxSteps,\n        prev = [point(minX)],\n        next = [];\n\n  if (minSteps === maxSteps) {\n    // no adaptation, sample uniform grid directly and return\n    for (let i = 1; i < maxSteps; ++i) {\n      prev.push(point(minX + (i / minSteps) * span));\n    }\n    prev.push(point(maxX));\n    return prev;\n  } else {\n    // sample minimum points on uniform grid\n    // then move on to perform adaptive refinement\n    next.push(point(maxX));\n    for (let i = minSteps; --i > 0;) {\n      next.push(point(minX + (i / minSteps) * span));\n    }\n  }\n\n  let p0 = prev[0],\n      p1 = next[next.length - 1];\n\n  while (p1) {\n    // midpoint for potential curve subdivision\n    const pm = point((p0[0] + p1[0]) / 2);\n\n    if (pm[0] - p0[0] >= stop && angleDelta(p0, pm, p1) > MIN_RADIANS) {\n      // maximum resolution has not yet been met, and\n      // subdivision midpoint sufficiently different from endpoint\n      // save subdivision, push midpoint onto the visitation stack\n      next.push(pm);\n    } else {\n      // subdivision midpoint sufficiently similar to endpoint\n      // skip subdivision, store endpoint, move to next point on the stack\n      p0 = p1;\n      prev.push(p1);\n      next.pop();\n    }\n    p1 = next[next.length - 1];\n  }\n\n  return prev;\n}\n\nfunction angleDelta(p, q, r) {\n  const a0 = Math.atan2(r[1] - p[1], r[0] - p[0]),\n        a1 = Math.atan2(q[1] - p[1], q[0] - p[0]);\n  return Math.abs(a0 - a1);\n}\n"]},"metadata":{},"sourceType":"module"}