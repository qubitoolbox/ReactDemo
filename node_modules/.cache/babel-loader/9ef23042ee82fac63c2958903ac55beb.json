{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { contains } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { isConcatModel, isLayerModel, isRepeatModel } from '../model';\nexport function assembleProjections(model) {\n  if (isLayerModel(model) || isConcatModel(model) || isRepeatModel(model)) {\n    return assembleProjectionsForModelAndChildren(model);\n  } else {\n    return assembleProjectionForModel(model);\n  }\n}\nexport function assembleProjectionsForModelAndChildren(model) {\n  return model.children.reduce((projections, child) => {\n    return projections.concat(child.assembleProjections());\n  }, assembleProjectionForModel(model));\n}\nexport function assembleProjectionForModel(model) {\n  const component = model.component.projection;\n\n  if (!component || component.merged) {\n    return [];\n  }\n\n  const projection = component.combine();\n\n  const {\n    name\n  } = projection,\n        rest = __rest(projection, [\"name\"]); // we need to extract name so that it is always present in the output and pass TS type validation\n\n\n  if (!component.data) {\n    // generate custom projection, no automatic fitting\n    return [Object.assign(Object.assign({\n      name\n    }, {\n      translate: {\n        signal: '[width / 2, height / 2]'\n      }\n    }), rest)];\n  } else {\n    // generate projection that uses extent fitting\n    const size = {\n      signal: `[${component.size.map(ref => ref.signal).join(', ')}]`\n    };\n    const fit = component.data.reduce((sources, data) => {\n      const source = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;\n\n      if (!contains(sources, source)) {\n        // build a unique list of sources\n        sources.push(source);\n      }\n\n      return sources;\n    }, []);\n\n    if (fit.length <= 0) {\n      throw new Error(\"Projection's fit didn't find any data sources\");\n    }\n\n    return [Object.assign({\n      name,\n      size,\n      fit: {\n        signal: fit.length > 1 ? `[${fit.join(', ')}]` : fit[0]\n      }\n    }, rest)];\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/projection/assemble.ts"],"names":[],"mappings":";AACA,SAAQ,QAAR,QAAuB,YAAvB;AACA,SAAQ,WAAR,QAA0B,mBAA1B;AACA,SAAQ,aAAR,EAAuB,YAAvB,EAAqC,aAArC,QAAgE,UAAhE;AAGA,OAAM,SAAU,mBAAV,CAA8B,KAA9B,EAA0C;AAC9C,MAAI,YAAY,CAAC,KAAD,CAAZ,IAAuB,aAAa,CAAC,KAAD,CAApC,IAA+C,aAAa,CAAC,KAAD,CAAhE,EAAyE;AACvE,WAAO,sCAAsC,CAAC,KAAD,CAA7C;AACD,GAFD,MAEO;AACL,WAAO,0BAA0B,CAAC,KAAD,CAAjC;AACD;AACF;AAED,OAAM,SAAU,sCAAV,CAAiD,KAAjD,EAA6D;AACjE,SAAO,KAAK,CAAC,QAAN,CAAe,MAAf,CAAsB,CAAC,WAAD,EAAc,KAAd,KAAuB;AAClD,WAAO,WAAW,CAAC,MAAZ,CAAmB,KAAK,CAAC,mBAAN,EAAnB,CAAP;AACD,GAFM,EAEJ,0BAA0B,CAAC,KAAD,CAFtB,CAAP;AAGD;AAED,OAAM,SAAU,0BAAV,CAAqC,KAArC,EAAiD;AACrD,QAAM,SAAS,GAAG,KAAK,CAAC,SAAN,CAAgB,UAAlC;;AACA,MAAI,CAAC,SAAD,IAAc,SAAS,CAAC,MAA5B,EAAoC;AAClC,WAAO,EAAP;AACD;;AAED,QAAM,UAAU,GAAG,SAAS,CAAC,OAAV,EAAnB;;AACA,QAAM;AAAC,IAAA;AAAD,MAAkB,UAAxB;AAAA,QAAa,IAAA,GAAA,MAAA,CAAA,UAAA,EAAA,CAAA,MAAA,CAAA,CAAb,CAPqD,CAOjB;;;AAEpC,MAAI,CAAC,SAAS,CAAC,IAAf,EAAqB;AACnB;AACA,WAAO,C;AAEH,MAAA;OAEG;AAAC,MAAA,SAAS,EAAE;AAAC,QAAA,MAAM,EAAE;AAAT;AAAZ,K,GAEA,I,CANA,CAAP;AASD,GAXD,MAWO;AACL;AACA,UAAM,IAAI,GAAc;AACtB,MAAA,MAAM,EAAE,IAAI,SAAS,CAAC,IAAV,CAAe,GAAf,CAAmB,GAAG,IAAI,GAAG,CAAC,MAA9B,EAAsC,IAAtC,CAA2C,IAA3C,CAAgD;AADtC,KAAxB;AAIA,UAAM,GAAG,GAAa,SAAS,CAAC,IAAV,CAAe,MAAf,CAAsB,CAAC,OAAD,EAAU,IAAV,KAAkB;AAC5D,YAAM,MAAM,GAAW,WAAW,CAAC,IAAD,CAAX,GAAoB,IAAI,CAAC,MAAzB,GAAkC,SAAS,KAAK,CAAC,gBAAN,CAAuB,IAAvB,CAA4B,IAA9F;;AACA,UAAI,CAAC,QAAQ,CAAC,OAAD,EAAU,MAAV,CAAb,EAAgC;AAC9B;AACA,QAAA,OAAO,CAAC,IAAR,CAAa,MAAb;AACD;;AACD,aAAO,OAAP;AACD,KAPqB,EAOnB,EAPmB,CAAtB;;AASA,QAAI,GAAG,CAAC,MAAJ,IAAc,CAAlB,EAAqB;AACnB,YAAM,IAAI,KAAJ,CAAU,+CAAV,CAAN;AACD;;AAED,WAAO,C;AAEH,MAAA,I;AACA,MAAA,I;AACA,MAAA,GAAG,EAAE;AACH,QAAA,MAAM,EAAE,GAAG,CAAC,MAAJ,GAAa,CAAb,GAAiB,IAAI,GAAG,CAAC,IAAJ,CAAS,IAAT,CAAc,GAAnC,GAAyC,GAAG,CAAC,CAAD;AADjD;OAGF,I,CAPA,CAAP;AAUD;AACF","sourcesContent":["import {SignalRef} from 'vega';\nimport {contains} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {isConcatModel, isLayerModel, isRepeatModel, Model} from '../model';\nimport {Projection as VgProjection} from 'vega';\n\nexport function assembleProjections(model: Model): VgProjection[] {\n  if (isLayerModel(model) || isConcatModel(model) || isRepeatModel(model)) {\n    return assembleProjectionsForModelAndChildren(model);\n  } else {\n    return assembleProjectionForModel(model);\n  }\n}\n\nexport function assembleProjectionsForModelAndChildren(model: Model): VgProjection[] {\n  return model.children.reduce((projections, child) => {\n    return projections.concat(child.assembleProjections());\n  }, assembleProjectionForModel(model));\n}\n\nexport function assembleProjectionForModel(model: Model): VgProjection[] {\n  const component = model.component.projection;\n  if (!component || component.merged) {\n    return [];\n  }\n\n  const projection = component.combine();\n  const {name, ...rest} = projection; // we need to extract name so that it is always present in the output and pass TS type validation\n\n  if (!component.data) {\n    // generate custom projection, no automatic fitting\n    return [\n      {\n        name,\n        // translate to center by default\n        ...{translate: {signal: '[width / 2, height / 2]'}},\n        // parameters, overwrite default translate if specified\n        ...rest\n      }\n    ];\n  } else {\n    // generate projection that uses extent fitting\n    const size: SignalRef = {\n      signal: `[${component.size.map(ref => ref.signal).join(', ')}]`\n    };\n\n    const fit: string[] = component.data.reduce((sources, data) => {\n      const source: string = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;\n      if (!contains(sources, source)) {\n        // build a unique list of sources\n        sources.push(source);\n      }\n      return sources;\n    }, []);\n\n    if (fit.length <= 0) {\n      throw new Error(\"Projection's fit didn't find any data sources\");\n    }\n\n    return [\n      {\n        name,\n        size,\n        fit: {\n          signal: fit.length > 1 ? `[${fit.join(', ')}]` : fit[0]\n        },\n        ...rest\n      }\n    ];\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}