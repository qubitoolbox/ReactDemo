{"ast":null,"code":"import { groupkey } from './util/AggregateKeys';\nimport { createMeasure, compileMeasures, measureName, ValidAggregateOps } from './util/AggregateOps';\nimport TupleStore from './util/TupleStore';\nimport { ingest, replace, Transform } from 'vega-dataflow';\nimport { accessorFields, accessorName, array, error, inherits } from 'vega-util';\n/**\n * Group-by aggregation operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.\n * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.\n * @param {Array<string>} [params.as] - An array of output field names for aggregated values.\n * @param {boolean} [params.cross=false] - A flag indicating that the full\n *   cross-product of groupby values should be generated, including empty cells.\n *   If true, the drop parameter is ignored and empty cells are retained.\n * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.\n */\n\nexport default function Aggregate(params) {\n  Transform.call(this, null, params);\n  this._adds = []; // array of added output tuples\n\n  this._mods = []; // array of modified output tuples\n\n  this._alen = 0; // number of active added tuples\n\n  this._mlen = 0; // number of active modified tuples\n\n  this._drop = true; // should empty aggregation cells be removed\n\n  this._cross = false; // produce full cross-product of group-by values\n\n  this._dims = []; // group-by dimension accessors\n\n  this._dnames = []; // group-by dimension names\n\n  this._measures = []; // collection of aggregation monoids\n\n  this._countOnly = false; // flag indicating only count aggregation\n\n  this._counts = null; // collection of count fields\n\n  this._prev = null; // previous aggregation cells\n\n  this._inputs = null; // array of dependent input tuple field names\n\n  this._outputs = null; // array of output tuple field names\n}\nAggregate.Definition = {\n  \"type\": \"Aggregate\",\n  \"metadata\": {\n    \"generates\": true,\n    \"changes\": true\n  },\n  \"params\": [{\n    \"name\": \"groupby\",\n    \"type\": \"field\",\n    \"array\": true\n  }, {\n    \"name\": \"ops\",\n    \"type\": \"enum\",\n    \"array\": true,\n    \"values\": ValidAggregateOps\n  }, {\n    \"name\": \"fields\",\n    \"type\": \"field\",\n    \"null\": true,\n    \"array\": true\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"null\": true,\n    \"array\": true\n  }, {\n    \"name\": \"drop\",\n    \"type\": \"boolean\",\n    \"default\": true\n  }, {\n    \"name\": \"cross\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }, {\n    \"name\": \"key\",\n    \"type\": \"field\"\n  }]\n};\nvar prototype = inherits(Aggregate, Transform);\n\nprototype.transform = function (_, pulse) {\n  var aggr = this,\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      mod = _.modified();\n\n  aggr.stamp = out.stamp;\n\n  if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n    aggr._prev = aggr.value;\n    aggr.value = mod ? aggr.init(_) : {};\n    pulse.visit(pulse.SOURCE, t => aggr.add(t));\n  } else {\n    aggr.value = aggr.value || aggr.init(_);\n    pulse.visit(pulse.REM, t => aggr.rem(t));\n    pulse.visit(pulse.ADD, t => aggr.add(t));\n  } // Indicate output fields and return aggregate tuples.\n\n\n  out.modifies(aggr._outputs); // Should empty cells be dropped?\n\n  aggr._drop = _.drop !== false; // If domain cross-product requested, generate empty cells as needed\n  // and ensure that empty cells are not dropped\n\n  if (_.cross && aggr._dims.length > 1) {\n    aggr._drop = false;\n    aggr.cross();\n  }\n\n  return aggr.changes(out);\n};\n\nprototype.cross = function () {\n  var aggr = this,\n      curr = aggr.value,\n      dims = aggr._dnames,\n      vals = dims.map(function () {\n    return {};\n  }),\n      n = dims.length; // collect all group-by domain values\n\n  function collect(cells) {\n    var key, i, t, v;\n\n    for (key in cells) {\n      t = cells[key].tuple;\n\n      for (i = 0; i < n; ++i) {\n        vals[i][v = t[dims[i]]] = v;\n      }\n    }\n  }\n\n  collect(aggr._prev);\n  collect(curr); // iterate over key cross-product, create cells as needed\n\n  function generate(base, tuple, index) {\n    var name = dims[index],\n        v = vals[index++],\n        k,\n        key;\n\n    for (k in v) {\n      tuple[name] = v[k];\n      key = base ? base + '|' + k : k;\n      if (index < n) generate(key, tuple, index);else if (!curr[key]) aggr.cell(key, tuple);\n    }\n  }\n\n  generate('', {}, 0);\n};\n\nprototype.init = function (_) {\n  // initialize input and output fields\n  var inputs = this._inputs = [],\n      outputs = this._outputs = [],\n      inputMap = {};\n\n  function inputVisit(get) {\n    var fields = array(accessorFields(get)),\n        i = 0,\n        n = fields.length,\n        f;\n\n    for (; i < n; ++i) {\n      if (!inputMap[f = fields[i]]) {\n        inputMap[f] = 1;\n        inputs.push(f);\n      }\n    }\n  } // initialize group-by dimensions\n\n\n  this._dims = array(_.groupby);\n  this._dnames = this._dims.map(function (d) {\n    var dname = accessorName(d);\n    inputVisit(d);\n    outputs.push(dname);\n    return dname;\n  });\n  this.cellkey = _.key ? _.key : groupkey(this._dims); // initialize aggregate measures\n\n  this._countOnly = true;\n  this._counts = [];\n  this._measures = [];\n  var fields = _.fields || [null],\n      ops = _.ops || ['count'],\n      as = _.as || [],\n      n = fields.length,\n      map = {},\n      field,\n      op,\n      m,\n      mname,\n      outname,\n      i;\n\n  if (n !== ops.length) {\n    error('Unmatched number of fields and aggregate ops.');\n  }\n\n  for (i = 0; i < n; ++i) {\n    field = fields[i];\n    op = ops[i];\n\n    if (field == null && op !== 'count') {\n      error('Null aggregate field specified.');\n    }\n\n    mname = accessorName(field);\n    outname = measureName(op, mname, as[i]);\n    outputs.push(outname);\n\n    if (op === 'count') {\n      this._counts.push(outname);\n\n      continue;\n    }\n\n    m = map[mname];\n\n    if (!m) {\n      inputVisit(field);\n      m = map[mname] = [];\n      m.field = field;\n\n      this._measures.push(m);\n    }\n\n    if (op !== 'count') this._countOnly = false;\n    m.push(createMeasure(op, outname));\n  }\n\n  this._measures = this._measures.map(function (m) {\n    return compileMeasures(m, m.field);\n  });\n  return {}; // aggregation cells (this.value)\n}; // -- Cell Management -----\n\n\nprototype.cellkey = groupkey();\n\nprototype.cell = function (key, t) {\n  var cell = this.value[key];\n\n  if (!cell) {\n    cell = this.value[key] = this.newcell(key, t);\n    this._adds[this._alen++] = cell;\n  } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {\n    cell.stamp = this.stamp;\n    this._adds[this._alen++] = cell;\n  } else if (cell.stamp < this.stamp) {\n    cell.stamp = this.stamp;\n    this._mods[this._mlen++] = cell;\n  }\n\n  return cell;\n};\n\nprototype.newcell = function (key, t) {\n  var cell = {\n    key: key,\n    num: 0,\n    agg: null,\n    tuple: this.newtuple(t, this._prev && this._prev[key]),\n    stamp: this.stamp,\n    store: false\n  };\n\n  if (!this._countOnly) {\n    var measures = this._measures,\n        n = measures.length,\n        i;\n    cell.agg = Array(n);\n\n    for (i = 0; i < n; ++i) {\n      cell.agg[i] = new measures[i](cell);\n    }\n  }\n\n  if (cell.store) {\n    cell.data = new TupleStore();\n  }\n\n  return cell;\n};\n\nprototype.newtuple = function (t, p) {\n  var names = this._dnames,\n      dims = this._dims,\n      x = {},\n      i,\n      n;\n\n  for (i = 0, n = dims.length; i < n; ++i) {\n    x[names[i]] = dims[i](t);\n  }\n\n  return p ? replace(p.tuple, x) : ingest(x);\n}; // -- Process Tuples -----\n\n\nprototype.add = function (t) {\n  var key = this.cellkey(t),\n      cell = this.cell(key, t),\n      agg,\n      i,\n      n;\n  cell.num += 1;\n  if (this._countOnly) return;\n  if (cell.store) cell.data.add(t);\n  agg = cell.agg;\n\n  for (i = 0, n = agg.length; i < n; ++i) {\n    agg[i].add(agg[i].get(t), t);\n  }\n};\n\nprototype.rem = function (t) {\n  var key = this.cellkey(t),\n      cell = this.cell(key, t),\n      agg,\n      i,\n      n;\n  cell.num -= 1;\n  if (this._countOnly) return;\n  if (cell.store) cell.data.rem(t);\n  agg = cell.agg;\n\n  for (i = 0, n = agg.length; i < n; ++i) {\n    agg[i].rem(agg[i].get(t), t);\n  }\n};\n\nprototype.celltuple = function (cell) {\n  var tuple = cell.tuple,\n      counts = this._counts,\n      agg,\n      i,\n      n; // consolidate stored values\n\n  if (cell.store) {\n    cell.data.values();\n  } // update tuple properties\n\n\n  for (i = 0, n = counts.length; i < n; ++i) {\n    tuple[counts[i]] = cell.num;\n  }\n\n  if (!this._countOnly) {\n    agg = cell.agg;\n\n    for (i = 0, n = agg.length; i < n; ++i) {\n      agg[i].set(tuple);\n    }\n  }\n\n  return tuple;\n};\n\nprototype.changes = function (out) {\n  var adds = this._adds,\n      mods = this._mods,\n      prev = this._prev,\n      drop = this._drop,\n      add = out.add,\n      rem = out.rem,\n      mod = out.mod,\n      cell,\n      key,\n      i,\n      n;\n  if (prev) for (key in prev) {\n    cell = prev[key];\n    if (!drop || cell.num) rem.push(cell.tuple);\n  }\n\n  for (i = 0, n = this._alen; i < n; ++i) {\n    add.push(this.celltuple(adds[i]));\n    adds[i] = null; // for garbage collection\n  }\n\n  for (i = 0, n = this._mlen; i < n; ++i) {\n    cell = mods[i];\n    (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));\n    mods[i] = null; // for garbage collection\n  }\n\n  this._alen = this._mlen = 0; // reset list of active cells\n\n  this._prev = null;\n  return out;\n};","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-transforms/src/Aggregate.js"],"names":["groupkey","createMeasure","compileMeasures","measureName","ValidAggregateOps","TupleStore","ingest","replace","Transform","accessorFields","accessorName","array","error","inherits","Aggregate","params","call","_adds","_mods","_alen","_mlen","_drop","_cross","_dims","_dnames","_measures","_countOnly","_counts","_prev","_inputs","_outputs","Definition","prototype","transform","_","pulse","aggr","out","fork","NO_SOURCE","NO_FIELDS","mod","modified","stamp","value","init","visit","SOURCE","t","add","REM","rem","ADD","modifies","drop","cross","length","changes","curr","dims","vals","map","n","collect","cells","key","i","v","tuple","generate","base","index","name","k","cell","inputs","outputs","inputMap","inputVisit","get","fields","f","push","groupby","d","dname","cellkey","ops","as","field","op","m","mname","outname","newcell","num","agg","newtuple","store","measures","Array","data","p","names","x","celltuple","counts","values","set","adds","mods","prev"],"mappings":"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","sourcesContent":["import {groupkey} from './util/AggregateKeys';\nimport {createMeasure, compileMeasures, measureName, ValidAggregateOps} from './util/AggregateOps';\nimport TupleStore from './util/TupleStore';\nimport {ingest, replace, Transform} from 'vega-dataflow';\nimport {accessorFields, accessorName, array, error, inherits} from 'vega-util';\n\n/**\n * Group-by aggregation operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.\n * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.\n * @param {Array<string>} [params.as] - An array of output field names for aggregated values.\n * @param {boolean} [params.cross=false] - A flag indicating that the full\n *   cross-product of groupby values should be generated, including empty cells.\n *   If true, the drop parameter is ignored and empty cells are retained.\n * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.\n */\nexport default function Aggregate(params) {\n  Transform.call(this, null, params);\n\n  this._adds = []; // array of added output tuples\n  this._mods = []; // array of modified output tuples\n  this._alen = 0;  // number of active added tuples\n  this._mlen = 0;  // number of active modified tuples\n  this._drop = true;   // should empty aggregation cells be removed\n  this._cross = false; // produce full cross-product of group-by values\n\n  this._dims = [];   // group-by dimension accessors\n  this._dnames = []; // group-by dimension names\n\n  this._measures = []; // collection of aggregation monoids\n  this._countOnly = false; // flag indicating only count aggregation\n  this._counts = null; // collection of count fields\n  this._prev = null;   // previous aggregation cells\n\n  this._inputs = null;  // array of dependent input tuple field names\n  this._outputs = null; // array of output tuple field names\n}\n\nAggregate.Definition = {\n  \"type\": \"Aggregate\",\n  \"metadata\": {\"generates\": true, \"changes\": true},\n  \"params\": [\n    { \"name\": \"groupby\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"ops\", \"type\": \"enum\", \"array\": true, \"values\": ValidAggregateOps },\n    { \"name\": \"fields\", \"type\": \"field\", \"null\": true, \"array\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"null\": true, \"array\": true },\n    { \"name\": \"drop\", \"type\": \"boolean\", \"default\": true },\n    { \"name\": \"cross\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"key\", \"type\": \"field\" }\n  ]\n};\n\nvar prototype = inherits(Aggregate, Transform);\n\nprototype.transform = function(_, pulse) {\n  var aggr = this,\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      mod = _.modified();\n\n  aggr.stamp = out.stamp;\n\n  if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n    aggr._prev = aggr.value;\n    aggr.value = mod ? aggr.init(_) : {};\n    pulse.visit(pulse.SOURCE, t => aggr.add(t));\n  } else {\n    aggr.value = aggr.value || aggr.init(_);\n    pulse.visit(pulse.REM, t => aggr.rem(t));\n    pulse.visit(pulse.ADD, t => aggr.add(t));\n  }\n\n  // Indicate output fields and return aggregate tuples.\n  out.modifies(aggr._outputs);\n\n  // Should empty cells be dropped?\n  aggr._drop = _.drop !== false;\n\n  // If domain cross-product requested, generate empty cells as needed\n  // and ensure that empty cells are not dropped\n  if (_.cross && aggr._dims.length > 1) {\n    aggr._drop = false;\n    aggr.cross();\n  }\n\n  return aggr.changes(out);\n};\n\nprototype.cross = function() {\n  var aggr = this,\n      curr = aggr.value,\n      dims = aggr._dnames,\n      vals = dims.map(function() { return {}; }),\n      n = dims.length;\n\n  // collect all group-by domain values\n  function collect(cells) {\n    var key, i, t, v;\n    for (key in cells) {\n      t = cells[key].tuple;\n      for (i=0; i<n; ++i) {\n        vals[i][(v = t[dims[i]])] = v;\n      }\n    }\n  }\n  collect(aggr._prev);\n  collect(curr);\n\n  // iterate over key cross-product, create cells as needed\n  function generate(base, tuple, index) {\n    var name = dims[index],\n        v = vals[index++],\n        k, key;\n\n    for (k in v) {\n      tuple[name] = v[k];\n      key = base ? base + '|' + k : k;\n      if (index < n) generate(key, tuple, index);\n      else if (!curr[key]) aggr.cell(key, tuple);\n    }\n  }\n  generate('', {}, 0);\n};\n\nprototype.init = function(_) {\n  // initialize input and output fields\n  var inputs = (this._inputs = []),\n      outputs = (this._outputs = []),\n      inputMap = {};\n\n  function inputVisit(get) {\n    var fields = array(accessorFields(get)),\n        i = 0, n = fields.length, f;\n    for (; i<n; ++i) {\n      if (!inputMap[f=fields[i]]) {\n        inputMap[f] = 1;\n        inputs.push(f);\n      }\n    }\n  }\n\n  // initialize group-by dimensions\n  this._dims = array(_.groupby);\n  this._dnames = this._dims.map(function(d) {\n    var dname = accessorName(d);\n    inputVisit(d);\n    outputs.push(dname);\n    return dname;\n  });\n  this.cellkey = _.key ? _.key : groupkey(this._dims);\n\n  // initialize aggregate measures\n  this._countOnly = true;\n  this._counts = [];\n  this._measures = [];\n\n  var fields = _.fields || [null],\n      ops = _.ops || ['count'],\n      as = _.as || [],\n      n = fields.length,\n      map = {},\n      field, op, m, mname, outname, i;\n\n  if (n !== ops.length) {\n    error('Unmatched number of fields and aggregate ops.');\n  }\n\n  for (i=0; i<n; ++i) {\n    field = fields[i];\n    op = ops[i];\n\n    if (field == null && op !== 'count') {\n      error('Null aggregate field specified.');\n    }\n    mname = accessorName(field);\n    outname = measureName(op, mname, as[i]);\n    outputs.push(outname);\n\n    if (op === 'count') {\n      this._counts.push(outname);\n      continue;\n    }\n\n    m = map[mname];\n    if (!m) {\n      inputVisit(field);\n      m = (map[mname] = []);\n      m.field = field;\n      this._measures.push(m);\n    }\n\n    if (op !== 'count') this._countOnly = false;\n    m.push(createMeasure(op, outname));\n  }\n\n  this._measures = this._measures.map(function(m) {\n    return compileMeasures(m, m.field);\n  });\n\n  return {}; // aggregation cells (this.value)\n};\n\n// -- Cell Management -----\n\nprototype.cellkey = groupkey();\n\nprototype.cell = function(key, t) {\n  var cell = this.value[key];\n  if (!cell) {\n    cell = this.value[key] = this.newcell(key, t);\n    this._adds[this._alen++] = cell;\n  } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {\n    cell.stamp = this.stamp;\n    this._adds[this._alen++] = cell;\n  } else if (cell.stamp < this.stamp) {\n    cell.stamp = this.stamp;\n    this._mods[this._mlen++] = cell;\n  }\n  return cell;\n};\n\nprototype.newcell = function(key, t) {\n  var cell = {\n    key:   key,\n    num:   0,\n    agg:   null,\n    tuple: this.newtuple(t, this._prev && this._prev[key]),\n    stamp: this.stamp,\n    store: false\n  };\n\n  if (!this._countOnly) {\n    var measures = this._measures,\n        n = measures.length, i;\n\n    cell.agg = Array(n);\n    for (i=0; i<n; ++i) {\n      cell.agg[i] = new measures[i](cell);\n    }\n  }\n\n  if (cell.store) {\n    cell.data = new TupleStore();\n  }\n\n  return cell;\n};\n\nprototype.newtuple = function(t, p) {\n  var names = this._dnames,\n      dims = this._dims,\n      x = {}, i, n;\n\n  for (i=0, n=dims.length; i<n; ++i) {\n    x[names[i]] = dims[i](t);\n  }\n\n  return p ? replace(p.tuple, x) : ingest(x);\n};\n\n// -- Process Tuples -----\n\nprototype.add = function(t) {\n  var key = this.cellkey(t),\n      cell = this.cell(key, t),\n      agg, i, n;\n\n  cell.num += 1;\n  if (this._countOnly) return;\n\n  if (cell.store) cell.data.add(t);\n\n  agg = cell.agg;\n  for (i=0, n=agg.length; i<n; ++i) {\n    agg[i].add(agg[i].get(t), t);\n  }\n};\n\nprototype.rem = function(t) {\n  var key = this.cellkey(t),\n      cell = this.cell(key, t),\n      agg, i, n;\n\n  cell.num -= 1;\n  if (this._countOnly) return;\n\n  if (cell.store) cell.data.rem(t);\n\n  agg = cell.agg;\n  for (i=0, n=agg.length; i<n; ++i) {\n    agg[i].rem(agg[i].get(t), t);\n  }\n};\n\nprototype.celltuple = function(cell) {\n  var tuple = cell.tuple,\n      counts = this._counts,\n      agg, i, n;\n\n  // consolidate stored values\n  if (cell.store) {\n    cell.data.values();\n  }\n\n  // update tuple properties\n  for (i=0, n=counts.length; i<n; ++i) {\n    tuple[counts[i]] = cell.num;\n  }\n  if (!this._countOnly) {\n    agg = cell.agg;\n    for (i=0, n=agg.length; i<n; ++i) {\n      agg[i].set(tuple);\n    }\n  }\n\n  return tuple;\n};\n\nprototype.changes = function(out) {\n  var adds = this._adds,\n      mods = this._mods,\n      prev = this._prev,\n      drop = this._drop,\n      add = out.add,\n      rem = out.rem,\n      mod = out.mod,\n      cell, key, i, n;\n\n  if (prev) for (key in prev) {\n    cell = prev[key];\n    if (!drop || cell.num) rem.push(cell.tuple);\n  }\n\n  for (i=0, n=this._alen; i<n; ++i) {\n    add.push(this.celltuple(adds[i]));\n    adds[i] = null; // for garbage collection\n  }\n\n  for (i=0, n=this._mlen; i<n; ++i) {\n    cell = mods[i];\n    (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));\n    mods[i] = null; // for garbage collection\n  }\n\n  this._alen = this._mlen = 0; // reset list of active cells\n  this._prev = null;\n  return out;\n};\n"]},"metadata":{},"sourceType":"module"}