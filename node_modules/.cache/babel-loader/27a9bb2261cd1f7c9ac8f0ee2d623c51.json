{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isFieldDef, isValueDef, vgField } from '../../channeldef';\nimport { MAIN } from '../../data';\nimport { isAggregate, pathGroupingFields } from '../../encoding';\nimport { AREA, BAR, isPathMark, LINE, TRAIL } from '../../mark';\nimport { isSortByEncoding, isSortField } from '../../sort';\nimport { contains, getFirstDefined, isNullOrFalse, keys, omit, pick } from '../../util';\nimport { VG_CORNERRADIUS_CHANNELS } from '../../vega.schema';\nimport { getMarkConfig, getStyles, sortParams } from '../common';\nimport { area } from './area';\nimport { bar } from './bar';\nimport { geoshape } from './geoshape';\nimport { image } from './image';\nimport { line, trail } from './line';\nimport { circle, point, square } from './point';\nimport { rect } from './rect';\nimport { rule } from './rule';\nimport { text } from './text';\nimport { tick } from './tick';\nconst markCompiler = {\n  area,\n  bar,\n  circle,\n  geoshape,\n  image,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\nexport function parseMarkGroups(model) {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    return parsePathMark(model);\n  } else if (contains([BAR], model.mark)) {\n    return getStackGroups(model);\n  } else {\n    return getMarkGroups(model);\n  }\n}\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model) {\n  const details = pathGroupingFields(model.mark, model.encoding);\n  const pathMarks = getMarkGroups(model, {\n    // If has subfacet for line/area group, need to use faceted data from below.\n    fromPrefix: details.length > 0 ? FACETED_PATH_PREFIX : ''\n  });\n\n  if (details.length > 0) {\n    // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n    return [{\n      name: model.getName('pathgroup'),\n      type: 'group',\n      from: {\n        facet: {\n          name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n          data: model.requestDataName(MAIN),\n          groupby: details\n        }\n      },\n      encode: {\n        update: {\n          width: {\n            field: {\n              group: 'width'\n            }\n          },\n          height: {\n            field: {\n              group: 'height'\n            }\n          }\n        }\n      },\n      marks: pathMarks\n    }];\n  } else {\n    return pathMarks;\n  }\n}\n\nconst STACK_GROUP_PREFIX = 'stack_group_';\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\n\nfunction getStackGroups(model) {\n  var _a; // Don't use nested groups when cornerRadius is not specified, or specified as 0\n\n\n  const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(prop => model.markDef[prop] || getMarkConfig(prop, model.markDef, model.config)); // Activate groups if stack is used and the model doesn't have size encoding\n\n  if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n    // Generate the mark\n    const [mark] = getMarkGroups(model, {\n      fromPrefix: STACK_GROUP_PREFIX\n    }); // Get the scale for the stacked field\n\n    const fieldScale = model.scaleName(model.stack.fieldChannel);\n\n    const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt); // Find the min/max of the pixel value on the stacked direction\n\n\n    const stackFieldGroup = (func, expr) => {\n      const vgFieldMinMax = [stackField({\n        prefix: 'min',\n        suffix: 'start',\n        expr\n      }), stackField({\n        prefix: 'max',\n        suffix: 'start',\n        expr\n      }), stackField({\n        prefix: 'min',\n        suffix: 'end',\n        expr\n      }), stackField({\n        prefix: 'max',\n        suffix: 'end',\n        expr\n      })];\n      return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n    };\n\n    let groupUpdate;\n    let innerGroupUpdate; // Build the encoding for group and an inner group\n\n    if (model.stack.fieldChannel === 'x') {\n      // Move cornerRadius, y/yc/y2/height properties to group\n      // Group x/x2 should be the min/max of the marks within\n      groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS])), {\n        x: {\n          signal: stackFieldGroup('min', 'datum')\n        },\n        x2: {\n          signal: stackFieldGroup('max', 'datum')\n        },\n        clip: {\n          value: true\n        }\n      }); // Inner group should revert the x translation, and pass height through\n\n      innerGroupUpdate = {\n        x: {\n          field: {\n            group: 'x'\n          },\n          mult: -1\n        },\n        height: {\n          field: {\n            group: 'height'\n          }\n        }\n      }; // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n      // This is why size encoding is not supported yet\n\n      mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['y', 'yc', 'y2'])), {\n        height: {\n          field: {\n            group: 'height'\n          }\n        }\n      });\n    } else {\n      groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['x', 'xc', 'x2', 'width'])), {\n        y: {\n          signal: stackFieldGroup('min', 'datum')\n        },\n        y2: {\n          signal: stackFieldGroup('max', 'datum')\n        },\n        clip: {\n          value: true\n        }\n      });\n      innerGroupUpdate = {\n        y: {\n          field: {\n            group: 'y'\n          },\n          mult: -1\n        },\n        width: {\n          field: {\n            group: 'width'\n          }\n        }\n      };\n      mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['x', 'xc', 'x2'])), {\n        width: {\n          field: {\n            group: 'width'\n          }\n        }\n      });\n    } // Deal with cornerRadius properties\n\n\n    for (const key of VG_CORNERRADIUS_CHANNELS) {\n      const configValue = getMarkConfig(key, model.markDef, model.config); // Move from mark to group\n\n      if (mark.encode.update[key]) {\n        groupUpdate[key] = mark.encode.update[key];\n        delete mark.encode.update[key];\n      } else if (configValue) {\n        groupUpdate[key] = {\n          value: configValue\n        };\n      } // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n\n\n      if (configValue) {\n        mark.encode.update[key] = {\n          value: 0\n        };\n      }\n    } // For bin we have to add bin channels.\n\n\n    const groupby = model.vgField(model.stack.groupbyChannel) ? [model.vgField(model.stack.groupbyChannel)] : [];\n\n    if ((_a = model.fieldDef(model.stack.groupbyChannel)) === null || _a === void 0 ? void 0 : _a.bin) {\n      groupby.push(model.vgField(model.stack.groupbyChannel, {\n        binSuffix: 'end'\n      }));\n    }\n\n    const strokeProperties = ['stroke', 'strokeWidth', 'strokeJoin', 'strokeCap', 'strokeDash', 'strokeDashOffset', 'strokeMiterLimit', 'strokeOpacity']; // Generate stroke properties for the group\n\n    groupUpdate = strokeProperties.reduce((encode, prop) => {\n      if (mark.encode.update[prop]) {\n        return Object.assign(Object.assign({}, encode), {\n          [prop]: mark.encode.update[prop]\n        });\n      } else {\n        const configValue = getMarkConfig(prop, model.markDef, model.config);\n\n        if (configValue !== undefined) {\n          return Object.assign(Object.assign({}, encode), {\n            [prop]: {\n              value: configValue\n            }\n          });\n        } else {\n          return encode;\n        }\n      }\n    }, groupUpdate); // Apply strokeForeground and strokeOffset if stroke is used\n\n    if (groupUpdate.stroke) {\n      groupUpdate.strokeForeground = {\n        value: true\n      };\n      groupUpdate.strokeOffset = {\n        value: 0\n      };\n    }\n\n    return [{\n      type: 'group',\n      from: {\n        facet: {\n          data: model.requestDataName(MAIN),\n          name: STACK_GROUP_PREFIX + model.requestDataName(MAIN),\n          groupby,\n          aggregate: {\n            fields: [stackField({\n              suffix: 'start'\n            }), stackField({\n              suffix: 'start'\n            }), stackField({\n              suffix: 'end'\n            }), stackField({\n              suffix: 'end'\n            })],\n            ops: ['min', 'max', 'min', 'max']\n          }\n        }\n      },\n      encode: {\n        update: groupUpdate\n      },\n      marks: [{\n        type: 'group',\n        encode: {\n          update: innerGroupUpdate\n        },\n        marks: [mark]\n      }]\n    }];\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nexport function getSort(model) {\n  const {\n    encoding,\n    stack,\n    mark,\n    markDef,\n    config\n  } = model;\n  const order = encoding.order;\n\n  if (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(markDef.order) || isNullOrFalse(getMarkConfig('order', markDef, config))) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {\n      expr: 'datum'\n    });\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    const dimensionChannelDef = encoding[dimensionChannel];\n\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {\n            prefix: dimensionChannel,\n            suffix: 'sort_index',\n            expr: 'datum'\n          })\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField({\n            // FIXME: this op might not already exist?\n            // FIXME: what if dimensionChannel (x or y) contains custom domain?\n            aggregate: isAggregate(model.encoding) ? s.op : undefined,\n            field: s.field\n          }, {\n            expr: 'datum'\n          })\n        };\n      } else if (isSortByEncoding(s)) {\n        const fieldDefToSort = model.fieldDef(s.encoding);\n        return {\n          field: vgField(fieldDefToSort, {\n            expr: 'datum'\n          }),\n          order: s.order\n        };\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n\n    return undefined;\n  }\n\n  return undefined;\n}\n\nfunction getMarkGroups(model, opt = {\n  fromPrefix: ''\n}) {\n  const mark = model.mark;\n  const clip = getFirstDefined(model.markDef.clip, scaleClip(model), projectionClip(model));\n  const style = getStyles(model.markDef);\n  const key = model.encoding.key;\n  const sort = getSort(model);\n  const interactive = interactiveFlag(model);\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n  return [Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark\n  }, clip ? {\n    clip: true\n  } : {}), style ? {\n    style\n  } : {}), key ? {\n    key: key.field\n  } : {}), sort ? {\n    sort\n  } : {}), interactive ? interactive : {}), {\n    from: {\n      data: opt.fromPrefix + model.requestDataName(MAIN)\n    },\n    encode: {\n      update: markCompiler[mark].encodeEntry(model)\n    }\n  }), postEncodingTransform ? {\n    transform: postEncodingTransform\n  } : {})];\n}\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\n\n\nfunction scaleClip(model) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return xScale && xScale.get('selectionExtent') || yScale && yScale.get('selectionExtent') ? true : undefined;\n}\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\n\n\nfunction projectionClip(model) {\n  const projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\n\n\nfunction interactiveFlag(model) {\n  if (!model.component.selection) return null;\n  const unitCount = keys(model.component.selection).length;\n  let parentCount = unitCount;\n  let parent = model.parent;\n\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n\n  return parentCount ? {\n    interactive: unitCount > 0\n  } : null;\n}","map":{"version":3,"sources":["../../../../src/compile/mark/mark.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {FieldRefOption, isFieldDef, isValueDef, vgField} from '../../channeldef';\nimport {MAIN} from '../../data';\nimport {isAggregate, pathGroupingFields} from '../../encoding';\nimport {AREA, BAR, isPathMark, LINE, Mark, TRAIL} from '../../mark';\nimport {isSortByEncoding, isSortField} from '../../sort';\nimport {contains, getFirstDefined, isNullOrFalse, keys, omit, pick} from '../../util';\nimport {VgCompare, VgEncodeEntry, VG_CORNERRADIUS_CHANNELS} from '../../vega.schema';\nimport {getMarkConfig, getStyles, sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {MarkCompiler} from './base';\nimport {geoshape} from './geoshape';\nimport {image} from './image';\nimport {line, trail} from './line';\nimport {circle, point, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\nconst markCompiler: {[m in Mark]: MarkCompiler} = {\n  area,\n  bar,\n  circle,\n  geoshape,\n  image,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\n\nexport function parseMarkGroups(model: UnitModel): any[] {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    return parsePathMark(model);\n  } else if (contains([BAR], model.mark)) {\n    return getStackGroups(model);\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model: UnitModel) {\n  const details = pathGroupingFields(model.mark, model.encoding);\n\n  const pathMarks = getMarkGroups(model, {\n    // If has subfacet for line/area group, need to use faceted data from below.\n    fromPrefix: details.length > 0 ? FACETED_PATH_PREFIX : ''\n  });\n\n  if (details.length > 0) {\n    // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n    return [\n      {\n        name: model.getName('pathgroup'),\n        type: 'group',\n        from: {\n          facet: {\n            name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n            data: model.requestDataName(MAIN),\n            groupby: details\n          }\n        },\n        encode: {\n          update: {\n            width: {field: {group: 'width'}},\n            height: {field: {group: 'height'}}\n          }\n        },\n        marks: pathMarks\n      }\n    ];\n  } else {\n    return pathMarks;\n  }\n}\n\nconst STACK_GROUP_PREFIX = 'stack_group_';\n\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\nfunction getStackGroups(model: UnitModel) {\n  // Don't use nested groups when cornerRadius is not specified, or specified as 0\n  const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(\n    prop => model.markDef[prop] || getMarkConfig(prop, model.markDef, model.config)\n  );\n\n  // Activate groups if stack is used and the model doesn't have size encoding\n  if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n    // Generate the mark\n    const [mark] = getMarkGroups(model, {fromPrefix: STACK_GROUP_PREFIX});\n\n    // Get the scale for the stacked field\n    const fieldScale = model.scaleName(model.stack.fieldChannel);\n    const stackField = (opt: FieldRefOption = {}) => model.vgField(model.stack.fieldChannel, opt);\n    // Find the min/max of the pixel value on the stacked direction\n    const stackFieldGroup = (func: 'min' | 'max', expr: 'datum' | 'parent') => {\n      const vgFieldMinMax = [\n        stackField({prefix: 'min', suffix: 'start', expr}),\n        stackField({prefix: 'max', suffix: 'start', expr}),\n        stackField({prefix: 'min', suffix: 'end', expr}),\n        stackField({prefix: 'max', suffix: 'end', expr})\n      ];\n      return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n    };\n\n    let groupUpdate: VgEncodeEntry;\n    let innerGroupUpdate: VgEncodeEntry;\n\n    // Build the encoding for group and an inner group\n    if (model.stack.fieldChannel === 'x') {\n      // Move cornerRadius, y/yc/y2/height properties to group\n      // Group x/x2 should be the min/max of the marks within\n      groupUpdate = {\n        ...pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS]),\n        x: {signal: stackFieldGroup('min', 'datum')},\n        x2: {signal: stackFieldGroup('max', 'datum')},\n        clip: {value: true}\n      };\n      // Inner group should revert the x translation, and pass height through\n      innerGroupUpdate = {\n        x: {field: {group: 'x'}, mult: -1},\n        height: {field: {group: 'height'}}\n      };\n      // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n      // This is why size encoding is not supported yet\n      mark.encode.update = {\n        ...omit(mark.encode.update, ['y', 'yc', 'y2']),\n        height: {field: {group: 'height'}}\n      };\n    } else {\n      groupUpdate = {\n        ...pick(mark.encode.update, ['x', 'xc', 'x2', 'width']),\n        y: {signal: stackFieldGroup('min', 'datum')},\n        y2: {signal: stackFieldGroup('max', 'datum')},\n        clip: {value: true}\n      };\n      innerGroupUpdate = {\n        y: {field: {group: 'y'}, mult: -1},\n        width: {field: {group: 'width'}}\n      };\n      mark.encode.update = {\n        ...omit(mark.encode.update, ['x', 'xc', 'x2']),\n        width: {field: {group: 'width'}}\n      };\n    }\n\n    // Deal with cornerRadius properties\n    for (const key of VG_CORNERRADIUS_CHANNELS) {\n      const configValue = getMarkConfig(key, model.markDef, model.config);\n      // Move from mark to group\n      if (mark.encode.update[key]) {\n        groupUpdate[key] = mark.encode.update[key];\n        delete mark.encode.update[key];\n      } else if (configValue) {\n        groupUpdate[key] = {value: configValue};\n      }\n      // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n      if (configValue) {\n        mark.encode.update[key] = {value: 0};\n      }\n    }\n\n    // For bin we have to add bin channels.\n    const groupby: string[] = model.vgField(model.stack.groupbyChannel)\n      ? [model.vgField(model.stack.groupbyChannel)]\n      : [];\n    if (model.fieldDef(model.stack.groupbyChannel)?.bin) {\n      groupby.push(model.vgField(model.stack.groupbyChannel, {binSuffix: 'end'}));\n    }\n\n    const strokeProperties = [\n      'stroke',\n      'strokeWidth',\n      'strokeJoin',\n      'strokeCap',\n      'strokeDash',\n      'strokeDashOffset',\n      'strokeMiterLimit',\n      'strokeOpacity'\n    ] as const;\n\n    // Generate stroke properties for the group\n    groupUpdate = strokeProperties.reduce((encode, prop) => {\n      if (mark.encode.update[prop]) {\n        return {...encode, [prop]: mark.encode.update[prop]};\n      } else {\n        const configValue = getMarkConfig(prop, model.markDef, model.config);\n        if (configValue !== undefined) {\n          return {...encode, [prop]: {value: configValue}};\n        } else {\n          return encode;\n        }\n      }\n    }, groupUpdate);\n\n    // Apply strokeForeground and strokeOffset if stroke is used\n    if (groupUpdate.stroke) {\n      groupUpdate.strokeForeground = {value: true};\n      groupUpdate.strokeOffset = {value: 0};\n    }\n\n    return [\n      {\n        type: 'group',\n        from: {\n          facet: {\n            data: model.requestDataName(MAIN),\n            name: STACK_GROUP_PREFIX + model.requestDataName(MAIN),\n            groupby,\n            aggregate: {\n              fields: [\n                stackField({suffix: 'start'}),\n                stackField({suffix: 'start'}),\n                stackField({suffix: 'end'}),\n                stackField({suffix: 'end'})\n              ],\n              ops: ['min', 'max', 'min', 'max']\n            }\n          }\n        },\n        encode: {\n          update: groupUpdate\n        },\n        marks: [\n          {\n            type: 'group',\n            encode: {update: innerGroupUpdate},\n            marks: [mark]\n          }\n        ]\n      }\n    ];\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nexport function getSort(model: UnitModel): VgCompare {\n  const {encoding, stack, mark, markDef, config} = model;\n  const order = encoding.order;\n  if (\n    (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value)) ||\n    (!order && isNullOrFalse(markDef.order)) ||\n    isNullOrFalse(getMarkConfig('order', markDef, config))\n  ) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {expr: 'datum'});\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    const dimensionChannelDef = encoding[dimensionChannel];\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {prefix: dimensionChannel, suffix: 'sort_index', expr: 'datum'})\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField(\n            {\n              // FIXME: this op might not already exist?\n              // FIXME: what if dimensionChannel (x or y) contains custom domain?\n              aggregate: isAggregate(model.encoding) ? s.op : undefined,\n              field: s.field\n            },\n            {expr: 'datum'}\n          )\n        };\n      } else if (isSortByEncoding(s)) {\n        const fieldDefToSort = model.fieldDef(s.encoding);\n        return {\n          field: vgField(fieldDefToSort, {expr: 'datum'}),\n          order: s.order\n        };\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n    return undefined;\n  }\n  return undefined;\n}\n\nfunction getMarkGroups(\n  model: UnitModel,\n  opt: {\n    fromPrefix: string;\n  } = {fromPrefix: ''}\n) {\n  const mark = model.mark;\n\n  const clip = getFirstDefined(model.markDef.clip, scaleClip(model), projectionClip(model));\n  const style = getStyles(model.markDef);\n  const key = model.encoding.key;\n  const sort = getSort(model);\n  const interactive = interactiveFlag(model);\n\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform\n    ? markCompiler[mark].postEncodingTransform(model)\n    : null;\n\n  return [\n    {\n      name: model.getName('marks'),\n      type: markCompiler[mark].vgMark,\n      ...(clip ? {clip: true} : {}),\n      ...(style ? {style} : {}),\n      ...(key ? {key: key.field} : {}),\n      ...(sort ? {sort} : {}),\n      ...(interactive ? interactive : {}),\n      from: {data: opt.fromPrefix + model.requestDataName(MAIN)},\n      encode: {\n        update: markCompiler[mark].encodeEntry(model)\n      },\n      ...(postEncodingTransform\n        ? {\n            transform: postEncodingTransform\n          }\n        : {})\n    }\n  ];\n}\n\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\nfunction scaleClip(model: UnitModel) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return (xScale && xScale.get('selectionExtent')) || (yScale && yScale.get('selectionExtent')) ? true : undefined;\n}\n\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\nfunction projectionClip(model: UnitModel) {\n  const projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\nfunction interactiveFlag(model: UnitModel) {\n  if (!model.component.selection) return null;\n  const unitCount = keys(model.component.selection).length;\n  let parentCount = unitCount;\n  let parent = model.parent;\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n  return parentCount ? {interactive: unitCount > 0} : null;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}