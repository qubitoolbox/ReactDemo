{"ast":null,"code":"import { isBinning } from '../../bin';\nimport { X, Y } from '../../channel';\nimport { isDiscrete, valueArray } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { NOMINAL, ORDINAL } from '../../type';\nimport { contains, normalizeAngle } from '../../util';\nimport { getAxisConfig } from './config'; // TODO: we need to refactor this method after we take care of config refactoring\n\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\n\nexport function defaultGrid(scaleType, fieldDef) {\n  return !hasDiscreteDomain(scaleType) && !isBinning(fieldDef.bin);\n}\nexport function gridScale(model, channel) {\n  const gridChannel = channel === 'x' ? 'y' : 'x';\n\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n\n  return undefined;\n}\nexport function labelAngle(model, specifiedAxis, channel, fieldDef) {\n  // try axis value\n  if (specifiedAxis.labelAngle !== undefined) {\n    return normalizeAngle(specifiedAxis.labelAngle);\n  } else {\n    // try axis config value\n    const angle = getAxisConfig('labelAngle', model.config, channel, orient(channel), model.getScaleComponent(channel).get('type'));\n\n    if (angle !== undefined) {\n      return normalizeAngle(angle);\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldDef.type)) {\n        return 270;\n      } // no default\n\n\n      return undefined;\n    }\n  }\n}\nexport function defaultLabelBaseline(angle, axisOrient) {\n  if (angle !== undefined) {\n    angle = normalizeAngle(angle);\n\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle <= 45 || 315 <= angle) {\n        return axisOrient === 'top' ? 'bottom' : 'top';\n      } else if (135 <= angle && angle <= 225) {\n        return axisOrient === 'top' ? 'top' : 'bottom';\n      } else {\n        return 'middle';\n      }\n    } else {\n      if (angle <= 45 || 315 <= angle || 135 <= angle && angle <= 225) {\n        return 'middle';\n      } else if (45 <= angle && angle <= 135) {\n        return axisOrient === 'left' ? 'top' : 'bottom';\n      } else {\n        return axisOrient === 'left' ? 'bottom' : 'top';\n      }\n    }\n  }\n\n  return undefined;\n}\nexport function defaultLabelAlign(angle, axisOrient) {\n  if (angle !== undefined) {\n    angle = normalizeAngle(angle);\n\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle % 180 === 0) {\n        return 'center';\n      } else if (0 < angle && angle < 180) {\n        return axisOrient === 'top' ? 'right' : 'left';\n      } else {\n        return axisOrient === 'top' ? 'left' : 'right';\n      }\n    } else {\n      if ((angle + 90) % 180 === 0) {\n        return 'center';\n      } else if (90 <= angle && angle < 270) {\n        return axisOrient === 'left' ? 'left' : 'right';\n      } else {\n        return axisOrient === 'left' ? 'right' : 'left';\n      }\n    }\n  }\n\n  return undefined;\n}\nexport function defaultLabelFlush(fieldDef, channel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], fieldDef.type)) {\n    return true;\n  }\n\n  return undefined;\n}\nexport function defaultLabelOverlap(fieldDef, scaleType) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (fieldDef.type !== 'nominal') {\n    if (scaleType === 'log') {\n      return 'greedy';\n    }\n\n    return true;\n  }\n\n  return undefined;\n}\nexport function orient(channel) {\n  switch (channel) {\n    case X:\n      return 'bottom';\n\n    case Y:\n      return 'left';\n  }\n  /* istanbul ignore next: This should never happen. */\n\n\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\nexport function defaultTickCount({\n  fieldDef,\n  scaleType,\n  size\n}) {\n  if (!hasDiscreteDomain(scaleType) && scaleType !== 'log' && !contains(['month', 'hours', 'day', 'quarter'], fieldDef.timeUnit)) {\n    if (isBinning(fieldDef.bin)) {\n      // for binned data, we don't want more ticks than maxbins\n      return {\n        signal: `ceil(${size.signal}/10)`\n      };\n    }\n\n    return {\n      signal: `ceil(${size.signal}/40)`\n    };\n  }\n\n  return undefined;\n}\nexport function values(specifiedAxis, model, fieldDef) {\n  const vals = specifiedAxis.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n\n  return undefined;\n}\nexport function defaultZindex(mark, fieldDef) {\n  if (mark === 'rect' && isDiscrete(fieldDef)) {\n    return 1;\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["../../../../src/compile/axis/properties.ts"],"names":[],"mappings":"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","sourcesContent":["import {Align, AxisOrient, SignalRef} from 'vega';\nimport {Axis} from '../../axis';\nimport {isBinning} from '../../bin';\nimport {PositionScaleChannel, X, Y} from '../../channel';\nimport {isDiscrete, TypedFieldDef, valueArray} from '../../channeldef';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../scale';\nimport {NOMINAL, ORDINAL} from '../../type';\nimport {contains, normalizeAngle} from '../../util';\nimport {UnitModel} from '../unit';\nimport {getAxisConfig} from './config';\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function defaultGrid(scaleType: ScaleType, fieldDef: TypedFieldDef<string>) {\n  return !hasDiscreteDomain(scaleType) && !isBinning(fieldDef.bin);\n}\n\nexport function gridScale(model: UnitModel, channel: PositionScaleChannel) {\n  const gridChannel: PositionScaleChannel = channel === 'x' ? 'y' : 'x';\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n  return undefined;\n}\n\nexport function labelAngle(\n  model: UnitModel,\n  specifiedAxis: Axis,\n  channel: PositionScaleChannel,\n  fieldDef: TypedFieldDef<string>\n) {\n  // try axis value\n  if (specifiedAxis.labelAngle !== undefined) {\n    return normalizeAngle(specifiedAxis.labelAngle);\n  } else {\n    // try axis config value\n    const angle = getAxisConfig(\n      'labelAngle',\n      model.config,\n      channel,\n      orient(channel),\n      model.getScaleComponent(channel).get('type')\n    );\n    if (angle !== undefined) {\n      return normalizeAngle(angle);\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldDef.type)) {\n        return 270;\n      }\n      // no default\n      return undefined;\n    }\n  }\n}\n\nexport function defaultLabelBaseline(angle: number, axisOrient: AxisOrient) {\n  if (angle !== undefined) {\n    angle = normalizeAngle(angle);\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle <= 45 || 315 <= angle) {\n        return axisOrient === 'top' ? 'bottom' : 'top';\n      } else if (135 <= angle && angle <= 225) {\n        return axisOrient === 'top' ? 'top' : 'bottom';\n      } else {\n        return 'middle';\n      }\n    } else {\n      if (angle <= 45 || 315 <= angle || (135 <= angle && angle <= 225)) {\n        return 'middle';\n      } else if (45 <= angle && angle <= 135) {\n        return axisOrient === 'left' ? 'top' : 'bottom';\n      } else {\n        return axisOrient === 'left' ? 'bottom' : 'top';\n      }\n    }\n  }\n  return undefined;\n}\n\nexport function defaultLabelAlign(angle: number, axisOrient: AxisOrient): Align {\n  if (angle !== undefined) {\n    angle = normalizeAngle(angle);\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle % 180 === 0) {\n        return 'center';\n      } else if (0 < angle && angle < 180) {\n        return axisOrient === 'top' ? 'right' : 'left';\n      } else {\n        return axisOrient === 'top' ? 'left' : 'right';\n      }\n    } else {\n      if ((angle + 90) % 180 === 0) {\n        return 'center';\n      } else if (90 <= angle && angle < 270) {\n        return axisOrient === 'left' ? 'left' : 'right';\n      } else {\n        return axisOrient === 'left' ? 'right' : 'left';\n      }\n    }\n  }\n  return undefined;\n}\n\nexport function defaultLabelFlush(fieldDef: TypedFieldDef<string>, channel: PositionScaleChannel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], fieldDef.type)) {\n    return true;\n  }\n  return undefined;\n}\n\nexport function defaultLabelOverlap(fieldDef: TypedFieldDef<string>, scaleType: ScaleType) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (fieldDef.type !== 'nominal') {\n    if (scaleType === 'log') {\n      return 'greedy';\n    }\n    return true;\n  }\n  return undefined;\n}\n\nexport function orient(channel: PositionScaleChannel) {\n  switch (channel) {\n    case X:\n      return 'bottom';\n    case Y:\n      return 'left';\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\n\nexport function defaultTickCount({\n  fieldDef,\n  scaleType,\n  size\n}: {\n  fieldDef: TypedFieldDef<string>;\n  scaleType: ScaleType;\n  size?: SignalRef;\n}) {\n  if (\n    !hasDiscreteDomain(scaleType) &&\n    scaleType !== 'log' &&\n    !contains(['month', 'hours', 'day', 'quarter'], fieldDef.timeUnit)\n  ) {\n    if (isBinning(fieldDef.bin)) {\n      // for binned data, we don't want more ticks than maxbins\n      return {signal: `ceil(${size.signal}/10)`};\n    }\n    return {signal: `ceil(${size.signal}/40)`};\n  }\n\n  return undefined;\n}\n\nexport function values(specifiedAxis: Axis, model: UnitModel, fieldDef: TypedFieldDef<string>) {\n  const vals = specifiedAxis.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n\n  return undefined;\n}\n\nexport function defaultZindex(mark: Mark, fieldDef: TypedFieldDef<string>) {\n  if (mark === 'rect' && isDiscrete(fieldDef)) {\n    return 1;\n  }\n  return 0;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}