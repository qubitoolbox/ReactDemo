{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { forEachSelection, MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE } from '.';\nimport { dateTimeExpr, isDateTime } from '../../datetime';\nimport { keys, varName } from '../../util';\nimport { isUnitModel } from '../model';\nimport { forEachTransform } from './transforms/transforms';\nimport { parseSelectionBinExtent } from './parse';\nexport function assembleInit(init, isExpr = true, wrap = identity) {\n  if (isArray(init)) {\n    const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n    return isExpr ? `[${assembled.join(', ')}]` : assembled;\n  } else if (isDateTime(init)) {\n    return wrap(dateTimeExpr(init, false, !isExpr));\n  }\n\n  return isExpr ? wrap(JSON.stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    const name = selCmpt.name;\n    let modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n    signals.push(...selCompiler.signals(model, selCmpt));\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.signals) {\n        signals = txCompiler.signals(model, selCmpt, signals);\n      }\n\n      if (txCompiler.modifyExpr) {\n        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n      }\n    });\n    signals.push({\n      name: name + MODIFY,\n      on: [{\n        events: {\n          signal: selCmpt.name + TUPLE\n        },\n        update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n      }]\n    });\n  });\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('mousemove', 'scope'),\n        update: `isTuple(facet) ? facet : group(${name}).datum`\n      }]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n  let hasSelections = false;\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    const name = selCmpt.name;\n    const store = stringValue(name + STORE);\n    const hasSg = signals.filter(s => s.name === name);\n\n    if (hasSg.length === 0) {\n      const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      const isMulti = selCmpt.type === 'multi' ? ', true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isMulti}`\n      });\n    }\n\n    hasSelections = true;\n\n    if (selCompiler.topLevelSignals) {\n      signals = selCompiler.topLevelSignals(model, selCmpt, signals);\n    }\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.topLevelSignals) {\n        signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n      }\n    });\n  });\n\n  if (hasSelections) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{\n          events: 'mousemove',\n          update: 'isTuple(group()) ? group() : unit'\n        }]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n  const dataCopy = [...data];\n  forEachSelection(model, selCmpt => {\n    const init = {\n      name: selCmpt.name + STORE\n    };\n\n    if (selCmpt.init) {\n      const fields = selCmpt.project.items.map(proj => {\n        const {\n          signals\n        } = proj,\n              rest = __rest(proj, [\"signals\"]);\n\n        return rest;\n      });\n      const insert = selCmpt.init.map(i => assembleInit(i, false));\n      init.values = selCmpt.type === 'interval' ? [{\n        unit: unitName(model, {\n          escape: false\n        }),\n        fields,\n        values: insert\n      }] : insert.map(i => ({\n        unit: unitName(model, {\n          escape: false\n        }),\n        fields,\n        values: i\n      }));\n    }\n\n    const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n\n    if (!contains.length) {\n      dataCopy.push(init);\n    }\n  });\n  return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.marks) {\n        marks = txCompiler.marks(model, selCmpt, marks);\n      }\n    });\n  });\n  return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n  for (const child of model.children) {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  }\n\n  return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent) {\n  const name = extent.selection;\n  const selCmpt = model.getSelectionComponent(name, varName(name));\n  return {\n    signal: parseSelectionBinExtent(selCmpt, extent)\n  };\n}\n\nfunction cleanupEmptyOnArray(signals) {\n  return signals.map(s => {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/selection/assemble.ts"],"names":[],"mappings":"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","sourcesContent":["import {Signal, SignalRef} from 'vega';\nimport {selector as parseSelector} from 'vega-event-selector';\nimport {identity, isArray, stringValue} from 'vega-util';\nimport {forEachSelection, MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE} from '.';\nimport {dateTimeExpr, isDateTime} from '../../datetime';\nimport {SelectionInit, SelectionInitInterval, SelectionExtent} from '../../selection';\nimport {keys, varName} from '../../util';\nimport {VgData} from '../../vega.schema';\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {isUnitModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {forEachTransform} from './transforms/transforms';\nimport {parseSelectionBinExtent} from './parse';\n\nexport function assembleInit(\n  init: readonly (SelectionInit | readonly SelectionInit[] | SelectionInitInterval)[] | SelectionInit,\n  isExpr = true,\n  wrap: (str: string) => string = identity\n): any {\n  if (isArray(init)) {\n    const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n    return isExpr ? `[${assembled.join(', ')}]` : assembled;\n  } else if (isDateTime(init)) {\n    return wrap(dateTimeExpr(init, false, !isExpr));\n  }\n  return isExpr ? wrap(JSON.stringify(init)) : init;\n}\n\nexport function assembleUnitSelectionSignals(model: UnitModel, signals: Signal[]) {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    const name = selCmpt.name;\n    let modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n\n    signals.push(...selCompiler.signals(model, selCmpt));\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.signals) {\n        signals = txCompiler.signals(model, selCmpt, signals);\n      }\n      if (txCompiler.modifyExpr) {\n        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n      }\n    });\n\n    signals.push({\n      name: name + MODIFY,\n      on: [\n        {\n          events: {signal: selCmpt.name + TUPLE},\n          update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n        }\n      ]\n    });\n  });\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleFacetSignals(model: FacetModel, signals: Signal[]) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [\n        {\n          events: parseSelector('mousemove', 'scope'),\n          update: `isTuple(facet) ? facet : group(${name}).datum`\n        }\n      ]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleTopLevelSignals(model: UnitModel, signals: Signal[]) {\n  let hasSelections = false;\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    const name = selCmpt.name;\n    const store = stringValue(name + STORE);\n    const hasSg = signals.filter(s => s.name === name);\n    if (hasSg.length === 0) {\n      const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      const isMulti = selCmpt.type === 'multi' ? ', true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isMulti}`\n      });\n    }\n    hasSelections = true;\n\n    if (selCompiler.topLevelSignals) {\n      signals = selCompiler.topLevelSignals(model, selCmpt, signals);\n    }\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.topLevelSignals) {\n        signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n      }\n    });\n  });\n\n  if (hasSelections) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{events: 'mousemove', update: 'isTuple(group()) ? group() : unit'}]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleUnitSelectionData(model: UnitModel, data: readonly VgData[]): VgData[] {\n  const dataCopy = [...data];\n  forEachSelection(model, selCmpt => {\n    const init: VgData = {name: selCmpt.name + STORE};\n    if (selCmpt.init) {\n      const fields = selCmpt.project.items.map(proj => {\n        const {signals, ...rest} = proj;\n        return rest;\n      });\n\n      const insert = selCmpt.init.map(i => assembleInit(i, false));\n      init.values =\n        selCmpt.type === 'interval'\n          ? [{unit: unitName(model, {escape: false}), fields, values: insert}]\n          : insert.map(i => ({unit: unitName(model, {escape: false}), fields, values: i}));\n    }\n    const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n    if (!contains.length) {\n      dataCopy.push(init);\n    }\n  });\n\n  return dataCopy;\n}\n\nexport function assembleUnitSelectionMarks(model: UnitModel, marks: any[]): any[] {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.marks) {\n        marks = txCompiler.marks(model, selCmpt, marks);\n      }\n    });\n  });\n\n  return marks;\n}\n\nexport function assembleLayerSelectionMarks(model: LayerModel, marks: any[]): any[] {\n  for (const child of model.children) {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  }\n\n  return marks;\n}\n\nexport function assembleSelectionScaleDomain(model: Model, extent: SelectionExtent): SignalRef {\n  const name = extent.selection;\n  const selCmpt = model.getSelectionComponent(name, varName(name));\n  return {signal: parseSelectionBinExtent(selCmpt, extent)};\n}\n\nfunction cleanupEmptyOnArray(signals: Signal[]) {\n  return signals.map(s => {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}