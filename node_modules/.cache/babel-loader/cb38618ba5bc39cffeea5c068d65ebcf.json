{"ast":null,"code":"import { getState, setState } from './state';\nimport { canonicalType, isCollect } from './util';\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\n\nexport default function (df, transforms, functions) {\n  return new Context(df, transforms, functions);\n}\n\nfunction Context(df, transforms, functions) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction ContextFork(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.functions = ctx.functions;\n  this.events = ctx.events;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = ContextFork.prototype = {\n  fork: function () {\n    var ctx = new ContextFork(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n  get: function (id) {\n    return this.nodes[id];\n  },\n  set: function (id, node) {\n    return this.nodes[id] = node;\n  },\n  add: function (spec, op) {\n    var ctx = this,\n        df = ctx.dataflow,\n        data;\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && (data = spec.value)) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      var p = ctx.get(spec.parent.$ref);\n\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(function () {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      for (var name in spec.data) {\n        data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(function (role) {\n          data[role] = op;\n        });\n      }\n    }\n  },\n  resolve: function () {\n    (this.unresolved || []).forEach(function (fn) {\n      fn();\n    });\n    delete this.unresolved;\n    return this;\n  },\n  operator: function (spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n  transform: function (spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n  stream: function (spec, stream) {\n    this.set(spec.id, stream);\n  },\n  update: function (spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n  getState: getState,\n  setState: setState\n};","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-runtime/src/context.js"],"names":["getState","setState","canonicalType","isCollect","df","transforms","functions","Context","dataflow","events","bind","signals","scales","nodes","data","fn","Object","create","context","ContextFork","ctx","prototype","fork","subcontext","push","get","id","set","node","add","spec","op","type","value","$ingest","ingest","$format","$request","preload","pulse","changeset","insert","root","parent","p","$ref","connect","targets","unresolved","signal","scale","name","forEach","role","resolve","operator","update","transform","stream","target","params","on","options"],"mappings":"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","sourcesContent":["import {getState, setState} from './state';\nimport {canonicalType, isCollect} from './util';\n\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\nexport default function(df, transforms, functions) {\n  return new Context(df, transforms, functions);\n}\n\nfunction Context(df, transforms, functions) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction ContextFork(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.functions = ctx.functions;\n  this.events = ctx.events;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = ContextFork.prototype = {\n  fork: function() {\n    var ctx = new ContextFork(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n  get: function(id) {\n    return this.nodes[id];\n  },\n  set: function(id, node) {\n    return this.nodes[id] = node;\n  },\n  add: function(spec, op) {\n    var ctx = this,\n        df = ctx.dataflow,\n        data;\n\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && (data = spec.value)) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      var p = ctx.get(spec.parent.$ref);\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(function() {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      for (var name in spec.data) {\n        data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(function(role) { data[role] = op; });\n      }\n    }\n  },\n  resolve: function() {\n    (this.unresolved || []).forEach(function(fn) { fn(); });\n    delete this.unresolved;\n    return this;\n  },\n  operator: function(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n  transform: function(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n  stream: function(spec, stream) {\n    this.set(spec.id, stream);\n  },\n  update: function(spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n  getState: getState,\n  setState: setState\n};\n"]},"metadata":{},"sourceType":"module"}