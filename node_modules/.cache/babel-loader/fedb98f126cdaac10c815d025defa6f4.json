{"ast":null,"code":"import { Group, AxisRole, LegendRole, TitleRole } from './constants';\nimport { Transform } from 'vega-dataflow';\nimport { boundClip, Marks } from 'vega-scenegraph';\nimport { inherits } from 'vega-util';\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\n\nexport default function Bound(params) {\n  Transform.call(this, null, params);\n}\nvar prototype = inherits(Bound, Transform);\n\nprototype.transform = function (_, pulse) {\n  var view = pulse.dataflow,\n      mark = _.mark,\n      type = mark.marktype,\n      entry = Marks[type],\n      bound = entry.bound,\n      markBounds = mark.bounds,\n      rebound;\n\n  if (entry.nested) {\n    // multi-item marks have a single bounds instance\n    if (mark.items.length) view.dirty(mark.items[0]);\n    markBounds = boundItem(mark, bound);\n    mark.items.forEach(function (item) {\n      item.bounds.clear().union(markBounds);\n    });\n  } else if (type === Group || _.modified()) {\n    // operator parameters modified -> re-bound all items\n    // updates group bounds in response to modified group content\n    pulse.visit(pulse.MOD, function (item) {\n      view.dirty(item);\n    });\n    markBounds.clear();\n    mark.items.forEach(function (item) {\n      markBounds.union(boundItem(item, bound));\n    }); // force reflow for axes/legends/titles to propagate any layout changes\n\n    switch (mark.role) {\n      case AxisRole:\n      case LegendRole:\n      case TitleRole:\n        pulse.reflow();\n    }\n  } else {\n    // incrementally update bounds, re-bound mark as needed\n    rebound = pulse.changed(pulse.REM);\n    pulse.visit(pulse.ADD, function (item) {\n      markBounds.union(boundItem(item, bound));\n    });\n    pulse.visit(pulse.MOD, function (item) {\n      rebound = rebound || markBounds.alignsWith(item.bounds);\n      view.dirty(item);\n      markBounds.union(boundItem(item, bound));\n    });\n\n    if (rebound) {\n      markBounds.clear();\n      mark.items.forEach(function (item) {\n        markBounds.union(item.bounds);\n      });\n    }\n  } // ensure mark bounds do not exceed any clipping region\n\n\n  boundClip(mark);\n  return pulse.modifies('bounds');\n};\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-view-transforms/src/Bound.js"],"names":["Group","AxisRole","LegendRole","TitleRole","Transform","boundClip","Marks","inherits","Bound","params","call","prototype","transform","_","pulse","view","dataflow","mark","type","marktype","entry","bound","markBounds","bounds","rebound","nested","items","length","dirty","boundItem","forEach","item","clear","union","modified","visit","MOD","role","reflow","changed","REM","ADD","alignsWith","modifies","opt"],"mappings":"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","sourcesContent":["import {Group, AxisRole, LegendRole, TitleRole} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {boundClip, Marks} from 'vega-scenegraph';\nimport {inherits} from 'vega-util';\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\nexport default function Bound(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(Bound, Transform);\n\nprototype.transform = function(_, pulse) {\n  var view = pulse.dataflow,\n      mark = _.mark,\n      type = mark.marktype,\n      entry = Marks[type],\n      bound = entry.bound,\n      markBounds = mark.bounds, rebound;\n\n  if (entry.nested) {\n    // multi-item marks have a single bounds instance\n    if (mark.items.length) view.dirty(mark.items[0]);\n    markBounds = boundItem(mark, bound);\n    mark.items.forEach(function(item) {\n      item.bounds.clear().union(markBounds);\n    });\n  }\n\n  else if (type === Group || _.modified()) {\n    // operator parameters modified -> re-bound all items\n    // updates group bounds in response to modified group content\n    pulse.visit(pulse.MOD, function(item) { view.dirty(item); });\n    markBounds.clear();\n    mark.items.forEach(function(item) {\n      markBounds.union(boundItem(item, bound));\n    });\n\n    // force reflow for axes/legends/titles to propagate any layout changes\n    switch (mark.role) {\n      case AxisRole:\n      case LegendRole:\n      case TitleRole:\n        pulse.reflow();\n    }\n  }\n\n  else {\n    // incrementally update bounds, re-bound mark as needed\n    rebound = pulse.changed(pulse.REM);\n\n    pulse.visit(pulse.ADD, function(item) {\n      markBounds.union(boundItem(item, bound));\n    });\n\n    pulse.visit(pulse.MOD, function(item) {\n      rebound = rebound || markBounds.alignsWith(item.bounds);\n      view.dirty(item);\n      markBounds.union(boundItem(item, bound));\n    });\n\n    if (rebound) {\n      markBounds.clear();\n      mark.items.forEach(function(item) { markBounds.union(item.bounds); });\n    }\n  }\n\n  // ensure mark bounds do not exceed any clipping region\n  boundClip(mark);\n\n  return pulse.modifies('bounds');\n};\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\n"]},"metadata":{},"sourceType":"module"}