{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { hasOwnProperty, isString, stringValue } from 'vega-util';\nimport { STORE, forEachSelection } from '.';\nimport { duplicate, logicalExpr, varName } from '../../util';\nimport { OutputNode } from '../data/dataflow';\nimport { forEachTransform } from './transforms/transforms';\nimport { warn } from '../../log';\nimport { FilterNode } from '../data/filter';\nexport function parseUnitSelection(model, selDefs) {\n  var _a;\n\n  const selCmpts = {};\n  const selectionConfig = model.config.selection;\n\n  for (const name in selDefs) {\n    if (!hasOwnProperty(selDefs, name)) {\n      continue;\n    }\n\n    const selDef = duplicate(selDefs[name]);\n\n    const _b = selectionConfig[selDef.type],\n          {\n      fields,\n      encodings\n    } = _b,\n          cfg = __rest(_b, [\"fields\", \"encodings\"]); // Project transform applies its defaults.\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n\n\n    for (const key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if (key === 'encodings' && selDef.fields || key === 'fields' && selDef.encodings) {\n        continue;\n      }\n\n      if (key === 'mark') {\n        selDef[key] = Object.assign(Object.assign({}, cfg[key]), selDef[key]);\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = (_a = cfg[key], _a !== null && _a !== void 0 ? _a : selDef[key]);\n      }\n    }\n\n    const safeName = varName(name);\n    const selCmpt = selCmpts[safeName] = Object.assign(Object.assign({}, selDef), {\n      name: safeName,\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : duplicate(selDef.on)\n    });\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.has(selCmpt) && txCompiler.parse) {\n        txCompiler.parse(model, selCmpt, selDef, selDefs[name]);\n      }\n    });\n  }\n\n  return selCmpts;\n}\nexport function parseSelectionPredicate(model, selections, dfnode, datum = 'datum') {\n  const stores = [];\n\n  function expr(name) {\n    const vname = varName(name);\n    const selCmpt = model.getSelectionComponent(vname, name);\n    const store = stringValue(vname + STORE);\n\n    if (selCmpt.project.timeUnit) {\n      const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;\n      const tunode = selCmpt.project.timeUnit.clone();\n\n      if (child.parent) {\n        tunode.insertAsParentOf(child);\n      } else {\n        child.parent = tunode;\n      }\n    }\n\n    if (selCmpt.empty !== 'none') {\n      stores.push(store);\n    }\n\n    return `vlSelectionTest(${store}, ${datum}` + (selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`);\n  }\n\n  const predicateStr = logicalExpr(selections, expr);\n  return (stores.length ? '!(' + stores.map(s => `length(data(${s}))`).join(' || ') + ') || ' : '') + `(${predicateStr})`;\n}\nexport function parseSelectionBinExtent(selCmpt, extent) {\n  const encoding = extent['encoding'];\n  let field = extent['field'];\n\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n\n    if (selCmpt.project.items.length > 1) {\n      warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' + `Using \"field\": ${stringValue(field)}.`);\n    }\n  } else if (encoding && !field) {\n    const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn((!encodings.length ? 'No ' : 'Multiple ') + `matching ${stringValue(encoding)} encoding found for selection ${stringValue(extent.selection)}. ` + `Using \"field\": ${stringValue(field)}.`);\n    } else {\n      field = encodings[0].field;\n    }\n  }\n\n  return `${selCmpt.name}[${stringValue(field)}]`;\n}\nexport function materializeSelections(model, main) {\n  forEachSelection(model, selCmpt => {\n    const selection = selCmpt.name;\n    const lookupName = model.getName(`lookup_${selection}`);\n    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main, model, {\n      selection\n    }), lookupName, 'lookup', model.component.data.outputNodeRefCounts);\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/selection/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {selector as parseSelector} from 'vega-event-selector';\nimport {hasOwnProperty, isString, stringValue} from 'vega-util';\nimport {SelectionComponent, STORE, forEachSelection} from '.';\nimport {LogicalOperand} from '../../logical';\nimport {SelectionDef, SelectionExtent} from '../../selection';\nimport {Dict, duplicate, logicalExpr, varName} from '../../util';\nimport {DataFlowNode, OutputNode} from '../data/dataflow';\nimport {Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {forEachTransform} from './transforms/transforms';\nimport {warn} from '../../log';\nimport {FilterNode} from '../data/filter';\n\nexport function parseUnitSelection(model: UnitModel, selDefs: Dict<SelectionDef>) {\n  const selCmpts: Dict<SelectionComponent<any /* this has to be \"any\" so typing won't fail in test files*/>> = {};\n  const selectionConfig = model.config.selection;\n\n  for (const name in selDefs) {\n    if (!hasOwnProperty(selDefs, name)) {\n      continue;\n    }\n\n    const selDef = duplicate(selDefs[name]);\n    const {fields, encodings, ...cfg} = selectionConfig[selDef.type]; // Project transform applies its defaults.\n\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    for (const key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {\n        continue;\n      }\n\n      if (key === 'mark') {\n        selDef[key] = {...cfg[key], ...selDef[key]};\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = cfg[key] ?? selDef[key];\n      }\n    }\n\n    const safeName = varName(name);\n    const selCmpt = (selCmpts[safeName] = {\n      ...selDef,\n      name: safeName,\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : duplicate(selDef.on)\n    } as any);\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.has(selCmpt) && txCompiler.parse) {\n        txCompiler.parse(model, selCmpt, selDef, selDefs[name]);\n      }\n    });\n  }\n\n  return selCmpts;\n}\n\nexport function parseSelectionPredicate(\n  model: Model,\n  selections: LogicalOperand<string>,\n  dfnode?: DataFlowNode,\n  datum = 'datum'\n): string {\n  const stores: string[] = [];\n  function expr(name: string): string {\n    const vname = varName(name);\n    const selCmpt = model.getSelectionComponent(vname, name);\n    const store = stringValue(vname + STORE);\n\n    if (selCmpt.project.timeUnit) {\n      const child = dfnode ?? model.component.data.raw;\n      const tunode = selCmpt.project.timeUnit.clone();\n      if (child.parent) {\n        tunode.insertAsParentOf(child);\n      } else {\n        child.parent = tunode;\n      }\n    }\n\n    if (selCmpt.empty !== 'none') {\n      stores.push(store);\n    }\n\n    return (\n      `vlSelectionTest(${store}, ${datum}` + (selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`)\n    );\n  }\n\n  const predicateStr = logicalExpr(selections, expr);\n  return (\n    (stores.length ? '!(' + stores.map(s => `length(data(${s}))`).join(' || ') + ') || ' : '') + `(${predicateStr})`\n  );\n}\n\nexport function parseSelectionBinExtent(selCmpt: SelectionComponent, extent: SelectionExtent) {\n  const encoding = extent['encoding'];\n  let field = extent['field'];\n\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n    if (selCmpt.project.items.length > 1) {\n      warn(\n        'A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' +\n          `Using \"field\": ${stringValue(field)}.`\n      );\n    }\n  } else if (encoding && !field) {\n    const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn(\n        (!encodings.length ? 'No ' : 'Multiple ') +\n          `matching ${stringValue(encoding)} encoding found for selection ${stringValue(extent.selection)}. ` +\n          `Using \"field\": ${stringValue(field)}.`\n      );\n    } else {\n      field = encodings[0].field;\n    }\n  }\n\n  return `${selCmpt.name}[${stringValue(field)}]`;\n}\n\nexport function materializeSelections(model: UnitModel, main: OutputNode) {\n  forEachSelection(model, selCmpt => {\n    const selection = selCmpt.name;\n    const lookupName = model.getName(`lookup_${selection}`);\n    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(\n      new FilterNode(main, model, {selection}),\n      lookupName,\n      'lookup',\n      model.component.data.outputNodeRefCounts\n    );\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}