{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nconst dom_1 = require(\"../util/dom\");\n\nconst utils_1 = require(\"../util/utils\");\n\nconst render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a line chart\n *\n * ```js\n * const series1 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 - (Math.random() * 50))\n *   .map((y, x) => ({ x, y, }));\n *\n * const series2 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 - (Math.random() * 150))\n *   .map((y, x) => ({ x, y, }));\n *\n * const series = ['First', 'Second'];\n * const data = { values: [series1, series2], series }\n *\n * const surface = { name: 'Line chart', tab: 'Charts' };\n * tfvis.render.linechart(surface, data);\n * ```\n *\n * ```js\n * const series1 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 + 50)\n *   .map((y, x) => ({ x, y, }));\n *\n * const data = { values: [series1] }\n *\n * // Render to visor\n * const surface = { name: 'Zoomed Line Chart', tab: 'Charts' };\n * tfvis.render.linechart(surface, data, { zoomToFit: true });\n * ```\n *\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\n\nfunction linechart(container, data, opts = {}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Nest data if necessary before further processing\n    const _data = Array.isArray(data.values[0]) ? data.values : [data.values];\n\n    const numValues = _data[0].length; // Create series names if none were passed in.\n\n    const _series = data.series ? data.series : _data.map((_, i) => `Series ${i + 1}`);\n\n    utils_1.assert(_series.length === _data.length, 'Must have an equal number of series labels as there are data series');\n\n    if (opts.seriesColors != null) {\n      utils_1.assert(opts.seriesColors.length === _data.length, 'Must have an equal number of series colors as there are data series');\n    }\n\n    const vlChartValues = [];\n\n    for (let valueIdx = 0; valueIdx < numValues; valueIdx++) {\n      const v = {\n        x: valueIdx\n      };\n\n      _series.forEach((seriesName, seriesIdx) => {\n        const seriesValue = _data[seriesIdx][valueIdx].y;\n        v[seriesName] = seriesValue;\n        v[`${seriesName}-name`] = seriesName;\n      });\n\n      vlChartValues.push(v);\n    }\n\n    const options = Object.assign({}, defaultOpts, opts);\n\n    const yScale = () => {\n      if (options.zoomToFit) {\n        return {\n          'zero': false\n        };\n      } else if (options.yAxisDomain != null) {\n        return {\n          'domain': options.yAxisDomain\n        };\n      }\n\n      return undefined;\n    };\n\n    const sharedEncoding = {\n      x: {\n        field: 'x',\n        type: options.xType,\n        title: options.xLabel\n      },\n      tooltip: [{\n        field: 'x',\n        type: 'quantitative'\n      }, ..._series.map(seriesName => {\n        return {\n          field: seriesName,\n          type: 'quantitative'\n        };\n      })]\n    };\n\n    const lineLayers = _series.map(seriesName => {\n      return {\n        // data will be defined at the chart level.\n        'data': undefined,\n        'mark': {\n          'type': 'line',\n          'clip': true\n        },\n        'encoding': {\n          // Note: the encoding for 'x' is shared\n          // Add a y encoding for this series\n          'y': {\n            'field': seriesName,\n            'type': options.yType,\n            'title': options.yLabel,\n            'scale': yScale()\n          },\n          'color': {\n            'field': `${seriesName}-name`,\n            'type': 'nominal',\n            'legend': {\n              'values': _series,\n              title: null\n            },\n            'scale': {\n              'range': options.seriesColors\n            }\n          }\n        }\n      };\n    });\n\n    const tooltipLayer = {\n      'mark': 'rule',\n      'selection': {\n        'hover': {\n          'type': 'single',\n          'on': 'mouseover',\n          'nearest': true,\n          clear: 'mouseout'\n        }\n      },\n      'encoding': {\n        'color': {\n          'value': 'grey',\n          'condition': {\n            'selection': {\n              'not': 'hover'\n            },\n            'value': 'transparent'\n          }\n        }\n      }\n    };\n    const drawArea = render_utils_1.getDrawArea(container);\n    const spec = {\n      'width': options.width || dom_1.getDefaultWidth(drawArea),\n      'height': options.height || dom_1.getDefaultHeight(drawArea),\n      'padding': 0,\n      'autosize': {\n        'type': 'fit',\n        'contains': 'padding',\n        'resize': true\n      },\n      'config': {\n        'axis': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        },\n        'text': {\n          'fontSize': options.fontSize\n        },\n        'legend': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        }\n      },\n      'data': {\n        'values': vlChartValues\n      },\n      'encoding': sharedEncoding,\n      'layer': [...lineLayers, tooltipLayer]\n    };\n    const embedOpts = {\n      actions: false,\n      mode: 'vega-lite',\n      defaultStyle: false\n    };\n    yield vega_embed_1.default(drawArea, spec, embedOpts);\n    return Promise.resolve();\n  });\n}\n\nexports.linechart = linechart;\nconst defaultOpts = {\n  xLabel: 'x',\n  yLabel: 'y',\n  xType: 'quantitative',\n  yType: 'quantitative',\n  zoomToFit: false,\n  fontSize: 11\n};","map":{"version":3,"sources":["../../src/render/linechart.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport embed, {Mode, VisualizationSpec} from 'vega-embed';\nimport {TopLevelSpec} from 'vega-lite';\n\nimport {Drawable, Point2D, XYPlotData, XYPlotOptions} from '../types';\nimport {getDefaultHeight, getDefaultWidth} from '../util/dom';\nimport {assert} from '../util/utils';\n\nimport {getDrawArea} from './render_utils';\n\n/**\n * Renders a line chart\n *\n * ```js\n * const series1 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 - (Math.random() * 50))\n *   .map((y, x) => ({ x, y, }));\n *\n * const series2 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 - (Math.random() * 150))\n *   .map((y, x) => ({ x, y, }));\n *\n * const series = ['First', 'Second'];\n * const data = { values: [series1, series2], series }\n *\n * const surface = { name: 'Line chart', tab: 'Charts' };\n * tfvis.render.linechart(surface, data);\n * ```\n *\n * ```js\n * const series1 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 + 50)\n *   .map((y, x) => ({ x, y, }));\n *\n * const data = { values: [series1] }\n *\n * // Render to visor\n * const surface = { name: 'Zoomed Line Chart', tab: 'Charts' };\n * tfvis.render.linechart(surface, data, { zoomToFit: true });\n * ```\n *\n */\n/** @doc {heading: 'Charts', namespace: 'render'} */\nexport async function linechart(\n    container: Drawable, data: XYPlotData,\n    opts: XYPlotOptions = {}): Promise<void> {\n  // Nest data if necessary before further processing\n  const _data = Array.isArray(data.values[0]) ? data.values as Point2D[][] :\n                                                [data.values] as Point2D[][];\n  const numValues = _data[0].length;\n\n  // Create series names if none were passed in.\n  const _series: string[] =\n      data.series ? data.series : _data.map((_, i) => `Series ${i + 1}`);\n  assert(\n      _series.length === _data.length,\n      'Must have an equal number of series labels as there are data series');\n\n  if (opts.seriesColors != null) {\n    assert(\n        opts.seriesColors.length === _data.length,\n        'Must have an equal number of series colors as there are data series');\n  }\n\n  const vlChartValues: VLChartValue[] = [];\n  for (let valueIdx = 0; valueIdx < numValues; valueIdx++) {\n    const v: VLChartValue = {\n      x: valueIdx,\n    };\n\n    _series.forEach((seriesName, seriesIdx) => {\n      const seriesValue = _data[seriesIdx][valueIdx].y;\n      v[seriesName] = seriesValue;\n      v[`${seriesName}-name`] = seriesName;\n    });\n    vlChartValues.push(v);\n  }\n\n  const options = Object.assign({}, defaultOpts, opts);\n\n  const yScale = (): {}|undefined => {\n    if (options.zoomToFit) {\n      return {'zero': false};\n    } else if (options.yAxisDomain != null) {\n      return {'domain': options.yAxisDomain};\n    }\n    return undefined;\n  };\n\n  const sharedEncoding = {\n    x: {\n      field: 'x',\n      type: options.xType,\n      title: options.xLabel,\n    },\n    tooltip: [\n      {field: 'x', type: 'quantitative'},\n      ..._series.map(seriesName => {\n        return {\n          field: seriesName,\n          type: 'quantitative',\n        };\n      }),\n    ]\n  };\n\n  const lineLayers: TopLevelSpec[] = _series.map((seriesName) => {\n    return {\n      // data will be defined at the chart level.\n      'data': undefined,\n      'mark': {'type': 'line', 'clip': true},\n      'encoding': {\n        // Note: the encoding for 'x' is shared\n        // Add a y encoding for this series\n        'y': {\n          'field': seriesName,\n          'type': options.yType,\n          'title': options.yLabel,\n          'scale': yScale(),\n        },\n        'color': {\n          'field': `${seriesName}-name`,\n          'type': 'nominal',\n          'legend': {'values': _series, title: null},\n          'scale': {\n            'range': options.seriesColors,\n          }\n        },\n      }\n    };\n  });\n\n  const tooltipLayer = {\n    'mark': 'rule',\n    'selection': {\n      'hover': {\n        'type': 'single',\n        'on': 'mouseover',\n        'nearest': true,\n        clear: 'mouseout',\n      }\n    },\n    'encoding': {\n      'color': {\n        'value': 'grey',\n        'condition': {\n          'selection': {'not': 'hover'},\n          'value': 'transparent',\n        }\n      }\n    }\n  };\n\n  const drawArea = getDrawArea(container);\n  const spec = {\n    'width': options.width || getDefaultWidth(drawArea),\n    'height': options.height || getDefaultHeight(drawArea),\n    'padding': 0,\n    'autosize': {\n      'type': 'fit',\n      'contains': 'padding',\n      'resize': true,\n    },\n    'config': {\n      'axis': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      },\n      'text': {'fontSize': options.fontSize},\n      'legend': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      }\n    },\n    'data': {'values': vlChartValues},\n    'encoding': sharedEncoding,\n    'layer': [\n      ...lineLayers,\n      tooltipLayer,\n    ],\n  };\n\n  const embedOpts = {\n    actions: false,\n    mode: 'vega-lite' as Mode,\n    defaultStyle: false,\n  };\n\n  await embed(drawArea, spec as VisualizationSpec, embedOpts);\n  return Promise.resolve();\n}\n\nconst defaultOpts = {\n  xLabel: 'x',\n  yLabel: 'y',\n  xType: 'quantitative',\n  yType: 'quantitative',\n  zoomToFit: false,\n  fontSize: 11,\n};\n\ninterface VLChartValue {\n  x: number;\n  [key: string]: string|number;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}