{"ast":null,"code":"import { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { isValueDef } from '../../channeldef';\nimport { GEOJSON } from '../../type';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class GeoJSONNode extends DataFlowNode {\n  constructor(parent, fields, geojson, signal) {\n    super(parent);\n    this.fields = fields;\n    this.geojson = geojson;\n    this.signal = signal;\n  }\n\n  clone() {\n    return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);\n  }\n\n  static parseAll(parent, model) {\n    if (model.component.projection && !model.component.projection.isFit) {\n      return parent;\n    }\n\n    let geoJsonCounter = 0;\n\n    for (const coordinates of [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]) {\n      const pair = coordinates.map(channel => model.channelHasField(channel) ? model.fieldDef(channel).field : isValueDef(model.encoding[channel]) ? {\n        expr: model.encoding[channel].value + ''\n      } : undefined);\n\n      if (pair[0] || pair[1]) {\n        parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    if (model.channelHasField(SHAPE)) {\n      const fieldDef = model.fieldDef(SHAPE);\n\n      if (fieldDef.type === GEOJSON) {\n        parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    return parent;\n  }\n\n  dependentFields() {\n    var _a;\n\n    const fields = (_a = this.fields, _a !== null && _a !== void 0 ? _a : []).filter(isString);\n    return new Set([...(this.geojson ? [this.geojson] : []), ...fields]);\n  }\n\n  producedFields() {\n    return new Set();\n  }\n\n  hash() {\n    return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;\n  }\n\n  assemble() {\n    return Object.assign(Object.assign(Object.assign({\n      type: 'geojson'\n    }, this.fields ? {\n      fields: this.fields\n    } : {}), this.geojson ? {\n      geojson: this.geojson\n    } : {}), {\n      signal: this.signal\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/compile/data/geojson.ts"],"names":[],"mappings":"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","sourcesContent":["import {GeoJSONTransform as VgGeoJSONTransform, Vector2} from 'vega';\nimport {isString} from 'vega-util';\nimport {GeoPositionChannel, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE} from '../../channel';\nimport {isValueDef, ValueDef} from '../../channeldef';\nimport {GEOJSON} from '../../type';\nimport {duplicate, hash} from '../../util';\nimport {VgExprRef} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class GeoJSONNode extends DataFlowNode {\n  public clone() {\n    return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);\n  }\n\n  public static parseAll(parent: DataFlowNode, model: UnitModel): DataFlowNode {\n    if (model.component.projection && !model.component.projection.isFit) {\n      return parent;\n    }\n\n    let geoJsonCounter = 0;\n\n    for (const coordinates of [\n      [LONGITUDE, LATITUDE],\n      [LONGITUDE2, LATITUDE2]\n    ] as Vector2<GeoPositionChannel>[]) {\n      const pair = coordinates.map(channel =>\n        model.channelHasField(channel)\n          ? model.fieldDef(channel).field\n          : isValueDef(model.encoding[channel])\n          ? {expr: (model.encoding[channel] as ValueDef<number>).value + ''}\n          : undefined\n      ) as [GeoPositionChannel, GeoPositionChannel];\n\n      if (pair[0] || pair[1]) {\n        parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    if (model.channelHasField(SHAPE)) {\n      const fieldDef = model.fieldDef(SHAPE);\n      if (fieldDef.type === GEOJSON) {\n        parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    return parent;\n  }\n\n  constructor(\n    parent: DataFlowNode,\n    private fields?: Vector2<string | VgExprRef>,\n    private geojson?: string,\n    private signal?: string\n  ) {\n    super(parent);\n  }\n\n  public dependentFields() {\n    const fields = (this.fields ?? []).filter(isString) as string[];\n    return new Set([...(this.geojson ? [this.geojson] : []), ...fields]);\n  }\n\n  public producedFields() {\n    return new Set<string>();\n  }\n\n  public hash() {\n    return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;\n  }\n\n  public assemble(): VgGeoJSONTransform {\n    return {\n      type: 'geojson',\n      ...(this.fields ? {fields: this.fields} : {}),\n      ...(this.geojson ? {geojson: this.geojson} : {}),\n      signal: this.signal\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}