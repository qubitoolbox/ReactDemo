{"ast":null,"code":"import parseTransform from '../transform';\nimport { ref } from '../../util';\nimport { Collect } from '../../transforms';\nimport { array, error, extend } from 'vega-util';\nexport default function (from, group, scope) {\n  var facet, key, op, dataRef, parent; // if no source data, generate singleton datum\n\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  } // if faceted, process facet specification\n  else if (facet = from.facet) {\n      if (!group) error('Only group marks can be faceted.'); // use pre-faceted source data, if available\n\n      if (facet.field != null) {\n        dataRef = parent = getDataRef(facet, scope);\n      } else {\n        // generate facet aggregates if no direct data specification\n        if (!from.data) {\n          op = parseTransform(extend({\n            type: 'aggregate',\n            groupby: array(facet.groupby)\n          }, facet.aggregate), scope);\n          op.params.key = scope.keyRef(facet.groupby);\n          op.params.pulse = getDataRef(facet, scope);\n          dataRef = parent = ref(scope.add(op));\n        } else {\n          parent = ref(scope.getData(from.data).aggregate);\n        }\n\n        key = scope.keyRef(facet.groupby, true);\n      }\n    } // if not yet defined, get source data reference\n\n\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\nexport function getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}","map":{"version":3,"sources":["C:/NewReactResume/resm/node_modules/vega-parser/src/parsers/marks/data.js"],"names":["parseTransform","ref","Collect","array","error","extend","from","group","scope","facet","key","op","dataRef","parent","add","field","getDataRef","data","type","groupby","aggregate","params","keyRef","pulse","getData","$ref","output"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,cAA3B;AACA,SAAQC,GAAR,QAAkB,YAAlB;AACA,SAAQC,OAAR,QAAsB,kBAAtB;AACA,SAAQC,KAAR,EAAeC,KAAf,EAAsBC,MAAtB,QAAmC,WAAnC;AAEA,eAAe,UAASC,IAAT,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AAC1C,MAAIC,KAAJ,EAAWC,GAAX,EAAgBC,EAAhB,EAAoBC,OAApB,EAA6BC,MAA7B,CAD0C,CAG1C;;AACA,MAAI,CAACP,IAAL,EAAW;AACTM,IAAAA,OAAO,GAAGX,GAAG,CAACO,KAAK,CAACM,GAAN,CAAUZ,OAAO,CAAC,IAAD,EAAO,CAAC,EAAD,CAAP,CAAjB,CAAD,CAAb;AACD,GAFD,CAIA;AAJA,OAKK,IAAIO,KAAK,GAAGH,IAAI,CAACG,KAAjB,EAAwB;AAC3B,UAAI,CAACF,KAAL,EAAYH,KAAK,CAAC,kCAAD,CAAL,CADe,CAG3B;;AACA,UAAIK,KAAK,CAACM,KAAN,IAAe,IAAnB,EAAyB;AACvBH,QAAAA,OAAO,GAAGC,MAAM,GAAGG,UAAU,CAACP,KAAD,EAAQD,KAAR,CAA7B;AACD,OAFD,MAEO;AACL;AACA,YAAI,CAACF,IAAI,CAACW,IAAV,EAAgB;AACdN,UAAAA,EAAE,GAAGX,cAAc,CAACK,MAAM,CAAC;AACzBa,YAAAA,IAAI,EAAK,WADgB;AAEzBC,YAAAA,OAAO,EAAEhB,KAAK,CAACM,KAAK,CAACU,OAAP;AAFW,WAAD,EAGvBV,KAAK,CAACW,SAHiB,CAAP,EAGEZ,KAHF,CAAnB;AAIAG,UAAAA,EAAE,CAACU,MAAH,CAAUX,GAAV,GAAgBF,KAAK,CAACc,MAAN,CAAab,KAAK,CAACU,OAAnB,CAAhB;AACAR,UAAAA,EAAE,CAACU,MAAH,CAAUE,KAAV,GAAkBP,UAAU,CAACP,KAAD,EAAQD,KAAR,CAA5B;AACAI,UAAAA,OAAO,GAAGC,MAAM,GAAGZ,GAAG,CAACO,KAAK,CAACM,GAAN,CAAUH,EAAV,CAAD,CAAtB;AACD,SARD,MAQO;AACLE,UAAAA,MAAM,GAAGZ,GAAG,CAACO,KAAK,CAACgB,OAAN,CAAclB,IAAI,CAACW,IAAnB,EAAyBG,SAA1B,CAAZ;AACD;;AAEDV,QAAAA,GAAG,GAAGF,KAAK,CAACc,MAAN,CAAab,KAAK,CAACU,OAAnB,EAA4B,IAA5B,CAAN;AACD;AACF,KA/ByC,CAiC1C;;;AACA,MAAI,CAACP,OAAL,EAAc;AACZA,IAAAA,OAAO,GAAGI,UAAU,CAACV,IAAD,EAAOE,KAAP,CAApB;AACD;;AAED,SAAO;AACLE,IAAAA,GAAG,EAAEA,GADA;AAELa,IAAAA,KAAK,EAAEX,OAFF;AAGLC,IAAAA,MAAM,EAAEA;AAHH,GAAP;AAKD;AAED,OAAO,SAASG,UAAT,CAAoBV,IAApB,EAA0BE,KAA1B,EAAiC;AACtC,SAAOF,IAAI,CAACmB,IAAL,GAAYnB,IAAZ,GACHA,IAAI,CAACW,IAAL,IAAaX,IAAI,CAACW,IAAL,CAAUQ,IAAvB,GAA8BnB,IAAI,CAACW,IAAnC,GACAhB,GAAG,CAACO,KAAK,CAACgB,OAAN,CAAclB,IAAI,CAACW,IAAnB,EAAyBS,MAA1B,CAFP;AAGD","sourcesContent":["import parseTransform from '../transform';\nimport {ref} from '../../util';\nimport {Collect} from '../../transforms';\nimport {array, error, extend} from 'vega-util';\n\nexport default function(from, group, scope) {\n  var facet, key, op, dataRef, parent;\n\n  // if no source data, generate singleton datum\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  }\n\n  // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.');\n\n    // use pre-faceted source data, if available\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type:    'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  }\n\n  // if not yet defined, get source data reference\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\n\nexport function getDataRef(from, scope) {\n  return from.$ref ? from\n    : from.data && from.data.$ref ? from.data\n    : ref(scope.getData(from.data).output);\n}"]},"metadata":{},"sourceType":"module"}