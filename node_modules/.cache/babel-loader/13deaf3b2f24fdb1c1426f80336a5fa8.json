{"ast":null,"code":"import { isString, toSet } from 'vega-util';\nimport { contains, keys } from './util';\nconst AGGREGATE_OP_INDEX = {\n  argmax: 1,\n  argmin: 1,\n  average: 1,\n  count: 1,\n  distinct: 1,\n  max: 1,\n  mean: 1,\n  median: 1,\n  min: 1,\n  missing: 1,\n  q1: 1,\n  q3: 1,\n  ci0: 1,\n  ci1: 1,\n  stderr: 1,\n  stdev: 1,\n  stdevp: 1,\n  sum: 1,\n  valid: 1,\n  values: 1,\n  variance: 1,\n  variancep: 1\n};\nexport const MULTIDOMAIN_SORT_OP_INDEX = {\n  count: 1,\n  min: 1,\n  max: 1\n};\nexport function isArgminDef(a) {\n  return !!a && !!a['argmin'];\n}\nexport function isArgmaxDef(a) {\n  return !!a && !!a['argmax'];\n}\nexport const AGGREGATE_OPS = keys(AGGREGATE_OP_INDEX);\nexport function isAggregateOp(a) {\n  return isString(a) && !!AGGREGATE_OP_INDEX[a];\n}\nexport const COUNTING_OPS = ['count', 'valid', 'missing', 'distinct'];\nexport function isCountingAggregateOp(aggregate) {\n  return isString(aggregate) && contains(COUNTING_OPS, aggregate);\n}\nexport function isMinMaxOp(aggregate) {\n  return isString(aggregate) && contains(['min', 'max'], aggregate);\n}\n/** Additive-based aggregation operations. These can be applied to stack. */\n\nexport const SUM_OPS = ['count', 'sum', 'distinct', 'valid', 'missing'];\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\n\nexport const SHARED_DOMAIN_OPS = ['mean', 'average', 'median', 'q1', 'q3', 'min', 'max'];\nexport const SHARED_DOMAIN_OP_INDEX = toSet(SHARED_DOMAIN_OPS);","map":{"version":3,"sources":["../../src/aggregate.ts"],"names":[],"mappings":"AACA,SAAQ,QAAR,EAAkB,KAAlB,QAA8B,WAA9B;AACA,SAAQ,QAAR,EAAwB,IAAxB,QAAmC,QAAnC;AAEA,MAAM,kBAAkB,GAAsB;AAC5C,EAAA,MAAM,EAAE,CADoC;AAE5C,EAAA,MAAM,EAAE,CAFoC;AAG5C,EAAA,OAAO,EAAE,CAHmC;AAI5C,EAAA,KAAK,EAAE,CAJqC;AAK5C,EAAA,QAAQ,EAAE,CALkC;AAM5C,EAAA,GAAG,EAAE,CANuC;AAO5C,EAAA,IAAI,EAAE,CAPsC;AAQ5C,EAAA,MAAM,EAAE,CARoC;AAS5C,EAAA,GAAG,EAAE,CATuC;AAU5C,EAAA,OAAO,EAAE,CAVmC;AAW5C,EAAA,EAAE,EAAE,CAXwC;AAY5C,EAAA,EAAE,EAAE,CAZwC;AAa5C,EAAA,GAAG,EAAE,CAbuC;AAc5C,EAAA,GAAG,EAAE,CAduC;AAe5C,EAAA,MAAM,EAAE,CAfoC;AAgB5C,EAAA,KAAK,EAAE,CAhBqC;AAiB5C,EAAA,MAAM,EAAE,CAjBoC;AAkB5C,EAAA,GAAG,EAAE,CAlBuC;AAmB5C,EAAA,KAAK,EAAE,CAnBqC;AAoB5C,EAAA,MAAM,EAAE,CApBoC;AAqB5C,EAAA,QAAQ,EAAE,CArBkC;AAsB5C,EAAA,SAAS,EAAE;AAtBiC,CAA9C;AAyBA,OAAO,MAAM,yBAAyB,GAAG;AACvC,EAAA,KAAK,EAAE,CADgC;AAEvC,EAAA,GAAG,EAAE,CAFkC;AAGvC,EAAA,GAAG,EAAE;AAHkC,CAAlC;AAkBP,OAAM,SAAU,WAAV,CAAsB,CAAtB,EAA2C;AAC/C,SAAO,CAAC,CAAC,CAAF,IAAO,CAAC,CAAC,CAAC,CAAC,QAAD,CAAjB;AACD;AAED,OAAM,SAAU,WAAV,CAAsB,CAAtB,EAA2C;AAC/C,SAAO,CAAC,CAAC,CAAF,IAAO,CAAC,CAAC,CAAC,CAAC,QAAD,CAAjB;AACD;AAED,OAAO,MAAM,aAAa,GAAG,IAAI,CAAC,kBAAD,CAA1B;AAEP,OAAM,SAAU,aAAV,CAAwB,CAAxB,EAAyD;AAC7D,SAAO,QAAQ,CAAC,CAAD,CAAR,IAAe,CAAC,CAAC,kBAAkB,CAAC,CAAD,CAA1C;AACD;AAED,OAAO,MAAM,YAAY,GAAwB,CAAC,OAAD,EAAU,OAAV,EAAmB,SAAnB,EAA8B,UAA9B,CAA1C;AAEP,OAAM,SAAU,qBAAV,CAAgC,SAAhC,EAA8D;AAClE,SAAO,QAAQ,CAAC,SAAD,CAAR,IAAuB,QAAQ,CAAC,YAAD,EAAe,SAAf,CAAtC;AACD;AAED,OAAM,SAAU,UAAV,CAAqB,SAArB,EAAmD;AACvD,SAAO,QAAQ,CAAC,SAAD,CAAR,IAAuB,QAAQ,CAAC,CAAC,KAAD,EAAQ,KAAR,CAAD,EAAiB,SAAjB,CAAtC;AACD;AAED;;AACA,OAAO,MAAM,OAAO,GAAwB,CAAC,OAAD,EAAU,KAAV,EAAiB,UAAjB,EAA6B,OAA7B,EAAsC,SAAtC,CAArC;AAEP;;;;AAGA,OAAO,MAAM,iBAAiB,GAAkB,CAAC,MAAD,EAAS,SAAT,EAAoB,QAApB,EAA8B,IAA9B,EAAoC,IAApC,EAA0C,KAA1C,EAAiD,KAAjD,CAAzC;AAEP,OAAO,MAAM,sBAAsB,GAAG,KAAK,CAAC,iBAAD,CAApC","sourcesContent":["import {AggregateOp} from 'vega';\nimport {isString, toSet} from 'vega-util';\nimport {contains, Flag, keys} from './util';\n\nconst AGGREGATE_OP_INDEX: Flag<AggregateOp> = {\n  argmax: 1,\n  argmin: 1,\n  average: 1,\n  count: 1,\n  distinct: 1,\n  max: 1,\n  mean: 1,\n  median: 1,\n  min: 1,\n  missing: 1,\n  q1: 1,\n  q3: 1,\n  ci0: 1,\n  ci1: 1,\n  stderr: 1,\n  stdev: 1,\n  stdevp: 1,\n  sum: 1,\n  valid: 1,\n  values: 1,\n  variance: 1,\n  variancep: 1\n};\n\nexport const MULTIDOMAIN_SORT_OP_INDEX = {\n  count: 1,\n  min: 1,\n  max: 1\n};\n\nexport interface ArgminDef {\n  argmin: string;\n}\n\nexport interface ArgmaxDef {\n  argmax: string;\n}\n\nexport type NonArgAggregateOp = Exclude<AggregateOp, 'argmin' | 'argmax'>;\n\nexport type Aggregate = NonArgAggregateOp | ArgmaxDef | ArgminDef;\n\nexport function isArgminDef(a: Aggregate | string): a is ArgminDef {\n  return !!a && !!a['argmin'];\n}\n\nexport function isArgmaxDef(a: Aggregate | string): a is ArgmaxDef {\n  return !!a && !!a['argmax'];\n}\n\nexport const AGGREGATE_OPS = keys(AGGREGATE_OP_INDEX);\n\nexport function isAggregateOp(a: string | ArgminDef | ArgmaxDef): a is AggregateOp {\n  return isString(a) && !!AGGREGATE_OP_INDEX[a];\n}\n\nexport const COUNTING_OPS: NonArgAggregateOp[] = ['count', 'valid', 'missing', 'distinct'];\n\nexport function isCountingAggregateOp(aggregate?: string | Aggregate): boolean {\n  return isString(aggregate) && contains(COUNTING_OPS, aggregate);\n}\n\nexport function isMinMaxOp(aggregate?: Aggregate | string): boolean {\n  return isString(aggregate) && contains(['min', 'max'], aggregate);\n}\n\n/** Additive-based aggregation operations. These can be applied to stack. */\nexport const SUM_OPS: NonArgAggregateOp[] = ['count', 'sum', 'distinct', 'valid', 'missing'];\n\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexport const SHARED_DOMAIN_OPS: AggregateOp[] = ['mean', 'average', 'median', 'q1', 'q3', 'min', 'max'];\n\nexport const SHARED_DOMAIN_OP_INDEX = toSet(SHARED_DOMAIN_OPS);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}